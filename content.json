{"pages":[],"posts":[{"title":"Capacitated Facility Location Problem","text":"本次算法项目中，我们被要求解决一个“仓库选址问题”。在该问题中，我们被给定了一定数量的顾客和一定数量的仓库。每个顾客到不同的仓库有不同的服务成本，同时每个仓库也有最小的经营成本（这意味着一旦仓库服务了顾客，其就会产生一个额外的成本）。我们的目标是寻找到一个顾客分配方案，使得总的服务成本（包含经营成本）最少。 FLP 是一个经典的 NP 难问题，CFLP 也一样。由于 NP 难问题夸张的求解时间复杂度，我们不能够寻求一个常规的，最优的方案来求解。相对的，我们只能够构建一个能够收敛到近似全局最优的启发式算法来获得一个近似解。 在本次项目中，我们选择了 爬山算法（Hill Climbing Algorithm）） 和 遗传算法（Genetic Algorithm） 作为我们的代码实现，并通过对比来寻求二者间的差异。 代码仓库 为什么选择 HC 和 GA？HC 和 GA 是启发式算法的两大代表。其中前者是普通的启发式算法，通过不断寻求临域中的最优解来不断迭代，最后爬上“山峰”（即最优解）。但是这种算法存在严重的问题，它没有任何能力来避开局部最优解，因而当其收敛时，其到达的一般只是众多山峰中的一个较小的山峰（局部最优解）。与之相对，GA 作为一种经典的元启发式算法，有着一定的脱离局部最优陷阱的能力，因而通常能够在最后获得一个比 HC 更好的解。 Hill Climbing 爬山算法爬山算法正如之前所说，是选择领域解池内估价最高的一个解来作为下一跳的起点。更数学化地来说，理想的爬山算法是在函数曲线（面）上的一个点，向着函数梯度方向爬升（下降）。因而如何在离散解集中生成梯度方向的解是爬山算法中的关键。 在本项目中，我们在每个解集输入时记录每个顾客的最低 Assign Cost 和其对应的工厂。然后，我们在生成一个解后，依次替换解中每个顾客的选择为其最低 Cost 值，再从之中选择最优值。如此迭代，最后能取得非常优秀的解（对于 P1，该方法可以收敛到 9300 的总 Cost）。并且得益于非常小的临域空间和无随机干扰（收敛条件可以设置为两次迭代间最优数值没有变化，而不需要继续迭代数次确保收敛）的缘故，其运行速度极快（对于所有测试数据集，算法运行时间均不超过 1 秒（在 MacBook Pro 2017 上测试，使用 g++ 编译））。 结果表格 详细结果 Genetic Algorithm 遗传算法在遗传算法中，我们没有像爬山算法那样“功利”。我们随缘地生成一堆「个体」，或者说「种群」。每个个体持有一个基因，也就是一个问题的可能（但可能非法的）解，然后每次迭代时，我们从其中选取一定数量的个体（通过 K = 2 的竞技场算法）。之后我们令这些个体两两配对，取出双方的基因的拷贝，按给定概率对于基因进行交叉/编译，然后将这些基因用于生成新的个体，并加入下一代种群中。如此一来，就如同大自然的优胜劣汰一般，优秀的基因被不断保留，组合，又结合变异产生的随机扰动，最后更有可能达到一个全局最优值。 在本项目中，我们推荐您使用 20% 的交叉概率，5% 的变异概率，20 的种群大小，来达到结果优秀程度和算法收敛速度的较好平衡。我们在自有平台上测试结果如下： 结果表格 详细结果 算法结果对比在两个算法的表格中我们可以明显看到（以 p1 和 p59 为例）： 算例 爬山算法结果 遗传算法结果 爬山算法耗时 遗传算法耗时 p1 9327 9033(-294, -3%) 0 3(+3, +&gt;1000%) p59 39121 37423(-1698, -4%) 0 9(+9, +&gt;1000%) 正如我们上面讲的一样，爬山算法的优势在于梯度下降，速度极快，它很快地收敛到了一个局部最优解，而遗传算法在其上更进一步，虽然速度比爬山算法慢了非常多，但是也在较短时间内收敛到了一个优秀解。更重要的是，这个解普遍比爬山算法优秀一些，尤其是在算例规模较大的情况下，这得益于其随机扰动带来的走出局部最优的可能性。但相应的，庞大的解空间为其带来了不小的困扰。 但值得一提的是，这个结果并不能完全显示两者的差距。在遗传算法中，我几乎不需要考虑原本的估价函数的影响因素，也不需要担心生成新解的函数是否能够让解沿梯度下降方向前进——我只需要让种群自己进化，为他们提供交流基因和改变基因的可能就好了。在设计速度上，遗传算法要远胜爬山算法。而在执行效果上也是如此，尤其是对于那些估价函数性质不明显，影响因素不确定的问题，爬山算法可能同样需要面对一个巨大的临域空间，从而难以找到梯度方向，最终得到一个更差的结果，且消耗更久的时间。 在这个特殊 CFLP 中，爬山算法的优点被发挥到了极致，但纵然如此，它也不过是和遗传算法互有胜负。因而我们认为，在更复杂、一般的问题中，遗传算法通常会是一个更好的选择。","link":"/Algorithm/Capacitated-Facility-Location-Problem/"},{"title":"16340258-Hairi Final Report","text":"简短的课程学习自我总结负责内容在本次项目中，我任职 JavaScript 工程师，主要负责服务端开发、设计并编写 RESTful API 和通过 Swagger 可视化 OpenAPI 文档。在项目开发后期，我还参与前端开发，协助完成了自定义问卷渲染、前端与服务端对接等工作。在过程中，我了解到了 RESTful API 的设计模式，其设计理念的内在逻辑以及 OpenAPI 使用方法与 Swagger 可视化中的问题。另一方面，我参与解决了各端代码成品的构建问题，并协助解决了跨域测试等问题。同时，我还负责了部分的会议记录绘制、文档框架构建和图形绘制工作。 PSP2.1 表格 Personal Software Process Stages Time (%) Planning 计划 15 estimate 预估任务时间 6 documents 调研文档撰写 8 Development 开发 70 analysis 需求分析 10 design spec 生成设计文档 10 design review 设计复审 2 coding standard 代码规范 2 design 具体设计，包括绘制 UI，设计架构等 5 coding 具体编码 25 code review 代码复审 5 test 测试 16 Report 报告 15 test report 测试报告 8 size measurement 计算工作量 2 postmortem &amp; process improvement plan 每次迭代结束后写总结文档，并提出改进计划 5 个人分支 Git 统计报告以下为截止2019年6月26日的截图 文档 服务端 前端 特别感谢 16340261 BroInBro：利用丰富的项目经验，为项目引入了诸多先进的自动化部署、检测、报告工具，规范了业务代码，提供了多种便于团队开发的建设性意见。同时他还完善了大部分项目文档，主导了服务端和前端开发，辅助各端使用成熟的软件架构模式进行开发，为全栈开发提供了强有力的技术支持。 15344015 快乐舔狗：为后端架构引入了诸多先进技术，构建了高一致性的分布式数据库管理程序，设计了完备的数据库表单。 16340284 张三丰：为各端提供了专业的信息安全指导，提出了以 HTTPS 和 AES 为核心的数据安全保证机制，确保了系统的信息安全。 16340122 Cynthia：为前端和服务端提供了高质量的数据有效性校验模式，助力各端开发，完成了诸多示例图的绘制。 16340256 无情咸鱼：前端的主要构建人员，选定并构建了前端框架，设计并实现了大部分的前端界面。","link":"/SSAD/16340258-Hairi-Final-Report/"},{"title":"First Article","text":"This is my real first blog, and this will be a place for me to display my projects. What’s coming…Hello! This is SiskonEmilia, and my github page is SiskonEmilia.In the next days, I’ll try to post all my WEB assignments to this bolg, and I might post a summury as well. You can find all source code of it at My Repository. About HexoDeploy web pagesA huge problem I found while trying to deploy is that, I only know how to post a markdown file. But there do be a way to post a web page on this bolg.The only thing you need to do is execute: 1hexo new page \"Page Title\" I’ll test this command in the next posting. Quick DeploymentActually, here’s some command that helps you generate and deploy a hexo website more quickly: 1hexo d -g This command means generate and then deploy the website to the remote link.","link":"/Hexo/First-Article/"},{"title":"Comment on Github Page with Gitment","text":"Last time, I added visitor statics system to my github page with Busuanzi. But a blog without a comment system is still not good enough. After hours of searching and testing, I finally implement it with a tool called Gitment. And if it works, you will be able to see a comment box below after you enter an article. (I didn’t set one on the home page.) And this article is an addition to the official guide, which might be more easy to understand and practice. What is GitmentAccording to the official document: Gitment is a comment system based on GitHub Issues, which can be used in the frontend without any server-side implementation. Actually, it create a issue for every article in your blog, and then every comment you add to the article will be added into the issue as well. And the OAuth mentioned in the official guide is used to get the access permission of your repository. Get Started with HexoThe official guide actually tells you about how to build a comment system, but not about how to build it under a particulay framework. And here’re some advices about building it under Hexo. Where should I add my comment boxIf you are using the default theme , I recommend you to add it in your /themes/landscape/layout/_partial/article.ejs, after the article tab like this: 12345678910111213141516&lt;% if (!index) { %&gt;&lt;div id=&quot;gitmentContainer&quot;&gt;&lt;/div&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;&lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment({ owner: &apos;your user name&apos;, repo: &apos;your repo name&apos;, oauth: { client_id: &apos;your client id here&apos;, client_secret: &apos;your client secret here&apos;, },})gitment.render(&apos;gitmentContainer&apos;)&lt;/script&gt;&lt;% } %&gt; After you doing that, you will find a comment box under every article of yours. If you want to display a comment box on your home page, you’d better move this part to your footer.ejs and add it to the beginning of your file. Why does Github return a 404 while I am trying to use itPlease check your repo property. It should be your repository’s name or id, not URL or something like that. Feel free to comment!","link":"/Hexo/Comment-on-Github-Page-with-Gitment/"},{"title":"Get Started with Unity3D - 5","text":"Escape with Unity-Chan v2.0 !B站视频 和Unity酱逃出生天第二弹！ 这次Unity酱来到了精灵森林，在本次游戏中，你将看到环绕着Unity酱上下飞舞的光精灵，在森林中驻足的水精灵和火精灵……以及动听的背景音乐！ 效果预览： 精灵制作因为基本按照大神博客制作，因而此处不再赘述精灵的基本制作方法，我们将着重讲讲不一样的地方～ 精灵效果预览： 首先：如何产生精灵「闪耀的效果」呢？ 通过 Start Lifetime 结合 Emission 的 Rate over Time 实现～因为在按照博客设置后，粒子有 Size over Lifetime 属性，这使得每个粒子首先出现时变大，然后在消失时变小。从而，错开的发射时间和消失时间能够使由多个粒子叠加出来的光晕产生忽大忽小的「闪耀的效果」。当然～给它添加一个点光源也是它闪闪发亮的一大原因～ 接下来：如何让精灵有一条闪光的，徐徐下降的尾巴呢？ 在博客中的设置应用后，我们能够得到的是所有掉落的“星星”都会跟随精灵的效果。这是因为我们将子粒子系统的 Simulation Space 设置为了 local，在这个情况下，粒子会跟随发射器的坐标系运动。那么如何让它摆脱束缚呢？简单地将它设置为 World 就好啦～同时，为了达成「徐徐下降」这一效果，我们将 Gravity Modifier 设置为了一个不为 0 的较小值。这样以后，你就能看到那条美丽的尾巴了。 最后：如何让精灵环绕角色上下飞舞呢？ 环绕角色是容易理解的，我们只需要设置一个空对象，把粒子系统作为它的子对象，之后将其位置实时更新为角色位置，最后旋转这个空对象即可。至于上下飞舞，则是通过 sin 函数结合当前时间的数据成员来实现的。","link":"/Unity3D/Get-Started-with-Unity3D-5/"},{"title":"Get Started with Unity3D - 6","text":"天色天歌天音 - Unity 换装游戏B站视频 注：视频有声音，请开大音量食用。 游戏预览： 制作起因「忘不了的记忆，不要忘记的记忆，然而却最终再也找回不了的记忆……」——《9-nine 天色天歌天音》 原本我们应该仿照 UGUI 的官方例子做一个装备栏／背包系统，但是最近笔者被一款游戏的剧情深深打动，不自禁地便为其女主角做了这样一款换装游戏。我认为你们都该玩一下《天色天歌天音》！（虽然结局很烂） 在本游戏里，你不仅可以为她选择可爱的衣服，还能调整她的表情、改变她的姿势，以及更换游戏的场景。为你心目中的她构造出最美的画面吧～ 操作指南点击物品栏中物品即可选中该物品，在装备栏处点击即可将物品放入装备栏。只有当表情、服装、动作齐全时，人物的立绘才会更换。 技术细节3D UI3D UI 的构建较为简单。首先，我们创建一个 Canvas 然后在其下再创建一个子 Canvas，并且再之下新建两个 Panel，分别用于“物品栏”和“装备栏”，以及一个额外的 Image 用于之后的拖拽使用： 为两个 Panel 添加 Grid Layout Group 之后，我们就可以向其中添加绑定了 Button 组件的 Image 了，它也就是我们的单个物品栏。 在根据需要改变锚点和位置属性后，我们为两个 Panel 绑定脚本，使之会根据鼠标的移动缓慢改变朝向： 123456789101112131415161718192021222324252627282930using System.Collections;using System.Collections.Generic;using UnityEngine;public class FaceWindow : MonoBehaviour { public Vector2 range = new Vector2(5f, 3f); Transform panelTransform; Quaternion panelRotate; Vector2 panelFacing = Vector2.zero; // Use this for initialization void Start () { panelTransform = transform; panelRotate = panelTransform.localRotation; } // Update is called once per frame void Update () { Vector3 mousePosition = Input.mousePosition; float halfWidth = Screen.width * 0.5f; float halfHeight = Screen.height * 0.5f; float x = Mathf.Clamp((mousePosition.x - halfWidth) / halfWidth, -1f, 1f); float y = Mathf.Clamp((mousePosition.y - halfHeight) / halfHeight, -1f, 1f); panelFacing = Vector2.Lerp(panelFacing, new Vector2(x, y), Time.deltaTime * 5f); panelTransform.localRotation = panelRotate * Quaternion.Euler(-panelFacing.y * range.y, panelFacing.x * range.x, 0f); }} 至此，3D UI 已经基本构建完毕，接下来我们关心的是如何将 角色以及背景等场景元素 和 UI 分离的问题。这个问题也较简单：我们新建一个 GUI Camera，通过 Culling Mask 区分其和 Main Camera 的渲染内容即可： 物品栏和物品“拖拽”首先，物品要如何体现呢？很简单，我们之前制作物品栏的时候，每个 Grid 都包含有 Image 和 Button 两个组件，我们将 Image 的\b Source Image 设置为我们想要的图片就好了： 至于拖拽就比较麻烦了，还记得我们前面的用于拖拽的 Image 吗，这里它将派上大用场！首先，我们令其跟随鼠标： 123Vector3 camera = Camera.main.WorldToScreenPoint(transform.position);// 相机是世界的，世界到屏幕 Vector3 pos = new Vector3(Input.mousePosition.x + 40, Input.mousePosition.y - 40, camera.z);transform.position = Camera.main.ScreenToWorldPoint(pos); 然后，在每次点击物品栏中的物品时，我们将二者的 Image Source 交换，就有了“取出物品”的体验： 12345678910111213141516171819202122232425262728293031323334353637383940if (isEmpty){ if (gsm.GetMouse().GetMouseType() != -1) { equipType = gsm.GetMouse().GetMouseType(); GetComponent&lt;Image&gt;().sprite = gsm.GetMouse().present; content = gsm.GetMouse().content; gsm.GetMouse().present = null; gsm.GetMouse().SetMouseType(-1); isEmpty = false; }}else{ if (gsm.GetMouse().GetMouseType() == -1) { gsm.GetMouse().present = GetComponent&lt;Image&gt;().sprite; GetComponent&lt;Image&gt;().sprite = null; gsm.GetMouse().SetMouseType(equipType); gsm.GetMouse().content = content; isEmpty = true; equipType = -1; } else { var temp = gsm.GetMouse().present; gsm.GetMouse().present = GetComponent&lt;Image&gt;().sprite; GetComponent&lt;Image&gt;().sprite = temp; var tempc = gsm.GetMouse().content; gsm.GetMouse().content = content; content = tempc; var tempe = gsm.GetMouse().GetMouseType(); gsm.GetMouse().SetMouseType(equipType); equipType = tempe; } gsm.refresh();} 将物品放入装备栏也是同理，不再赘述。 如何“换装”单从 Unity 的角度来说，这是简单的。我们对每个人物部件进行标号，并且预先生成各种情况下的人物立绘，再根据装备栏的情况选择加载即可： 123456789101112131415161718192021public void refresh(){ getChar(); if (equippedItem1s[3].isEmpty) return; GameObject.Find(\"Background\").GetComponent&lt;SpriteRenderer&gt;().sprite = Resources.Load&lt;Sprite&gt;(\"bgimage/\" + equippedItem1s[3].content);}public void getChar(){ for (int i = 0; i &lt; 3; ++i) { if (equippedItem1s[i].isEmpty) return; } GameObject.Find(\"Character\").GetComponent&lt;SpriteRenderer&gt;().sprite = Resources.Load&lt;Sprite&gt;(\"figure/\" + equippedItem1s[1].content + equippedItem1s[2].content + equippedItem1s[0].content);} 真正的难点在于：如何把图片从游戏中提取出来并且组合成我们想要的形式呢？首先，我们要将数据包中的立绘资源（fgimage.xp3）取出（工具），取出来的东西大概是长这个样子： 看上去游戏里的角色被拆分成很多份存起来了……这是游戏为了节约内存空间而设计的。注意到文件夹中的 txt 文件了吗？它们指定了完整立绘的合成规则。借助一些小工具（百度一下就有～）我们就能合成出完整的立绘啦～ Enjoy Your Time with Her!","link":"/Unity3D/Get-Started-with-Unity3D-6/"},{"title":"Introducing gRPC","text":"何为 RPCRPC（Remote Procedure Call），远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC 协议假定某些传输协议的存在，如 TCP 或 UDP，为通信程序之间携带信息数据。在 OSI 网络通信模型中，RPC 跨越了传输层和应用层。RPC 使得开发包括网络分布式多程序在内的应用程序更加容易。 gRPCgRPC 是由 Google 牵头开发，语言中立、平台中立、开源的远程过程调用系统。其遵循一般的 RPC 系统的特点设计：即定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。 安装与测试运行开始之前…在安装和使用 gRPC 之前，我们首先需要安装 Protocol Buffers，它是Google 开发的一种数据描述语言，类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面。gRPC 依靠 Protocol Buffers 来定义服务。 安装通过如下命令即可安装 Protocol Buffers 和 gRPC：（由于引用了 Google 的 Golang 库，您可能需要代理运行） 12go get -u github.com/golang/protobuf/protoc-gen-gogo get -u google.golang.org/grpc 代理运行的方式： 1http_proxy=http://address:port go get ... 运行样例在我们刚才安装时获取的文件中，gRPC 为我们附带了其的运行样例，这个样例存储于 $GOPATH/src/google.golang.org/grpc/examples，下面我们以其中的 helloworld 为例进行讲解： 编译和运行首先，我们进入样例工作目录。注意，请确保您已经正确配置了 GOPATH 环境变量。 1cd $GOPATH/src/google.golang.org/grpc/examples/helloworld 在样例中，我们的文件都已经被正确编译为了 .pb.go 文件，实际上，这个文件是由服务定义文件 .proto 编译而来的。如果您想要自己编译，请使用我们通过 protoc-gen-go 引入的 protoc 编译器（请确保您的环境变量包含 \\$GOPATH/bin）。 接下来，我们编译并运行生成的服务端和客户端 go 文件： 1234# Run on terminal 1: Server sidego run greeter_server/main.go# Run on terminal 2: Client sidego run greeter_client/main.go 您会看到在客户端的终端界面中出现了 Greeting: Hello world，这表示我们的安装配置已经成功。 源码分析gRPC 是如何实现通过 go 语言满足我们在 proto 中定义的服务呢，我们可以通过分析生成的 go 语言代码来初步了解： 虽然我们通过 greeter_server/main.go 和 greeter_client/main.go 启动的 gRPC 服务，但这个服务真正的核心是他们共同引用的 helloworld/helloworld.pb.go。 首先我们看看 .proto 文件都写了些什么： 1234567891011121314151617181920212223242526272829// 指定 Protocol Buffer 的语法版本syntax = &quot;proto3&quot;;// 环境设置option java_multiple_files = true;option java_package = &quot;io.grpc.examples.helloworld&quot;;option java_outer_classname = &quot;HelloWorldProto&quot;;// 包名package helloworld;// 定义了 greeting 类，为其设计了一个自定义的方法，其接收一个 HelloRequest，返回一个 HelloReply// The greeting service definition.service Greeter { // Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply) {}}// 定义了消息类型 HelloRequest，其中有一个自定义 string 属性 Name// The request message containing the user&apos;s name.message HelloRequest { string name = 1;}// 定义了消息类型 HelloReply，其中有一个自定义 string 属性 message// The response message containing the greetingsmessage HelloReply { string message = 1;} 然后，我们抛开冗余的生成代码不看，helloworld.pb.go 实际上做了这几件事： 定义 HelloRequest 数据结构 123456type HelloRequest struct { Name string `protobuf:\"bytes,1,opt,name=name,proto3\" json:\"name,omitempty\"` XXX_NoUnkeyedLiteral struct{} `json:\"-\"` XXX_unrecognized []byte `json:\"-\"` XXX_sizecache int32 `json:\"-\"`} 其中，Name 是我们在 .proto 中定义的字段。 定义 HelloReply 数据结构 123456type HelloReply struct { Message string `protobuf:\"bytes,1,opt,name=message,proto3\" json:\"message,omitempty\"` XXX_NoUnkeyedLiteral struct{} `json:\"-\"` XXX_unrecognized []byte `json:\"-\"` XXX_sizecache int32 `json:\"-\"`} 其中，Message 是我们在 .proto 中定义的字段。 定义数据结构操作方法 12345678func (c *greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error) { out := new(HelloReply) err := c.cc.Invoke(ctx, \"/helloworld.Greeter/SayHello\", in, out, opts...) if err != nil { return nil, err } return out, nil} 除去一些基本的生成方法，这个方法定义了我们在 proto 中定义的方法，它允许客户端调用这个方法来向服务端发送一个 HelloRequest，并接受一个 HelloReply。 然后，我们就可以看到这些内容在服务端和客户端的使用了： 服务端： 服务端的 go 语言代码首先实现了我们在类文件中没有实现的定义： 1234func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) { log.Printf(\"Received: %v\", in.Name) return &amp;pb.HelloReply{Message: \"Hello \" + in.Name}, nil} 这样在其收到一个 HelloRequest 的时候就会调用这个方法来发送一个 HelloReply 给客户端。 然后，其监听给定端口，创建服务器对象，注册服务器并且将其绑定到端口上： 12345lis, err := net.Listen(\"tcp\", port)s := grpc.NewServer()pb.RegisterGreeterServer(s, &amp;server{})reflection.Register(s)err := s.Serve(lis) 客户端： 客户端首先尝试创建一个到服务端的连接，然后创建一个客户端对象，调用 SayHello 方法发送一个 HelloRequest 并回收一个 HelloReply： 12345conn, err := grpc.Dial(address, grpc.WithInsecure())c := pb.NewGreeterClient(conn)name := defaultNamectx, cancel := context.WithTimeout(context.Background(), time.Second)r, err := c.SayHello(ctx, &amp;pb.HelloRequest{Name: name}) 至此，运行两个 main.go 即可达到我们现前使用的效果，gRPC 服务也可正常运行。","link":"/Service-Computing/Introducing-gRPC/"},{"title":"Get Started with Unity3D Series","text":"简介该系列主要记录Unity3D编程设计课程作业，亦会记录一些学习过程中的心得 导航 Get Started with Unity3D - 1: 主要就是第一周的作业啦 Get Started with Unity3D - 2: 第二周作业～ Get Started with Unity3D - 3: 分离动作版的牧师与魔鬼，增加了Skybox和动态水面效果","link":"/Unity3D/Get-Started-with-Unity3D-Series/"},{"title":"Leetcode 135. Candy","text":"题目135. Candy Difficulty: Hard Total Accepted: 87.48K Total Submissions: 330.65K There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? Example 1: Input: [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.Example 2: Input: [1,2,2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions.解题报告AC 截图 题目大意本题给出一个等级队列，要求队列中每个孩子的糖果都至少为 1 个，且相邻的两个孩子中，等级较高者的糖果数较多。 解题思路我们可以将问题化为一个个子问题来看，再用贪心策略去解决每个子问题即可。更细节地讲，我们把问题分解为对于任意一个孩子，求他最小糖果数的问题。那么这个问题是简单的，我们只需要检查其左边和右边的孩子的糖果数和等级即可。对于没有计算的孩子，我们以 0 标识；而对于计算过的孩子，我们则直接存储它的糖果数。这样一来，我们就避免了许多重复的计算。应用上面的思路，我们就有了下面的题解： 题解1（最优解）1234567891011121314151617181920212223242526272829303132333435363738394041static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();class Solution {public: size_t size; int result = 0; int candy(vector&lt;int&gt;&amp; ratings) { vector&lt;int&gt; candies(size = ratings.size(), 0); for (int i = 0; i &lt; size; ++i) { result += getCandy(ratings, candies, i); } return result; } int getCandy(vector&lt;int&gt;&amp; ratings, vector&lt;int&gt;&amp; candies, int index) { if (candies[index]) return candies[index]; if (index &gt; 0 &amp;&amp; ratings[index - 1] &lt; ratings[index]) { if (index &lt; size - 1 &amp;&amp; ratings[index + 1] &lt; ratings[index]) { return candies[index] = (max(candies[index - 1], getCandy(ratings, candies, index + 1)) + 1); } else { return candies[index] = (candies[index - 1] + 1); } } else { if (index &lt; size - 1 &amp;&amp; ratings[index + 1] &lt; ratings[index]) { return candies[index] = (getCandy(ratings, candies, index + 1) + 1); } else { return candies[index] = 1; } } }};","link":"/Leetcode/Leetcode-135-Candy/"},{"title":"Leetcode 124. Binary Tree Maximum Path Sum","text":"题目124. Binary Tree Maximum Path Sum Difficulty: Hard Total Accepted: 145.3K Total Submissions: 519.8K Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. 解题报告AC 截图 题目大意给定一个非空的二叉树，我们需要找到一个路径，使得路径上所有节点的值的和最大。需要注意的是，该路径最少需要包含一个节点，同时这个路径可以不沿着树边「由父到子」的方向走，但是不可以回头。同时，这个路径也不需要经过根结点。 解题思路很简单的 DFS + 贪心算法就可以求解。因为路径可以不经过根节点，因而任何子过程都有可能产生一个最优解。为了记录这些最优解，我们建立一个全局变量来记录当前的最优解。考虑一条路径，以最上层的节点的视角，其有三种可能的形状：向左/右子树延伸，同时向两个子树延伸，以及一个裸节点。 其中，第一种情况和第三种情况的路径可以被上层节点复用，来构成新的路径；而第二种情况的路径则不能拓展，因为路径不能回头，因而不可能有分叉。因而，在每个子过程中，我们获取左右子树的非第二种情况的最大 sum 的路径，将其中大于 0 的都与节点的值相加，并尝试更新全局最大值。然后选择其中最大的大于零的 sum，与节点的值相加，并返回该值，作为「非第二种情况的最大值」。 然后，不要忘记加上 iostream 的加速装置～我们的最优解就出炉啦： 题解（最优解）C++ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return nullptr;}();/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int globalMax = 0; int maxPathSum(TreeNode* root) { globalMax = root-&gt;val; int maxSum = root-&gt;val, temp; temp = subtreeMax(root-&gt;left); if (temp &gt; 0) maxSum += temp; cout &lt;&lt; temp; temp = subtreeMax(root-&gt;right); if (temp &gt; 0) maxSum += temp; cout &lt;&lt; temp &lt;&lt; endl; if (maxSum &gt; globalMax) globalMax = maxSum; return globalMax; } int subtreeMax(TreeNode* subroot) { if (subroot == nullptr) return 0; int val = subroot-&gt;val, temp1, temp2; temp1 = subtreeMax(subroot-&gt;left); temp2 = subtreeMax(subroot-&gt;right); if (temp1 &gt; 0) { if (temp2 &gt; 0) { if (temp1 &gt; temp2) { val += temp1; if (val + temp2 &gt; globalMax) globalMax = val + temp2; return val; } else { val += temp2; if (val + temp1 &gt; globalMax) globalMax = val + temp1; return val; } } else { val += temp1; if (val &gt; globalMax) globalMax = val; return val; } } else if (temp2 &gt; 0) { val += temp2; if (val &gt; globalMax) globalMax = val; return val; } if (val &gt; globalMax) globalMax = val; return val; }};","link":"/Leetcode/Leetcode-124-Binary-Tree-Maximum-Path-Sum/"},{"title":"Leetcode 140. Word Break","text":"题目本题有两个不同难度的版本：139. Word Break 和 140. Word Break II。 139. Word Break Difficulty: Medium Total Accepted: 263K Total Submissions: 798K Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation.You may assume the dictionary does not contain duplicate words. Example 1: Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;] Output: true Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.Example 2: Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;] Output: true Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;. Note that you are allowed to reuse a dictionary word.Example 3: Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;] Output: false 140. Word Break II Difficulty: Hard Total Accepted: 133K Total Submissions: 520K Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note: The same word in the dictionary may be reused multiple times in the segmentation.You may assume the dictionary does not contain duplicate words. Example 1: Input: s = &quot;catsanddog&quot; wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;] Output: [ &quot;cats and dog&quot;, &quot;cat sand dog&quot; ]Example 2: Input: s = &quot;pineapplepenapple&quot; wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;] Output: [ &quot;pine apple pen apple&quot;, &quot;pineapple pen apple&quot;, &quot;pine applepen apple&quot; ] Explanation: Note that you are allowed to reuse a dictionary word.Example 3: Input: s = &quot;catsandog&quot; wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;] Output: []解题报告139. Word BreakAC 截图 题目大意给出一个非空字符串，判断其是否能够由字典中的单词组成。 解题思路设置一个布尔数组，对于其中下标为 i 的项，表示从起始字符到第 i 个字符为一个合法子串。其中，下标为 0 初始为 true。通过如下方式更新这个布尔数组： 对于下标为 i 的项，向前遍历布尔数组，如果第 j 项为 true，则判断从 j 到 i 的子字符串是否在字典内。若在字典内，则当前项置 true，退出内循环，并且继续向第 i + 1 项遍历更新。 在遍历完后，我们只需判断最后一项是否为 true 即可。 题解123456789101112131415161718192021222324252627class Solution {public: bool wordBreak(string &amp;s, vector&lt;string&gt; &amp;wordDict) { unordered_set&lt;string&gt; dict; for (auto &amp;iter: wordDict) dict.insert(iter); return wordBreak(s, dict); } bool wordBreak(string &amp;s, unordered_set&lt;string&gt; &amp;wordDict) { int size = s.size(); vector&lt;bool&gt; dp(size, false); dp[0] = true; for (int i = 1; i &lt;= size; ++i) { for (int j = i - 1; j &gt;= 0; --j) { if (dp[j]) { if (wordDict.find(s.substr(j, i - j)) != wordDict.end()) { dp[i] = true; break; } } } } return dp[size]; }}; 140. Word Break IIAC 截图 题目大意和上题基本一致，但是本题额外要求我们输出所有可能的分割情况。 解题思路把布尔数组换成一个二维数组。然后在字典内找到当前项的时候，不退出内循环，但是将 j 添加到第 i 项的数组内。最后我们只需要通过这些数组重建字符串即可。 题解12345678910111213141516171819202122232425262728293031323334353637static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();class Solution { vector&lt;vector&lt;int&gt; &gt; dp;public: vector&lt;string&gt; wordBreak(string &amp;s, vector&lt;string&gt; &amp;wordDict) { unordered_set&lt;string&gt; dict; for (auto &amp;iter: wordDict) dict.insert(iter); int size = s.size(); dp.resize(size + 1); dp[0].push_back(0); for (int i = 1; i &lt;= size; ++i) for (int j = i - 1; j &gt;= 0; --j) if (dp[j].size()) if (dict.find(s.substr(j, i - j)) != dict.end()) dp[i].push_back(j); return subQuestion(size, s); } vector&lt;string&gt; subQuestion(int index, string &amp;s) { vector&lt;string&gt; result; if (index) { for (auto &amp;iter : dp[index]) { auto strs = subQuestion(iter, s); if (strs.empty()) result.push_back(s.substr(0, index)); else { auto substr = s.substr(iter, index - iter); for (auto &amp;subResult : strs) result.push_back(subResult + \" \" + substr); } } } else return vector&lt;string&gt;(); return result; }};","link":"/Leetcode/Leetcode-140-Word-Break/"},{"title":"Leetcode 32. Longest Valid Parentheses","text":"题目32. Longest Valid Parentheses Difficulty: Hard Total Accepted: 152.4K Total Submissions: 632.8K Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: &quot;(()&quot; Output: 2 Explanation: The longest valid parentheses substring is &quot;()&quot;Example 2: Input: &quot;)()())&quot; Output: 4 Explanation: The longest valid parentheses substring is &quot;()()&quot;题目链接 解题报告AC 截图 题目大意本题要求我们寻找一个括号字符串中最长的合法符号子串长度 解题思路验证一个字符串是否是合法的括号字符串是简单的。我们只需要将其所有的左括号入栈，然后当右括号到来时弹出一个栈内括号，如果遇到栈为空，则判定为非法。若最后结束时没有括号剩余在栈中，则说明符号串合法。 由此出发，我们可以把所有匹配的串都加上一个标识，然后再扫一遍，找出最长连续的标识即可。整个算法的时间复杂度为 O(n)。 题解AC 截图 C++ 代码123456789101112131415161718192021222324252627282930313233343536373839static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();class Solution { public: int longestValidParentheses(string&amp; str) { int size = str.size(); int max = 0, counter = 0; vector&lt;bool&gt; validArr(size, false); stack&lt;int&gt; parentheses; for (int index = 0; index &lt; size; ++index) { if (str[index] == '(') parentheses.push(index); else if (!parentheses.empty()) { validArr[parentheses.top()] = true; validArr[index] = true; parentheses.pop(); } } for (const auto &amp;iter : validArr) { if (iter) { ++counter; } else { if (max &lt; counter) { max = counter; } counter = 0; } } return ((max &gt; counter) ? max : counter); }};","link":"/Leetcode/Leetcode-32-Longest-Valid-Parentheses/"},{"title":"Leetcode 44. Wildcard Matching","text":"题目44. Wildcard Matching Difficulty: Hard Total Accepted: 144.11K Total Submissions: 665.07K Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’. &apos;?&apos; Matches any single character. &apos;*&apos; Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *. Example 1: Input: s = &quot;aa&quot; p = &quot;a&quot; Output: false Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.Example 2: Input: s = &quot;aa&quot; p = &quot;*&quot; Output: true Explanation: &apos;*&apos; matches any sequence.Example 3: Input: s = &quot;cb&quot; p = &quot;?a&quot; Output: false Explanation: &apos;?&apos; matches &apos;c&apos;, but the second letter is &apos;a&apos;, which does not match &apos;b&apos;.Example 4: Input: s = &quot;adceb&quot; p = &quot;*a*b&quot; Output: true Explanation: The first &apos;*&apos; matches the empty sequence, while the second &apos;*&apos; matches the substring &quot;dce&quot;.Example 5: Input: s = &quot;acdcb&quot; p = &quot;a*c?b&quot; Output: false解题报告AC 截图 题目大意本题实际上是一个正则表达式的匹配问题，旨在检查字符串是否满足给定的正则表达式。正则表达式支持 ? 和 * 通配符，前者为单个字符的通配符，后者为任意字符序列（含空串）的通配符。 解题思路对于此类状态转换，最暴力的做法自然是直接 DFS/BFS 扫描一遍看是否满足即可，但是这样的方法有很大的风险造成 TLE： TLE 解AC 截图 C++ 代码12345678910111213141516171819202122232425class Solution {public: bool isMatch(string s, string p) { return isMatchSubquestion(s, p); } bool isMatchSubquestion(string s, string p) { if (s.size() == 0) return [&amp;](){ for (auto &amp;i : p) if (i != '*') return false; return true; }(); if (p.size() == 0) return s.size() == 0; switch(p[0]) { case '?' : return isMatchSubquestion(s.substr(1), p.substr(1)); case '*' : return isMatchSubquestion(s.substr(1), p.substr(1)) || isMatchSubquestion(s.substr(1), p) || isMatchSubquestion(s, p.substr(1)); default: return (s[0] == p[0]) &amp;&amp; isMatchSubquestion(s.substr(1), p.substr(1)); } }}; 题解分析如你所见，暴力搜索的算法果然暴毙了（当然弱智的 substr 也得背锅），重复的 * 带来了难以忍受的时间复杂度，因而我们不得不考虑其他方法（或是想方法去除重复的 *，但是这不能改变暴力搜索效率低下的本质）。 让我们考虑这样一个回滚算法。我们首先尽可能多地匹配两个字符串，然后一旦遇到表达式中的 *，则记录该位置并跳过他继续匹配。如果后续不匹配，则从上一个 * 位置之后的第 i 个位置继续匹配（i 为不匹配的次数），直到遍历完字符串或者表达式为止。 写作代码如下： 题解1（最优解）C++ 代码123456789101112131415161718192021222324252627282930313233static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();class Solution {public: bool isMatch(string&amp; s, string&amp; p) { int sIndex = 0, pIndex = 0; int pStarIndex = -1, sStarIndex = -1; int sSize = s.size(); while (sIndex &lt; sSize) { if (s[sIndex] == p[pIndex] || p[pIndex] == '?') { ++sIndex; ++pIndex; } else if (p[pIndex] == '*') { pStarIndex = pIndex++; sStarIndex = sIndex; } else if (pStarIndex &gt; -1){ pIndex = pStarIndex + 1; sIndex = ++sStarIndex; } else return false; } while(p[pIndex] == '*') ++pIndex; return (pIndex == p.size()); }}; AC 截图","link":"/Leetcode/Leetcode-44-Wildcard-Matching/"},{"title":"Leetcode 526. Beautiful Arrangement","text":"题目526. Beautiful Arrangement Difficulty: Middle Total Accepted: 31,338 Total Submissions: 59,005 Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 &lt;= i &lt;= N) in this array: The number at the ith position is divisible by i.i is divisible by the number at the ith position.Now given N, how many beautiful arrangements can you construct? Example 1: Input: 2 Output: 2 Explanation: The first beautiful arrangement is [1, 2]: Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1). Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2). The second beautiful arrangement is [2, 1]: Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1). Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.Note: N is a positive integer and will not exceed 15. 解题报告AC 截图 题目大意给定 1～N 的 N 个连续自然数，要求将其填入一个序列，使得对于序列上的每个位置，都有 位置序号可以整除或者被当前数字整除。 解题思路正常的思路： 动态规划或者直接暴力遍历。 奇怪的思路： 在编译阶段算出结果，然后直接调用结果即可。 题解结果截图无：Leetcode Bug C++ 代码12345678910111213141516171819202122232425262728static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();class Solution { int count = 0;public: int countArrangement(int N) { bool* visited = new bool[N + 1]; calculate(N, 1, visited); return count; } void calculate(int N, int pos, bool* visited) { if (pos &gt; N) ++count; for (int i = 1; i &lt;= N; ++i) { if (!visited[i] &amp;&amp; (pos % i == 0 || i % pos == 0)) { visited[i] = true; calculate(N, pos + 1, visited); visited[i] = false; } } }}; 奇怪的解法（打表简化版）（最优解）AC 截图 C++ 代码12345678910111213141516171819static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();static const int result[16] = { 1, 1, 2, 3, 8, 10, 36, 41, 132, 250, 700, 750, 4010, 4237, 10680, 24679};class Solution {public: int countArrangement(int N) { return result[N]; }};","link":"/Leetcode/Leetcode-526-Beautiful-Arrangement/"},{"title":"Leetcode 65. Valid Number","text":"题目65. Valid Number Difficulty: Hard Total Accepted: 99.5K Total Submissions: 753.7K Validate if a given string can be interpreted as a decimal number. Some examples:&quot;0&quot; =&gt; true&quot; 0.1 &quot; =&gt; true&quot;abc&quot; =&gt; false&quot;1 a&quot; =&gt; false&quot;2e10&quot; =&gt; true&quot; -90e3 &quot; =&gt; true&quot; 1e&quot; =&gt; false&quot;e3&quot; =&gt; false&quot; 6e-1&quot; =&gt; true&quot; 99e2.5 &quot; =&gt; false&quot;53.5e93&quot; =&gt; true&quot; --6 &quot; =&gt; false&quot;-+3&quot; =&gt; false&quot;95a54e53&quot; =&gt; false Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number: Numbers 0-9Exponent - “e”Positive/negative sign - “+”/“-“Decimal point - “.” Of course, the context of these characters also matters in the input. 解题报告AC 截图 题目大意检查一个字符串的内容（在删去前后缀的空格后）是否是一个合法的十进制数。 解题思路该题可以通过将字符串分块来令问题化为简单的子问题的组合。首先考虑有 E 的字符串，则我们只需要判断左边是否为一个合法小数，右边是否为一个合法整数。 对于一个小数字符串，我们只需要判断小数点左边和右边是否为一个合法整数。 对于一个整数字符串，我们只需要判断除了符号外，其他字符是否是一个合法数字即可。 坑点1. 和 .3 都是合法的数字。 题解AC 截图 C++ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { public: bool isNumber(string s) { int front = 0, last = s.size() - 1; for (; front &lt; last &amp;&amp; s[front] == ' '; ++front); for (; front &lt; last &amp;&amp; s[last] == ' '; --last); s = s.substr(front, last - front + 1); int indexOfE; if ((indexOfE = s.find('e')) != -1) { if (indexOfE != s.size() - 1) { return (isFraction(s.substr(0, indexOfE)) &amp;&amp; isInteger(s.substr(indexOfE + 1), true)); } return false; } else { return isFraction(s); } return false; } bool isFraction(string s) { s = s.substr(s[0] == '+' || s[0] == '-'); int indexOfDot = s.find('.'); if (indexOfDot != -1 &amp;&amp; indexOfDot != s.size() - 1) { return isInteger(s.substr(0, indexOfDot), false, true) &amp;&amp; isInteger(s.substr(indexOfDot + 1), false, true); } return isInteger(s); } bool isInteger(string s, bool checkMinus = false, bool allowZero = false) { if (checkMinus) { s = s.substr(s[0] == '+' || s[0] == '-'); } for (const auto &amp;iter : s) { if (iter &gt; '9' || iter &lt; '0') { return false; } } return allowZero || s.size(); }};","link":"/Leetcode/Leetcode-65-Valid-Number/"},{"title":"Leetcode 945. Minimum Increment to Make Array Unique","text":"题目945. Minimum Increment to Make Array Unique Difficulty: Middle Total Accepted: 5,139 Total Submissions: 12,879 Given an array of integers A, a move consists of choosing any A[i], and incrementing it by 1. Return the least number of moves to make every value in A unique. Example 1: Input: [1,2,2] Output: 1 Explanation: After 1 move, the array could be [1, 2, 3].Example 2: Input: [3,2,1,2,1,7] Output: 6 Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7]. It can be shown with 5 or less moves that it is impossible for the array to have all unique values.Note: 0 &lt;= A.length &lt;= 400000 &lt;= A[i] &lt; 40000 解题报告AC 截图 题目大意我们有一个可能有重复数字的数组，并且我们可以通过令某些元素 += 1 数次来消除重复。那么这样的操作最少需要多少次呢？ 解题思路由于题目给定了数组的长度和数组的最大长度，我们可以创建一个固定的，满足最大大小的数组，来统计每个数字出现的次数，然后当一个数字出现多次时，我们保留其中的一个，令剩余元素 += 1，如此递归，便能得到最终的解。 题解（最优解）结果截图 C++ 代码1234567891011121314151617181920212223242526272829303132static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();static short A[40000];class Solution {public: int minIncrementForUnique(vector&lt;int&gt;&amp; As) { memset(A, 0, 40000 * sizeof(short)); int result = 0, maxEle = 0, minEle = 40000; for (auto &amp;ele : As) { ++A[ele]; maxEle = max(maxEle, ele); minEle = min(minEle, ele); } for (int i = minEle; i &lt; maxEle; ++i) { if (A[i] &gt; 1) { A[i + 1] += A[i] - 1; result += A[i] - 1; } } if (A[maxEle] &gt; 1) result += (A[maxEle]) * (A[maxEle] - 1) / 2; return result; }};","link":"/Leetcode/Leetcode-945-Minimum-Increment-to-Make-Array-Unique/"},{"title":"Leetcode 948. Bag of Tokens","text":"题目948. Bag of Tokens Difficulty: Middle Total Accepted: 3,132 Total Submissions: 8,230 You have an initial power P, an initial score of 0 points, and a bag of tokens. Each token can be used at most once, has a value token[i], and has potentially two ways to use it. If we have at least token[i] power, we may play the token face up, losing token[i] power, and gaining 1 point.If we have at least 1 point, we may play the token face down, gaining token[i] power, and losing 1 point.Return the largest number of points we can have after playing any number of tokens. Example 1: Input: tokens = [100], P = 50 Output: 0Example 2: Input: tokens = [100,200], P = 150 Output: 1Example 3: Input: tokens = [100,200,300,400], P = 200 Output: 2Note: tokens.length &lt;= 10000 &lt;= tokens[i] &lt; 100000 &lt;= P &lt; 10000 解题报告AC 截图 题目大意初始状态下我们有 P 的能量，我们可以选择耗费 tokens[i] 的能量来将第 i + 1 个 token 换成一个点数，也可以耗费一个点数将第 i + 1 个 token 换成 tokens[i] 的能量。求最后最大的点数。 解题思路本题中，我们可以采用一个贪心策略，即是先将 tokens 排序，每次需要获得能量时，选择最大能量的，否则选择最小能量的。如此一来，在 power 足够时，我们就尽量获取点数，否则尝试用一个点数去交换能量，直到所有 token 都被消耗，或者只剩一个 token，且无足够能量为止。 题解（最优解）结果截图 C++ 代码12345678910111213141516171819202122232425262728static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();class Solution {public: int bagOfTokensScore(vector&lt;int&gt;&amp; tokens, int P) { sort(tokens.begin(), tokens.end()); if (tokens.size() == 0 || P &lt; tokens[0]) return 0; int count = 0, sum = P, begin = 0, end = tokens.size() - 1; while (sum &gt;= tokens[begin] &amp;&amp; begin &lt;= end) { sum -= tokens[begin++]; ++count; } while (begin &lt; end - 1) { sum += tokens[end--] - tokens[begin++]; while (sum &gt;= tokens[begin] &amp;&amp; begin &lt;= end) { sum -= tokens[begin++]; ++count; } } return count; }};","link":"/Leetcode/Leetcode-948-Bag-of-Tokens/"},{"title":"Let's have a cup of Gin.go","text":"最终制品：CloudGo-IO，是一个在 CloudGo 的基础上开发的基于 Gin 框架开发的简单的 WEB 服务程序，支持静态文件服务、JavaScript 请求响应、模板输出、表单处理等功能。具体来讲，我们实现了一个拥有美观界面的支持用户注册和信息查看的网页。用户可以在其上登录他们的信息，然后通过相应的页面查看（表格太丑，做了些样式）。支持多个用户信息的存储和访问。支持用户查重、信息查重、信息格式查错。 下面我将带你走进 Gin 的神奇世界！ 使用 CloudGo-IO配置好 Golang 环境的前提下，运行以下命令安装并使用 CloudGo-IO： 123go get github.com/siskonemilia/CloudGo-IOgo install github.com/siskonemilia/CloudGo-IOCloudGo-IO [-h/--hostname hostname] [-p/--port port] 然后你就可以访问 http://hostname:port 了，比如默认的 http://localhost:8000，来使用功能了。一开始你会看到的是一个注册界面，在注册完成后你会自动跳转到信息页面。在知道其他用户的用户名的前提下，你也可以通过 http://hostname:port/detail?username=username 来查看其他用户的信息。 什么是 Gin？Gin 是一个开源的，高性能的 Golang WEB 框架，是目前 Golang 开发中最受欢迎的 WEB 框架之一。Go WEB Framework Stars 是 Github 上整理流行 Go WEB 框架的仓库。在这个仓库给出的列表中，Gin 雄踞榜首。作为一个易于使用的框架，Gin 还拥有其他框架无法比拟的超强性能，这一切都造就了它作为 Go WEB 框架王者的身份。顺带一提，Gin 的名字来源于鸡尾酒的基酒「Gin 金酒」，因为他的 API 是类似于另一个有名的 Go WEB 框架：「Martini 马天尼」（一种著名的，以金酒为唯一基酒的古典鸡尾酒饮品）。 Gin 框架基本用法首先引用 Gin，然后我们就可以开始我们的开发之路了： 123import( \"github.com/gin-gonic/gin\") Gin 框架非常类似于我之前在 Node.js 开发时使用过的服务端框架：Express.js。他们都是实例化一个路由器（Router），然后对这个 Router 添加各种 Route 规则（也就是把特定路径的请求导向特定的处理函数）。如下例： 1234567router := gin.Default()router.GET(\"/getPath\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"key\": \"value\", })})router.Run(\"127.0.0.1:8000\") 该例中，我们实例化了一个 Gin 的默认路由器，并且指定对于 /getPath 路径发起的 GET 方法将会由后面的处理函数接管。这个处理函数接受一个 *gin.Context 对象（其中包含了 Request 和 Response），并且完成所有的输入和输出的处理。在这里，它没有理会客户端发来的内容，而是简单地发挥了一个状态码为 200 的 JSON 响应。在最后，我们将服务器设置在了 127.0.0.1:8000 上，运行之后，客户端就可以访问 http://127.0.0.1:8000/getPath 来查看结果了。 类似于上面的例子，Gin 还支持 POST、DELETE 等所有的 HTTP 请求，提供了多种预制的返回格式（HTML、XML等），使用起来非常方便，并且性能比语法相似的马天尼框架好大约 10 倍。 静态文件服务在 Gin 中，静态文件服务的搭建是简单的。我们只需要为路由器指定一个 Static Route 即可： 123router.Static(\"/public\", \"public\")// Now all visit towards /public will be served with// the target file in ./public. JavaScript 请求响应 &amp; 表单处理以 POST 方法的 Ajax 为例。当客户端试图通过 Ajax 的 POST 方法向服务端发起请求时，它实际上是向服务端发送了一个 POST 方法的表单数据。因而，我们实际上是处理一个表单数据，gin 也为我们提供了完备的支持： 1234567891011121314151617181920// This type is used to bind data sent to// the server side.type registerJSON struct { Username string `form:\"username\" binding:\"required\"` Stuid string `form:\"stuid\" binding:\"required\"` Tel string `form:\"tel\" binding:\"required\"` Email string `form:\"email\" binding:\"required\"`}// Create an instance of that type to bind datavar user registerJSON// Try to bind the data sent from client sideif err := c.Bind(&amp;user); err != nil { c.JSON(http.StatusBadRequest, gin.H{ \"code\": \"BAD_REQUEST\", \"message\": \"Something wrong with the server\", }) fmt.Println(err.Error()) return} 在这段代码中，我们首先定义了一个用于绑定数据的类型，并且为其指定了字段。所谓的「绑定数据」指的是我们将会把 request.body 中的数据按字段填入到这个类型的实例中。在上面的示例代码中，我们为其分配了表单中的字段，从而使它可以去解析一个 POST 表单。进而进行进一步的逻辑处理。通过 Bind 方法，我们就能将请求中的数据悉数传入到给定的绑定实例上，而如果有任何问题发生，一个 err 将会被返回给你。 模板输出Gin 支持众多的模板，但是简单起见，我们这里就使用最简单的 HTML 模板来做示例。那么，我们首先说说如何创建一个 HTML 模板吧。这种模板和普通的 HTML 区别不大，我们这里需要使用到的就是它的「变量」特性。在 HTML 模板中，所有的变量被标识为 {.VariableName} 的格式，这些被称为变量的字符串可以在渲染阶段被服务端轻易而统一地替换为有意义的字段。最后，我们把 .html 的后缀改为 .tmpl 即可。 为了加载一个 HTML 模板，我们需要使用 LoadHTMLGlob 或是 LoadHTMLFiles 方法： 12router.LoadHTMLBlob(\"views/*\")// Load all files in folder views 之后，我们就可以在需要的地方这样子使用模板渲染一个 HTML 返回给用户了： 1234c.HTML(http.StatusOK, \"ATemplate.tmpl\", gin.H{ \"variable1\": value1, \"variable2\": value2,}) 这样，用户收到的将会是一个变量被替换为对应值的 HTML。 「未实现」与 404对于 /unknown 的「未实现」报错，我们也可以简单地通过最基本的语法实现： 123456router.GET(\"/unknown\", func(c *gin.Context) { c.JSON(http.StatusNotImplemented, gin.H{ \"code\": \"NOT_IMPLEMENTED\", \"message\": \"This page has not been implemented.\", })}) 而对于 404 问题，Gin 提供了非常贴心的 NoRoute 方法，他可以捕获所有未能通过 Route 方法指定处理函数的请求，并且分配处理函数： 1234567// PAGE_NOT_FOUND page for all paths without routingrouter.NoRoute(func(c *gin.Context) { c.JSON(http.StatusNotFound, gin.H{ \"code\": \"PAGE_NOT_FOUND\", \"message\": \"Target page not found.\", })}) 这样用户就知道「服务器没有挂掉，只是我的网址写错了」啦。","link":"/Service-Computing/Let-s-have-a-cup-of-Gin-go/"},{"title":"Make Full Use of Your VPS Server","text":"【预告】相信很多小伙伴都有一个自己的 VPS 服务器，可是大多数人只是在上面挂载一个 SS/SSR 服务器（这篇里也有讲），然后就对它不管不问了……看看你们 VPS 的 CPU 利用率，这难道不是在暴殄天物嘛！如果你和我一样有 VPS 资源被白白浪费的苦恼，那么这篇文章或许能解决你的问题～【本文长期更新】 如何利用你的 VPS 服务器 如何利用你的 VPS 服务器 从登陆你的 VPS 开始说起 如何翻过那堵神秘的东西 傻瓜式一键解决方案！ 一步步搭建才最有成就感～ 一个私有的 GIT 仓库 你的服务器不仅可以用来挂梯子，还能用来膜 从登陆你的 VPS 开始说起如何翻过那堵神秘的东西傻瓜式一键解决方案！一步步搭建才最有成就感～一个私有的 GIT 仓库你的服务器不仅可以用来挂梯子，还能用来膜","link":"/Tips/Make-Full-Use-of-Your-VPS-Server/"},{"title":"Remote Floder for Your Parents","text":"On Otc.1, I bought a new netobook computer for my mother. But it seems that this item severely comfuse her, that she stored all the files she wants to use in her old one. Thus, I want to find a good way for her to fetch files from her old computer easily. And the problem is, although she has used computer for years, she’s still almost fresh to it. I have to find a approach which is quite easy to use and study. I finally chose remote floder with UNC to teach her. Why remote floderI know someone may advice me to build a FTP server on her old computer, but there do be some problems if I want to do that. First of all, as her old computer is running on Windows, it will be complex to deal with those comfusing settings of windows firewall and service layout. Secondly, my mom is quite aged to type in an IP address whenever she wants to get her file from the old divice. Compared with FTP server, a remote floder can be easily use like a normal windows explorer. And all I need to do is set a static IP address for her old device and write a .bat file for her to use quickly and easily. And what the .bat look like will be: 1start explorer \"\\\\192.168.1.xxx\" It will be easy to build and to use. I hope my mom will like it.","link":"/Others/Remote-Floder-for-Your-Parents/"},{"title":"Software System Analysis and Design Assignment 1","text":"系统分析 第一次作业 熊永琦 16340258 简答题 软件工程的定义 软件工程是一个系统的，可控的，有质量保证的开发、操作和维护软件的方法的应用，即对于软件的工程学的应用和对其方法的研究。 解释导致 software crisis 本质原因、表现，述说克服软件危机的方法 软件危机（Software Crisis）是指计算机发展所导致的软件危机，是计算力增长的情况下，编程方法论落后所带来的软件开发、操作和维护危机。其本质原因是随算力高速增长的软件需求和落后的软件生产方式不匹配。 它表现为： 软件项目超预算运作 软件项目超时限运作 软件产品运行低效 软件产品质量低下 软件产品时常不符合客户要求 软件项目管理困难，难以维护 软件产品从不被交付 要解决软件危机，需要开发更为先进的软件生产方法（如函数式、面向对象编程）和项目管理办法（如敏捷开发、螺旋式开发）来提升软件质量管理能力。总的来说，就是要开发和应用更先进的软件工程方法。 软件生命周期 软件生命周期（Software Life Cycle），是在软件工程学中用于描述软件计划、创建、测试、部署的过程的模型。它在时间维度上对软件项目任务进行了划分。其旨在基于用户需求，生产高质量的系统来满足甚至超过客户的需求。 SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide 请中文翻译其名称与简短说明） Software Requirements 软件要求 软件要求知识域包含发掘需求、协商、分析、特化和软件要求的验证。 Software Design 软件设计 软件设计知识域包含架构、组件、接口和系统或部件的其他特点的设计过程以及设计过程的结果。 Software Construction 软件构造 软件构造指的是通过细节设计、编码、单元测试、整合测试、调试和验证的结合来进行软件产品的细节创建中的一切过程。其知识域包含软件构造基础，管理软件构造，构造技术， Software Testing 软件测试 软件测试是为了验证产品质量并且通过指出缺陷来增进软件质量的活动。这包含了通过一组有限的测试样例来验证程序是否按预期行为运行。其知识域包含软件测试、测试技术、人机交互测试和验证、测试相关的度量，和实际操作中的注意事项。 Software Maintenance 软件维护 软件维护知识域包含软件维护基础（即维护的性质和需求，维护的领域和考校），软件维护的关键问题（包括技术问题、管理文问题和维护开销估计和软件维护度量），维护过程，维护技术（包含程序理解、重构、反向工程、淘汰、重调），灾难性恢复技术和维护工具。 Software Configuration Management 软件配置管理 软件配置管理知识域包含对于软件配置管理过程的管理，软件配置的识别、控制、状态审计、软件发布管理和交付，以及软件配置管理工具。 Software Engineering Management 软件工程管理 软件工程管理知识域包含初始化、作用域管理（决定和协商要求，可行性分析，对于要求的审查和重阅）、软件项目实施（估测、报告、控制、上下游合同管理）、产品接收、审查和分析向性能、项目必报和软件管理工具。 Software Engineering Process 软件工程过程 软件工程过程知识域包括定义、实现、估计、评估、管理和改进软件生命周期过程。 Software Engineering Models and Methods 软件工程模型和方法 软件工程模型和方法知识域指明了包含多个生命周期阶段的方法、用于特定生命周期阶段的方法由其他知识域来涵盖。 Software Quality 软件质量 软件质量知识域包含软件质量基础（软件工程文化、软件质量特点、软件质量的价值和消耗、改良软件质量）、软件质量管理过程（软件质量确保、验证和有效性检验、评估和审计）、实际操作中的注意事项（缺陷描述、软件质量评估、软件质量工具）。 Software Engineering Professional Practice 软件工程专业实践 软件工程专业实践知识域包含专业性知识（专业结论、专业社群、软件工程标准、雇员合同以及法律问题）、道德条律、开发小组动力（团队合作、认知问题复杂度、与股东进行互动、解决不确定性和歧义、解决多文化环境）以及社交技能。 Software Engineering Economics 软件工程经济 软件工程经济知识域关心如何在商业语境下做出决定来使组织内技术决定与商业目标达成一致。 Computing Foundations 计算机基础 计算基础知识域包含一些提供软件工程实践所必须的计算机基础相关的主题。 Mathematical Foundations 数学基础 计算基础知识域包含一些提供软件工程实践所必须的数学基础相关的主题。 Engineering Foundations 工程学基础 计算基础知识域包含一些提供软件工程实践所必须的工程学基础相关的主题。 简单解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。 Level 1 - Initial：没有可预知的生产过程，缺乏控制和应变能力 Level 2 - Managed：生产过程为每个项目特制，一般有一定的应变能力。 Level 3 - Defined：生产过程为组织所定制，并且积极主动。 Level 4 - Quantitatively Managed：生产过程可测度（预知）且可控。 Level 5 - Optimizing：生产专注于过程优化。 用自己语言简述 SWEBok 或 CMMI （约200字） CMMI，即 Capability Maturity Model Integration，是一个由 CMU 软件工程协会下小组开发的，过程级别的优化训练和评估程序。它提供了开发和改进满足组织商业需求的开发过程的建立与改善的指导。一个 CMMI 模型也可被用作评估组织生产流程成熟程度的框架。CMMI 模型由五个级别构成：Initial、Managed、Defined、Quantitatively Managed 和 Optimizing。通过匹配和学习不同的级别的标准，企业或组织可以根据需要在开销、调度、生产力、生产质量和用户满意度等多个方面改善企业生产效率，提高企业或组织的行业竞争力。","link":"/SSAD/Software-System-Analysis-and-Design-Assignment-1/"},{"title":"Software System Analysis and Design Assignment 2","text":"系统分析 第二次作业 熊永琦 16340258 简答题 用简短的语言给出对分析、设计的理解。 分析 Analysis：其任务是根据客户的需求，提取用户的具体需求，并基于此构建需求模型，并给出初步的软件架构。其重点在于调查问题和需求本身，而不是最后的解决方案。这包括改进使用案例（场景）模型、定义用户需求模型、定义候选的架构、改良架构。 设计 Design：其任务是根据分析得到的需求模型和使用场景，设计出能够满足需求模型和使用场景的软件框架。其最关心的是一个能够满足要求的概念上的解决方案（的设计），而不是解决方案的实现。这包括设计使用案例（场景）的具体实现、开发设计模型、开发部署模型。 用一句话描述面向对象的分析与设计的优势。 不同领域的，或者说负责不同阶段任务的专业技术人员不必要知道其他领域的专业知识，他们可以通过一种共同的，事先约定的记号语言来进行交流。 简述 UML（统一建模语言）的作用。考试考哪些图？ UML 的作用 作为草图：UML 可以用于来创建那些用于探索不同问题和不同可能解决方案的非正式、未完全的图样。 作为蓝图：UML 可以用于反向工程，构建已有代码的示意图来更好地理解现有工程结构，同时也可以帮助工程师更好地将结构化工程转换为代码。 作为编程语言：UML 可以构建一个可执行的软件系统，并自动生成可运行的代码。 考察四类共十种视图： 用例图：从用户角度出发，描述软件功能和执行者。 静态图 类图：描述类之间的概念和关系。 对象图：描述某个时间状态内系统中的对象和他们之间的关系。 包图：描述系统的分解结构。 行为图 交互图：描述对象间的消息传递。 状态图：描述对象的动态行为。 活动图：描述系统为完成某项功能而执行的操作序列。 实现图 构件图：组成部件及其关系。 部署图：物理体系结构和软件单元间的对应关系。 从软件本质的角度，解释软件范围（需求）控制的可行性 软件内在本质是软件危机的根源，为了满足用户增长的需求而设计和实现的计算机程序即为软件。然而大多数情况下，客户与开发者能就项目的少量内容给出严格的需求约定，绝大多数的内容都是相对模糊的。但是客户感兴趣的往往是当时背景下最能创造价值的几个特性，软件的复杂性、不可见性、不一致性、可变性决定了其范围对于客户和开发者均为模糊的，但这带给了开发管理的特色，产品设计与开发者有更大的话语权，从而使得范围管理成为可能。给予一些项目管理领域的成功模型（如 STR 模型），我们就能有效地在需求间做出决策，实现一定程度上的软件范围控制。 项目管理实践 看板使用练习（提交看板执行结果贴图，建议使用 Git project） 使用截图工具（png格式输出），展现你团队的任务看板 每个人的任务是明确的。必须一周后可以看到具体结果 每个人的任务是 1-2 项 至少包含一个团队活动任务 UML绘图工具练习（提交贴图，必须使用 UMLet） 请在 参考书2 或 教材 中选择一个类图（给出参考书页码图号） UML和模式应用（原书第3版） P6 图1-3","link":"/SSAD/Software-System-Analysis-and-Design-Assignment-2/"},{"title":"Software System Analysis and Design Assignment 3","text":"系统分析 第三次作业 熊永琦 16340258 简答题 简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点（从项目特点、风险特征、人力资源利用角度思考） 答： 瀑布模型 概念：开发过程由 Idea、Analysis、Design、Development、Test、Final Product 顺序构成。项目开发进程从一个阶段“流动”到下一个阶段，如果发现了问题，则会回流到上一个阶段。 优缺点： 项目特点：（优点）明确地定义了软件开发基本流程与活动。（缺点）无法应对快速变化的需求。 风险特征：（缺点）后期发现问题时，修复问题的代价大到难以接受；后续工作严重依赖于前序工作的结果。 人力资源利用：（缺点）每个阶段人员技能、数量要求不同，且高度串行化，降低了人力资源的利用效率。 增量模型 概念：开发过程由多个增量（包含完整的开发流程）构成，分步、分块完成项目需求，从而应对用户对产品的急切需求。 优缺点： 项目特点：（优点）优化了人力资源使用效率（允许一定程度的并行化开发）、能够快速满足用户需求。 风险特征：（优点）可以通过增量快速满足用户需求的变化。（缺点）项目控制困难，可能导致不同增量间的冲突。 人力资源利用：（优点）允许一定程度的并发工作，人力资源利用率高。（缺点）对团队组织要求高，容易因为团队管理不力而造成开发进度混乱。 螺旋模型 概念：周期性地运用原型方法进行若干次迭代的开发模式。 优缺点： 项目特点：（优点）多迭代开发，能够快速满足用户需求。 风险特征：（优点）风险驱动的开发模式，每个迭代中都有完整的风险评估过程。 人力资源利用：（缺点）无法确定迭代次数、串行式开发，人力资源利用率低。要求项目调度灵活，难以适应大型项目开发。 简述统一过程三大特点，与面向对象的方法有什么关系？ 答： 三大特点 用例驱动（风险驱动） 从通过编码和测试中获取的要求来构成用例 以架构为中心 以软件架构为中心点，进行迭代和增量开发 迭代和增量开发 允许在不完整、不完美的知识背景下进行开发 与面向对象的方法的关系： 在面向对象的方法中，所有的事务都是对象间交互的结果，一切事务都被抽象为对象和对象的方法。在统一过程中，“用例”是所有设计和实现的基础，所有工作围绕用例展开。其作用类似面向对象中的“对象”。 简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？ 答： 四个划分的准则和里程碑： Inception：阶段任务：建立开发小组、验证项目可行性、确定软件生产方式（开发或是购买）、拟定初步开发计划和预算。结束里程碑：开发了系统的一个近似版本，确定了商业场景，确定了范围，并且大致估算了任务日程和开销。 Elaboration：阶段任务：解决已知风险、建立并验证系统架构、确定系统要求的主要内容。结束里程碑：构造了一个构建阶段的计划，该计划准确、可信，并预估了可能在构建阶段出现的重大风险。 Construction：阶段任务：基于 Elaboration 阶段的结果，构建系统的剩余部分。结束里程碑：软件已经准备部署。 Transition：阶段任务：将产品部署给客户，并持续跟踪改进产品。结束里程碑：产品发布并投入使用。 软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？ 答： 利用软件产品范围的弹性，合理规划范围（20% 业务决定 80%满意度），从而使得固定节奏生产和发布软件产品成为可能。由此带来的固定的迭代周期，利于量化团队或个人生产率，从而利于企业更好地评估个人/团队贡献、激励员工高效工作、确保企业高效运作。","link":"/SSAD/Software-System-Analysis-and-Design-Assignment-3/"},{"title":"Software System Analysis and Design Assignment 4","text":"系统分析 第四次作业 熊永琦 16340258 简答题 用例的概念 是一组相关的失败或成功场景的合集，用于描述一个参与者如何是用系统来达到目的。也是在功能和行为上的要求，指示了系统需要做的事情。 用例和场景的关系？什么是主场景或 happy path？ 用例包含一组场景（主场景或可选场景） 主场景对应主要的系统界面，通常是一个成功场景。是最常用的，直接地实现用户目标的故事。 用例有哪些形式？ Brief 简短的单段总结，通常是对于主场景的 Casual 正式的段落格式，由多段内容来囊括多个场景 Fully 对于所有的步骤和变化都有详尽的表述，并且有一些附属的帮助理解的板块。 对于复杂业务，为什么编制完整用例非常难？ 因为复杂业务场景众多，关联复杂。如果要在其上编写完整用例，需要在其中抽丝剥茧地提取出每个场景，这要求编写者对于整个项目的每个细节都有入微的了解，而这在业务复杂时极其困难。 什么是用例图？ 通过具有系统上下文的图片，展示系统的边界和系统的使用方式，并且作为一个总结了系统行为的工具来与用户沟通。 用例图的基本符号与元素？ 参与者，符号为小人 用例，符号为圆形文本框 系统边界，符号为方框 关联关系，符号为无标记的无方向虚线 包含关系，符号为带有“&lt;&gt;”标记的虚线箭头 扩展关系，符号为带有“&lt;&gt;”标记的虚线箭头 泛化关系，符号为一个实线箭头，箭头为一个三角形 用例图的画法与步骤 确定研究的系统 用 System 方框表示待研究的系统 正确命名该系统 识别 Actors 识别主要参与者和角色 用用例图小人符号表示 actor，放在系统左边 识别系统依赖的外部系统 是用用例图 NeighborSystem 框表示用例依赖的外部系统，并使用构造型识别其赖姓 识别用例 识别用户级别用例 以主要参与者为目标驱动 手机主要参与者的业务事件 识别子功能级别的用例 正确使用用例和子用例之间的关系并用符号表达 建立 Actor 与 Use Case 之间的关联 使用无方向连线连接二者 用例图给利益相关人与开发者的价值有哪些？ 明确系统的业务范围、服务对象（角色）、外部系统与设备 帮助识别技术风险，提前实施关键技术原型公关与学习 易于评估项目工作量，合理规划迭代周期，规划人力需要 建模练习题 选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求： 请使用用户的视角，描述用户目标或系统提供的服务 粒度达到子用例级别，并用 include 和 exclude 关联它们 请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例 尽可能识别外部系统和服务 记单词APP：墨墨背单词 记单词APP：百词斩 然后，回答下列问题： 为什么相似系统的用例图是相似的？ 用户使用相似系统的过程（用例图所表达的）也是相似的，同类的不同产品的主要区别一般只是他们的特色功能。 如果是定旅馆业务，请对比 Asg_RH 用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术 如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用 通过不同颜色标记后，我们可以清晰地在用例图中看到创新的部分所处的位置，从而了解其在系统中的作用。 请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表 选择的用例图：墨墨背单词 ID Name Imp Est(man-day) How to demo Notes 1 注册 30 5 选择注册方式，检验注册方式是否可以正常运作 需要注意用户账号间冲突的情形，以及对字段有效性的验证 2 登陆 30 4 注册后使用注册的账号进行登录 使用 Cookie 或 Token 维持登录状态 3 管理订单 50 30 选择支付方式并完成支付，删除订单 需要验证支付状态 4 查询 50 10 通过酒店的信息查询可预订的酒店 需要提示可用的关键字 根据任务4，参考 使用用例点估算软件成本，给出项目用例点的估算 用例 事务 计算 原因 UC权重 注册 3 3 两种注册方式和输入有效性验证 简单 登陆 2 2 两种登录方式 简单 管理订单 10 8 多种支付方式、管理订单功能 复杂 查询 6 6 筛选、推荐 平均","link":"/SSAD/Software-System-Analysis-and-Design-Assignment-4/"},{"title":"Software System Analysis and Design Assignment 5","text":"系统分析 第五次作业 熊永琦 16340258 使用 UMLet 建模： 根据订旅馆建模文档 Asg-RH.pdf 绘制用例图模型（到子用例） 给出 make reservation 用例的活动图 根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景 分别用多泳道图建模三个场景的业务过程 x科技公司发明了投递柜，它们自建了投递柜以及远程控制系统。注册的投递员在推广期免费使用投递柜。由于缺乏资源，仅能使用y移动平台向客户发送短信通知。 随着产品推广，x公司与各大快递z公司达成协议。x公司在快递柜上添加了二维码扫描装置，z公司的快递员不仅可在快递柜上登陆（由z公司提供认证服务），且可扫描快递单号，投递入柜后自动由z公司发短信给客户。客户取件后，自动发送给z公司投递完成。 x公司进一步优化服务，开发了微信小程序实现扫码取快递。如果用户关注了该公司公众号，直接通过过公众号推送给用户取件码等信息。不再发送短信。 根据上述流程，给出快递柜系统最终的用例图模型 用正常色彩表示第一个业务流程反映的用例 用绿色背景表述第二个业务场景添加或修改的用例，以及支持 Actor 用黄色背景表述第三个业务场景添加或修改的用例，以及支持 Actor","link":"/SSAD/Software-System-Analysis-and-Design-Assignment-5/"},{"title":"Software System Analysis and Design Assignment 6","text":"系统分析 第六次作业 熊永琦 16340258 使用 UMLet 建模 使用类图，分别对 Asg_RH 文档中 Make Reservation 用例以及 Payment 用例开展领域建模。然后，根据上述模型，给出建议的数据表以及主要字段，特别是主键和外键 注意事项： 对象必须是名词、特别是技术名词、报表、描述类的处理； 关联必须有多重性、部分有名称与导航方向 属性要注意计算字段 数据建模，为了简化描述仅需要给出表清单，例如： Hotel（ID/Key，Name，LoctionID/Fkey，Address…..） 答： 使用 UML State Model，对每个订单对象生命周期建模 建模对象： 参考 Asg_RH 文档， 对 Reservation/Order 对象建模。 建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在 定旅馆 的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。 答：","link":"/Machine-Learning/Software-System-Analysis-and-Design-Assignment-6/"},{"title":"WEB Assignment 1","text":"This article is a start of a set of articles which contains all the static web pages I have worked out in the Modern WEB Technology course of SYSU. They are the mileposts on the road of my WEB learning. And it did take me a long time to design and implement each of them. I think it will be a good ending for them to be displayed here, as a milepost of my life road. Assignment 1 - RecipeIf you are a student of SYSU and are accessing the education network, you may be able to view the detail of this homework by visiting This Page. This is the very first homework that Professor Wang left for us. And this is also the very first time that I pay attention to designing a website. I use the background music of Mercedes-Benz’s Official Website as the background music of it, with adding mask layout to optimize the background image’s performance. Lucklily, it seems not to be a bad work.And now, let’s experience it! Assignment 1 (It seems that hexo cannot normally display a customized page. I think I have to register another Github account to accommodate my assignments.)","link":"/WEB-Assignments/WEB-Assignment-1/"},{"title":"WEB Assignment 2","text":"Assignment 2 - Movie ReviewDifferent from Assignment 1, which gave us the freedom to design our own page, this homework require us to implement a page which is almost the same as the one shown in the picture. If you are a student of SYSU and are accessing the education network, you may be able to view the detail of this homework by visiting This Page. How to make the page nearly the same as the given one is a huge problem, and I met a lot of troubles implementing it, the biggest one of which is that, I found my chrome will not really display a 8-pt font, and it would be forced to be changed into a 10-pt one.Whatever, take a look at the final version of it. [Assignment 2](https://SiskonEmiliaPage.github.io/Assignment 2/html/skeleton.html).","link":"/WEB-Assignments/WEB-Assignment-2/"},{"title":"WEB Assignment 3","text":"Assignment 3 - Ring MenuAssignment 3 gave us a good chance to learn the usage of CSS3 features, especially transition and transform. We were required to work out a page which is the same as the one displayed in the video. If you are a student of SYSU and are accessing the education network, you may be able to view the detail of this homework by visiting This Page. It took me about two days to optimize its performace, through which period I learnt a lot about the transition property of CSS3.Whatever, take a look at the final version of it. [Assignment 3](https://SiskonEmiliaPage.github.io/Assignment 3/html/index.html).","link":"/WEB-Assignments/WEB-Assignment-3/"},{"title":"WEB Assignment 4","text":"Assignment 4 - CalculatorAssignment 4 was the start of our journey of JavaScript. We’re required to implement a simple calculator with HTML, CSS and JS. If you are a student of SYSU and are accessing the education network, you may be able to view the detail of this homework by visiting This Page. In order to implement the feature of high-accuracy calculating, this project depende on math.js. And to meet the requirement of users with different sizes of screen, I design two versions of this project. Thus take a look at the final version of it. [Assignment 4 - bigger one](https://SiskonEmiliaPage.github.io/Assignment 4/html/calculator.html), [Assignment 4 - smaller one](https://SiskonEmiliaPage.github.io/Assignment 4/html/calculatorMini.html).","link":"/WEB-Assignments/WEB-Assignment-4/"},{"title":"WEB Assignment 5","text":"Assignment 5 - Games距离上次更新博客已有些时日了，这些时候一直在忙期末考试的事情，不过总算是顺利结束了，博客也可以开始更新了～本着放松的心态，这篇博文就换做中文书写吧。那么这次的博文是关于我们的第五个WEB作业——两个小游戏：迷宫和打地鼠～如果你是中山大学的在读学生，并且接入了校园网，你应该可以通过这个网页了解一些关于这个作业的详细信息～从作业本身来说，还是相当好玩的～在好玩的同时也学到了JavaScript编写应用程式的基本方式呢。 话不多说，一起来看看吧～[迷宫](https://SiskonEmiliaPage.github.io/Assignment 5/maze/html/maze.html) [打地鼠](https://SiskonEmiliaPage.github.io/Assignment 5/mole/html/mole.html)","link":"/WEB-Assignments/WEB-Assignment-5/"},{"title":"WEB Assignment 6","text":"Assignment 6 - PuzzleWEB作业系列的最后一作，拼图游戏～（其他的作业需要客户端支持，不太适合放到Pages上）它在搭载Chrome浏览器的Windows10下有最好的游玩体验，请尽量使用&gt;=1080p的分辨率进行游戏（13寸RetinaMBP可能需要缩小网页），缩放可能会导致画面排版异常。因为游戏彩蛋有音效，希望您能打开扬声器进行游戏。当难度&gt;=20时完成拼图可以解锁小彩蛋～如果你是中山大学的在读学生，并且接入了校园网，你应该可以通过这个网页了解一些关于这个作业的详细信息～在忙于做C#的今天回过头来看，JS这种轻量级的语言真是让人太幸福了……话不多说～来看看吧！[Final Puzzle](https://SiskonEmiliaPage.github.io/Assignment 6/html/Puzzle.html)","link":"/WEB-Assignments/WEB-Assignment-6/"},{"title":"从零开始的随机森林（1）：信息论","text":"Attention: This blog is a reading note of Tree - Information Theory in Chinese, which is written in English. As missing or misunderstanding might be included, please reference the original text if needed. We believe that the original text containing some misunderstandings on information theory itself, and we correct it in our version. 注意：本系列主要关注涉及分类决策和回归树/森林的理论，以及回归树/森林的代码实现。 近年来，基于决策树的集成算法在机器学习和数据挖掘界被广泛应用，并受到了大多数人的好评和欢迎。随机森林（Random Forest）是这批算法中的佼佼者，其拥有很高的准确率，同时兼具很高的运行效率和对于异常数据与过拟合的鲁棒性。因而，我们撰写了这一系列的博客，希望能够系统地介绍随机森林的原理和实现的方法。 随机森林的本质是决策树的集成，我们需要先阐述决策树背后的原理。而在此之前，我们需要先了解他们共同依赖的理论基础：信息论。（注意：本篇仅涉及对于其理论的直观认识，如需要严格的数学论证，请参阅原论文） 何为信息如果我们希望传输一个由四个字符构成的字符串，例如 ACABBDAA，我们需要多少比特？一种常见的想法是通过一个定长的比特串来表达每个字符，也就是令 A = 00, B = 01, C = 10, D = 11，那么我们可以得到我们的答案：2 * 8 = 16 位比特。 那么我们可以使用更少的比特来表达相同的信息吗？答案是肯定的。首先，我们刚才的问题抽象为公式可以表达为： $$E(N)=\\sum_{k\\in A,B,C,D}n_k* p(x=k)$$ 其中，$n_k$ 是字符 $k$ 所占用的比特数量，$p(x=k)$ 是字符$k$ 在字符串 $N$ 中出现的频率。对于四个字符，这个值分别是 0.5, 0.25, 0.125, 0.125。 因为因为我们上面的例子中，ABCD并非是均匀分布的，所以我们可以考虑通过改变 $n_k$ 的大小来使用更少的比特传输同样的数据。一种常见的办法是使用 Huffman 编码来压缩信息所需的空间。在此例中即令 A = 0, B = 10, C = 110, D = 111，最终我们可以在平均每个字符 1.75 个比特的情况下，实现对于原信息的表达。 似乎巧合的是，我们用来表达字符的比特数量似乎刚好满足 $n_k=-log_2(p(x=k))$。实际上，这是由二进制为载体的信息传输的性质决定的。每个比特都可以将一个值集合划分为两个子集，直到所有子集均只有一个值为止。因而我们实际上寻求的是一个最优的划分方法——而这显然是不断在数量上进行平分。为了方便理解，我们可以将其抽象为一棵二叉树，左子树和右子树分别代表在一位上为 0 和 1，而叶节点则指示了各值的编码。在此语境下，$n_k=-log_2(p(x=k))$ 表示的就是叶节点所处的层数，也就是所需的二进制的位数。 综上，我们能够得到表达一段信息所需要的最少平均比特数： $$H(X)=-\\sum_ip_i*log_2p_i$$ 这在某种意义上可以代表信息的量。在信息论中，我们称之为信息熵（Information Entropy），或者简称为熵（Entropy），并用来衡量信息的多少（对于连续量，该值为 $H(X)=-\\int_xp(x)*log_2p(x)dx$）。 熵：更进一步为什么是「熵」？熵并不是 Andrew 教授生造的概念，而是一个热力学中表征物质状态的参量。在物理上，熵是体系混乱程度的度量。直观地来讲，一个系统越混乱，其包含的信息就越多。例如一块100%纯净的有序晶体，要描述它的构造，我们只需要晶胞的构造式和数量即可；而要描述一块路边的碎石，我们则需要描述其内复合的各种物质，以及他们之间的结合关系——这是由混乱带来的信息量增长，也就是信息熵的本质。 而之后我们将要讲到的决策树将这种混乱称为“杂质”，它期望的是将通过将充满杂质的碎石通过某种规则“纯化”为数个有序晶体，并将这个学习到的规则应用到更广泛的样本中来达到回归或分类的效果。 交叉熵（Cross Entropy）交叉熵（Cross Entropy） 用于描述两个在同一数据集上的概率分布的信息差。更直观地来说，交叉熵是对同一组对象的两个信息之间的“歧义”，讨论的对象是一个“目标”信息和一个“当前”信息，这个信息可以是规则（如决策树的分类规则），数据等等。其研究的是两个信息之间的差距。或者说使用当前的信息，需要多少 bit 才能描述目标信息。基于前面的叙述，令 $p$ 为目标信息分布，$q$ 为当前信息分布，那么交叉熵的公式是直观的： $$H(p, q)=-\\sum_{x\\in\\mathcal{X}}p(x)\\ log\\ q(x)$$ 从压缩的角度来说，它表示一个压缩模式 $q$ 对于真实模式 $p$ 的效果，或者说使用 $q$ 来表示 $p$ 内信息所需要的平均比特数量。 信息增益（Information Gain）继续跟随我们刚才的逻辑，我们已经知道，$H(Y,X)$ 是在引入了信息 $X$ 后，与 $Y$ 信息之间的差距，或者说歧义。也可以说是在引入 $X$ 后 $Y$ 中仍不确定的信息量。考虑 $H(Y)$ 为随机变量 Y 所携带的信息量，令它减去 $H(Y,X)$，得到的 $H(Y)-H(Y,X)$ 就是“通过引入 $X$ 所确定的信息量”。在信息论中，我们称之为信息增益（Information Gain）： $$IG = H(Y) - H(Y,X)$$ 注意：在某些文献中，Information Gain 被认为与 Kullback–Leibler divergence 同义，而实际上后者的定义式为 $D_{KL}(Y||X)=\\sum_{x\\in\\mathcal{X}}Y(x)log(\\frac{Y(x)}{X(x)})=H(Y,X)-H(Y)$ 一个直观的认识是，当 $X$ 和 $Y$ 具有某种联系的时候，通过确定 $X$ 的信息，我们就能一定程度上了解 $Y$ 的信息，从而降低了 $Y$ 的信息熵，减少的这部分就是引入 $X$ 所带来的信息增益。决策树算法的主要理论依据正是信息增益。","link":"/Machine-Learning/从零开始的随机森林（1）：信息论/"},{"title":"Get Started with Unity3D - 1","text":"本篇博客是Unity3D第一周课程作业，包含对Unity3D基本概念的详尽解释和井字棋开发指南。若有疏漏，欢迎大家在评论区指正，谢谢～！ 概念解答注：markdown文档地址 解释 游戏对象（GameObjects） 和 资源（Assets）的区别与联系 区别 游戏对象 游戏对象是游戏场景中的所有实体的统称。它不仅包含游戏中的实体，同时也包含摄像机、光源等。正是他们之间的互动构成了游戏。 资源 资源包含材质、音乐、脚本等等，他们通常附着于游戏对象而发挥作用，但同时，也包含可以直接实例化为游戏对象的对象的预制。 联系 资源可以附着在游戏对象上，也可以实例化为对象而发挥作用，但是独立的资源不能直接发挥作用。 下载几个游戏案例，分别总结资源、对象组织的结构（指资源的目录组织结构与游戏对象树的层次结构） 资源目录结构 资源目录一般下属多个文件夹以区分不同的资源类型，如预制、材质、场景、脚本、音乐等，在文件夹下放置对应的资源，如此方便制作者对不同资源的管理。 游戏对象树结构 如同资源目录一般，根据用途被划分为几个大的空对象，来区分不同的游戏对象。实际起作用的对象作为这些对象的子对象而存在。常见的花粉中包含：光源、背景、实体、边界、事件、文字、摄像机等。 编写一个代码，使用 debug 语句来验证 MonoBehaviour 基本行为或事件触发的条件 基本行为包括 Awake() Start() Update() FixedUpdate() LateUpdate() 常用事件包括 OnGUI() OnDisable() OnEnable() 1234567891011121314151617181920212223242526272829303132333435363738 using System.Collections; using System.Collections.Generic; using UnityEngine; public class BehaviourTest : MonoBehaviour { void Start () { Debug.Log (\"Test: Start!\"); } void Update () { Debug.Log (\"Test: Update!\"); } private void Awake() { Debug.Log (\"Test: Awake!\"); } private void FixedUpdate() { Debug.Log (\"Test: FixedUpdate!\"); } private void LateUpdate() { Debug.Log (\"Test: LateUpdate!\"); } private void OnGUI() { Debug.Log (\"Test: OnGUI!\"); } private void OnDisable() { Debug.Log (\"Test: OnDisable!\"); } private void OnEnable() { Debug.Log (\"Test: OnEnable!\"); }} 结论：结合代码测试结果和官方文档解释得出 Start: 在脚本被启用情况下的第一帧被调用，先于所有的Update Update: 在每一帧都被调用 Awake: 在脚本被实例化并加载时就调用，调用顺序在Start之前 FixedUpdate: 在每个时间片，而不是每一帧调用 LastUpdate: 在Update被调用后调用 OnGUI: 在GUI事件被触发时调用 OnDisable: 在脚本被禁用时调用，仅在状态切换时调用，保持时不调用 OnEnable: 在脚本被启用时调用，仅在状态切换时调用，保持时不调用 查找脚本手册，了解 GameObject，Transform，Component 对象 分别翻译官方对三个对象的描述（Description） GameObject Scripting: 在Unity场景中的所有实体的基类。 Manual: 游戏对象在Unity中是那些表现角色、道具和场景基础对象。他们本身并不十分完整，但她们作为组件（Components）的容器而存在，这使得她们得以实现她们真正的功能。 Transform Scripting: 一个对象的位置、旋转（角度）和缩放。每个对象都有一个Transform。它被用于存储、和操作对象的位置、旋转角和缩放。 每个Transform都有一个父元素，这允许分层地应用这些属性。这也就是在层级窗口所呈现的层级。 Manual: Transform组件决定了场景中每个对象的位置、旋转（角度）和缩放。每个游戏对象都有一个Transform。 Component Scripting: 所有附着于游戏对象类的东西的基类。 描述下图中 table 对象（实体）的属性、table 的 Transform 的属性、 table 的部件 table 12345// class GameObjectbool activeSelf = true;int layer; // 为默认值（Default)string tag = \"\"; // Untaggedbool isStatic = false; table’s Transform 1234// class TransformVector3 Position = new Vector3 (0,0F, 0.0F, 0.0F);Quaternion rotation = \bnew Quaternion (0.0F, 0.0F, 0.0F, 1);Vector3 localScale = new Vector3 (1, 1, 1); table’s components 1234567891011121314151617// 基类均为 Components// class MeshFilterMesh mesh = cube;// class BoxColliderbool isTrigger = false;PhysicMaterial material = null;Vector3 Center = new Vector3 (0.0F, 0.0F, 0.0F);Vector3 Size = new Vector3 (1, 1, 1);// class MeshRendererRendering.ShadowCastingMode shadowCastingMode = On;bool receiveShadows = true;MotionVectorGenerationMode motionVectorGenerationMode = Object;Rendering.LightProbeUsage lightProbeUsage = BlendProbes;Rendering.ReflectionProbeUsage reflectionProbeUsage = BlendProbes;GameObject lightProbeProxyVolumeOverride = null; 用 UML 图描述 三者的关系 整理相关学习资料，编写简单代码验证以下技术的实现： 查找对象 12345static GameObject Find (string name) // 通过对象名来查找单个对象static GameObject FindWithTag (string tag) // 通过对象的tag来查找单个对象static GameObject[] FindGameObjectsWithTag (string tag) // 通过对象的tag来寻找所有对象static Object FindObjectOfType(Type type) // 通过对象的类型来寻找对象static Object[] FindObjectsOfType(Type type) // 通过对象的类型来寻找所有的对象 添加子对象 123GameObject parentObj = GameObject.Find([ParentName]);GameObject childObj = GameObject.Find([ChildName]);childObj.transform.parent = parentObj.transform; 遍历对象树 如前文所述，FindObjectsOfType函数可以通过对象类型寻找对象，因而将其type令为GameObject即可得到所有的对象的一个列表，遍历列表即可遍历整个对象树 123for (var obj in GameObject.FindObjectsOfType(typeof(GameObject))) {// your code here} 清除所有子对象 123 for (int i = 0; i &lt; transform.childCount; i++) { Destroy (transform.GetChil(i).gameObject);} 此处值得说明的是，在Destory之后，childCount并不会立即减少， 资源预设（Prefabs）与 对象克隆 (clone) 预设（Prefabs）有什么好处？ 提高设计的复用性，降低设计成本 提高资源的复用性，降低游戏空间复杂度 “类化”游戏对象，提高逻辑复用性 变相提供相对统一的设计风格 预设与对象克隆 (clone or copy or Instantiate of Unity Object) 关系？ 二者都可以创造一类相同／相似的对象 由同个预设创造的对象在预设更改时也会同步更改，但是克隆出来的对象是互相独立的 制作 table 预制，写一段代码将 table 预制资源实例化成游戏对象 12GameObject prefab = Resources.Load(\"Prefabs/table\") as GameObject;GameObject instance = Instantiate(prefab); 尝试解释组合模式（Composite Pattern / 一种设计模式 是一种树状层级式的组织结构，它允许使用者递归地处理对象间的关系。在这种模式下，复杂对象和简单对象被一视同仁——复杂对象的内部细节对外部是隐藏的，从而使得客户程序与复杂元素的内部结构解耦。一个形象的例子是计算机的文件系统——文件夹和单个文件从外部看都是一致的。 使用 BroadcastMessage() 方法向子对象发送消息 123456// 父类对象通过BroadcastMessage方法发送字符串消息，子类对象的同名方法将被调用this.BroadcastMessage(\"Hey\"); // 父类对象发出消息/*---*/void Hey(){// This part will be executed} // 子类对象同名方法将被调用 开发实验：井字棋注：仓库地址 有空再写～只看官方文档写游戏真是……","link":"/Unity3D/Get-Started-with-Unity3D-1/"},{"title":"Get Started with Unity3D - 2","text":"简答 &amp; 程序验证简答题仓库地址 注意：本简答题作业所有代码／实现／实验均包含在SolarSystem项目中，由不同的场景呈现，通过选择不同的场景，您可以快速查看各题目实现效果 游戏对象运动的本质是什么？ 是游戏对象的位置属性在每个时刻的变化。 12345// 示例代码：沿y轴向上匀速运动// 打开项目文件夹下Object Motion以查看完整代码void Update () { this.transform.position += Vector3.up * Time.deltaTime;} 请用三种方法以上方法，实现物体的抛物线运动。（在Parabola文件夹下三个场景分别对应三种方法的实现） 直接对 Transform.position 赋值 简单来说，每一帧通过获取间隔时间Time.deltaTime，来根据抛物线函数计算下一帧物体的位置，将其赋值给Transform.position，由此达成物体的抛物线运动。 1234567891011121314151617181920212223242526272829public class parabola1 : MonoBehaviour { static private float g = 2.38F; private float speedx; private float speedy; private float x; private float y; // Use this for initialization void Start () { speedx = 1.5F; speedy = 4; } // Update is called once per frame void Update () { float newSpeedy = speedy - g * Time.deltaTime; x = this.transform.position.x + speedx * Time.deltaTime; y = (speedy + newSpeedy) / 2 * Time.deltaTime + this.transform.position.y; if (y &lt;= 0) { y = -y; newSpeedy = -newSpeedy; } speedy = newSpeedy; this.transform.position = new Vector3( x, y, 0.0F ); }} 通过 Rigidbody 借由物理引擎实现 Rigidbody（刚体）组件可以让对象受Unity3D的物理引擎控制。因而，在开启重力影响后，赋予物体初速度，就可以看到抛物线运动的效果。 123456789101112131415161718[RequireComponent(typeof(Rigidbody))]public class Parabola2 : MonoBehaviour { private Rigidbody rigidbody; private Vector3 initSpeed; // Use this for initialization void Start () { rigidbody = this.GetComponent&lt;Rigidbody&gt; (); initSpeed = new Vector3 (3, 10, 0); rigidbody.velocity = initSpeed; } // Update is called once per frame void Update () { }} 通过 CharacterController 通过函数实现 CharacterController（角色控制器）是用于第一人称／第三人称角色的碰撞模型，免去了繁琐的刚体设置，并提供了Simple Move和Move两种方法，因为Simple Move会屏蔽y方向速度，因此此处使用Move并结合函数计算速度方向来实现抛物线运动。 123456789101112131415161718[RequireComponent(typeof(CharacterController))]public class Parabola3 : MonoBehaviour { private CharacterController charactercontroller; private Vector3 speed; // Use this for initialization void Start () { charactercontroller = this.GetComponent&lt;CharacterController&gt; (); speed = new Vector3 (2, 5, 0); } // Update is called once per frame void Update () { speed -= 3.0F * Time.deltaTime * Vector3.up; charactercontroller.Move (speed * Time.deltaTime); }} 写一个程序，实现一个完整的太阳系， 其他星球围绕太阳的转速必须不一样，且不在一个法平面上。 既然要做太阳系，为了较为真实，自然要用到太阳系的数据～ | 星球名 | 半径(公里) | 轨道半径(千万公里) | 自转周期(天) | 公转周期(天) || - | - | - | - | - | - || 太阳 Sun |696000|0|26.9|0|| 水星 Mercury | 2439 | 57.9 | 58.65 | 87.70 || 金星 Venus | 6052 | 108.2 | 243.01 | 224.70 || 地球 Earth | 6378 | 149.6 | 0.9973 | 365.26 || 火星 Mars | 3398 | 227.9 | 1.0260 | 686.98 || 木星 Jupiter | 71398 | 778.3 | 0.410 | 4332.71 || 土星 Saturn | 60330 | 1427.0 | 0.426 | 10759.5 || 天王星 Uranus | 25400 | 2882.3 | 0.646 | 30685 || 海王星 Neptune | 24600 | 4523.9 | 0.658 | 60190 || 冥王星 Pluto | 1500 | 5917.1 | 6.39 | 90800 | 不过，这些数据过于庞大，经过一些奇妙的处理（归一化）之后使用会更加好看。不过不管表面上的东西怎么变，核心代码始终是不变的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System.Collections;using System.Collections.Generic;using UnityEngine;public class SolarSystem : MonoBehaviour { public Transform Sun; public Transform Mercury; public Transform Venus; public Transform Earth; public Transform Moon; public Transform Mars; public Transform Jupiter; public Transform Saturn; public Transform Uranus; public Transform Neptune; public Transform Pluto; private float speed = 5; // Use this for initialization void Start () { } // Update is called once per frame void Update () { Sun.Rotate (speed * Vector3.up * 360 * Time.deltaTime / 30); Mercury.Rotate (speed * Vector3.up * 360 * Time.deltaTime / 30); Venus.Rotate (speed * Vector3.up * 360 * Time.deltaTime / 80); Earth.Rotate (speed * Vector3.up * 360 * Time.deltaTime / 20); Moon.Rotate (speed * Vector3.up * 360 * Time.deltaTime / 30); Mars.Rotate (speed * Vector3.up * 360 * Time.deltaTime / 20); Jupiter.Rotate (speed * Vector3.up * 360 * Time.deltaTime / 10); Saturn.Rotate (speed * Vector3.up * 360 * Time.deltaTime / 10); Uranus.Rotate (speed * Vector3.up * 360 * Time.deltaTime / 10); Neptune.Rotate (speed * Vector3.up * 360 * Time.deltaTime / 10); Pluto.Rotate (speed * Vector3.up * 360 * Time.deltaTime / 15); // 这部分指定了自转速度 Mercury.RotateAround (Sun.transform.position, Vector3.up + 0.1F * Vector3.left, speed * 360 * Time.deltaTime / 87); Venus.RotateAround (Sun.transform.position, Vector3.up - 0.05F * Vector3.left, speed * 360 * Time.deltaTime / 224); Earth.RotateAround (Sun.transform.position, Vector3.up + 0.13F * Vector3.left, speed * 360 * Time.deltaTime / 365); Moon.RotateAround (Earth.transform.position, Vector3.up + 0.2F * Vector3.left, speed * 360 * Time.deltaTime / 30); Mars.RotateAround (Sun.transform.position, Vector3.up - 0.18F * Vector3.left, speed * 360 * Time.deltaTime / 687); Jupiter.RotateAround (Sun.transform.position, Vector3.up + 0.09F * Vector3.left, speed * 360 * Time.deltaTime / 1000); Saturn.RotateAround (Sun.transform.position, Vector3.up - 0.21F * Vector3.left, speed * 360 * Time.deltaTime / 1300); Uranus.RotateAround (Sun.transform.position, Vector3.up + 0.1F * Vector3.left, speed * 360 * Time.deltaTime / 1500); Neptune.RotateAround (Sun.transform.position, Vector3.up + 0.2F * Vector3.left, speed * 360 * Time.deltaTime / 1800); Pluto.RotateAround (Sun.transform.position, Vector3.up + 0.15F * Vector3.left, speed * 360 * Time.deltaTime / 2000); // 这部分指定了公转轨道，因为第二个参数是法向量，因此改变该参数即可实现轨道不在同一平面内 }} 值得一提的是，为了星球的运动轨迹更加容易分辨，我们推荐您使用Trail Renderer来绘制轨迹 效果预览： 预览图1 - 星系全览 预览图2 - 光效展示 预览图3 - 贴图展示 预览图4 - 运动轨迹 实验：牧师与恶魔仓库地址 参考实现 预览图 列出游戏中提及的事物（Objects） 船（Boat） 码头（Coast） 牧师（Priest） 恶魔（Devil） 用表格列出玩家动作表（规则表），注意，动作越少越好 动作 结果 点击魔鬼 若船在同一侧，且有空位，则上船。若在船上，则下船 点击牧师 若船在同一侧，且有空位，则上船。若在船上，则下船 点击船 若船上有至少一个牧师或魔鬼，则船移动到另一侧 点击Restart按钮 重新开始游戏","link":"/Unity3D/Get-Started-with-Unity3D-2/"},{"title":"Get Started with Unity3D - 3","text":"操作与总结 参考 Fantasy Skybox FREE 构建自己的游戏场景 在Unity3D中，Skybox可以方便我们通过贴图快速创建游戏场景，而对于小白用户来说，Assets Store中的Skybox资源已然足够丰富，随意找到一个免费资源，已然足够精美。在本项目中，为了实现更好的效果，我们通过球形组件来模拟Skybox，并结合Standard Assets中的Water预设建立场景。 写一个简单的总结，总结游戏对象的使用 作为游戏中的实体，游戏对象在游戏中的地位重要性不言而喻。因而，游戏对象的组织也是相当重要的课题。通过分离功能、分层管理，我们就能更精准、更有条理的对对象们进行操作。譬如在这两次作业中，MVC和预制的结合很好地帮助我们对对象进行管理，给予了我们项目更好的可维护性和可拓展性。如此产出的代码质量和第一次作业时的产物是不可同日而语的。 编程实践 - 动作分离版牧师与魔鬼项目仓库地址（含视频） 为什么要动作分离？在我们原本的架构中，对象的动作由其对应的Controller负责，这样虽然通过对象类型的不同区分了各个动作，然而却忽略了一个关键事实：在游戏中，对象的运动其实都是相似的，这种相似使得其可以单独作为一类存在。再者，我们也需要一个单独的Manager来对Action进行统一的管理，以此进一步降低维护成本。 如何实现？ 动作基类 123456789101112131415161718192021public class SSAction : ScriptableObject{ public bool enable = true; public bool destoried = false; public GameObject gameobject { get; set; } public Transform transform { get; set; } public ISSActionCallback callback { get; set; } protected SSAction() {} public virtual void Start () { throw new System.NotImplementedException (); } public virtual void Update () { throw new System.NotImplementedException (); }} SSAction为所有动作的基类，包含对对象进行操作的必须属性。同时，enable和destoried两个bool值分别决定其是否在Manager的Update中被更新，以及是否被Manager清除。callback为动作完成时的回调，在实现组合动作时通知上个action的完成，并让manager调用下一个action。 两种动作 在本项目中，我们有两种动作亟待实现：船的移动动作和人物的上／下船动作。也就是实际上是一个直线平移，一个是跳跃动作（在本项目中，我们使用抛物线而不是折线实现）。那么首先是直线移动： 12345678910111213141516171819202122public class CCMoveToAction : SSAction { public Vector3 target; public float speed; public static CCMoveToAction GetSSAction (Vector3 target, float speed, GameObject gameobject) { CCMoveToAction action = ScriptableObject.CreateInstance&lt;CCMoveToAction&gt; (); action.target = target; action.speed = speed; action.gameobject = gameobject; action.transform = gameobject.transform; return action; } public override void Start() { } public override void Update() { this.transform.position = Vector3.MoveTowards (this.transform.position, target, speed * Time.deltaTime); if (this.transform.position == target) { this.destoried = true; } }} 需要特别注意的是Update在判断到达指定位置后需要将destoried设为true，通知manager释放掉这个action。然后我们看看抛物线运动： 1234567891011121314151617181920212223242526272829303132public class CCJumpToAction : SSAction { public Vector3 target; public float speedx; public float speedy; public static readonly float gravity = 100; public static CCJumpToAction GetSSAction (Vector3 target, float speed, GameObject gameobject) { CCJumpToAction action = ScriptableObject.CreateInstance&lt;CCJumpToAction&gt; (); action.gameobject = gameobject; action.transform = gameobject.transform; action.target = target; action.speedx = speed * ((target.x &lt; action.transform.position.x) ? -1 : 1); float deltaTime = (target.x - action.transform.position.x) / action.speedx; action.speedx *= deltaTime * 2; deltaTime = 0.5F; action.speedy = Mathf.Abs((target.y - action.transform.position.y) / deltaTime + 0.5F * gravity * deltaTime); return action; } public override void Start () { } public override void Update () { var newSpeedy = speedy - gravity * Time.deltaTime; this.transform.position += (Vector3.right * speedx * Time.deltaTime + Vector3.up * 0.5F * (newSpeedy + speedy) * Time.deltaTime); speedy = newSpeedy; if (this.transform.position.x == target.x || this.transform.position.y &lt;= target.y) { this.transform.position = target; this.destoried = true; } }} 和直线运动类似，不过我们需要在创建的时候计算初始速度。并且由于我们使用近似的轨迹算法，所以在最后判断到达的时候需要用不等号连接，确保不会越界。 动作管理 顾名思义，动作管理类是为了管理SSAction派生出来的众多动作而设置的，它通过维护三个列表来实现对全体动作的管理，我们另外提供了一个子类，来对动作进行进一步的分类，使之和具体对象产生联系。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class SSActionManager : MonoBehaviour, ISSActionCallback { private Dictionary &lt;int, SSAction&gt; actions = new Dictionary &lt;int, SSAction&gt;(); private List &lt;SSAction&gt; waitngAdd = new List&lt;SSAction&gt; (); private List &lt;int&gt; waitingDelete = new List&lt;int&gt; (); protected void Update() { foreach (SSAction ac in waitngAdd) actions [ac.GetInstanceID ()] = ac; waitngAdd.Clear (); foreach (KeyValuePair &lt;int, SSAction&gt; kv in actions) { SSAction ac = kv.Value; if (ac.destoried) waitingDelete.Add (ac.GetInstanceID ()); else if (ac.enable) ac.Update (); } foreach (int key in waitingDelete) { SSAction ac = actions [key]; actions.Remove (key); DestroyObject (ac); } waitingDelete.Clear (); } public void RunAction (SSAction action, ISSActionCallback manager) { action.callback = manager; waitngAdd.Add (action); action.Start (); } public void SSActionEvent (SSAction source, SSActionEventType type, int intPar, string strPar, Object objPar) {} protected void Start() { }}public class EmiliaScenceActionManager : SSActionManager { private readonly static float defaultSpeed = 10; public void MoveBoat (BoatController boat) { CCMoveToAction action = CCMoveToAction.GetSSAction (boat.getDestination(), defaultSpeed, boat.boat); RunAction (action, this); } public void MoveCharacter (ICharacterController character, Vector3 destination) { CCJumpToAction action = CCJumpToAction.GetSSAction (destination, defaultSpeed, character.character); RunAction (action, this); } public void Update() { base.Update (); }} 如此之后，我们在FirstScenceController中实例化一个EmiliaScenceActionManager即可实现对全体对象的动作管理。","link":"/Unity3D/Get-Started-with-Unity3D-3/"},{"title":"Get Started with Unity3D - 7","text":"坦克大战 - 人工智障版参考博客 B站视频 游戏预览： 这次实现的是一个带有人工智障的坦克大战！一起来看看具体的做法吧(｡ì _ í｡) Tank！——官方的资源包Tank！是官方教程包中的 坦克大战游戏制作教程，除了教导我们如何制作一个坦克大战以外，包内也包含了精美而充足的游戏资源供我们使用！ 导入这个包以后，我们能看到许多现成的资源：Model、Prefabs……把地形实例化后，往上添加自己喜欢的 Model 就能简单地做成一个地图啦。 从 NavMash 开始既然要做 AI，自动寻路就是一个问题了。好在 Unity 已经帮我们做了很多事情，我们只需要简单的设置即可使用～首先，设置地形为 Walkable，地形上的部件为 Not Walkable，然后就可以通过烘培生成一个可以被 Nav Agent 识别的地形啦。为我们的 tank 装上 Nav Agent 组件，就可以让它享受到 Unity 的自动寻路功能了。 AI 的逻辑设定AI 的目的是淘汰玩家，我们设置的逻辑是 AI 会不断尝试接近 player，并且在足够接近的情况下开始发射炮弹： Enemy.cs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class Enemy : Tank { public delegate void recycle(GameObject Tank); public static event recycle recycleEvent; private Vector3 target; private bool gameover; // Use this for initialization void Start () { setHp(100f); StartCoroutine(shoot()); } // Update is called once per frame void Update () { gameover = (GameDirector.GetInstance().currentSceneController as FirstController).isGameOver(); if (!gameover) { target = (GameDirector.GetInstance().currentSceneController as FirstController).player.transform.position; if (getHp() &lt;= 0 &amp;&amp; recycleEvent != null) { recycleEvent(this.gameObject); } else { var agent = GetComponent&lt;NavMeshAgent&gt;(); agent.SetDestination(target); } } else { var agent = GetComponent&lt;NavMeshAgent&gt;(); agent.velocity = Vector3.zero; agent.ResetPath(); } } IEnumerator shoot() { while (!gameover) { if (Vector3.Distance(transform.position, target) &lt; 20) { var factory = Factory.GetInstance(); GameObject bullet = factory.GetBullet(TankType.Enemy); bullet.transform.position = new Vector3(transform.position.x, 1.5f, transform.position.z) + transform.forward * 1.5f; bullet.transform.forward = transform.forward; Rigidbody rb = bullet.GetComponent&lt;Rigidbody&gt;(); rb.AddForce(bullet.transform.forward * 20, ForceMode.Impulse); } yield return new WaitForSeconds(1); } }} 不过这里有一个问题亟待解决：通过协程实现的定时发射炮弹似乎会同时发射两发……由于长时间无法解决，我们就顺水推舟的把敌方坦克设定为“双管坦克”了 =v= 代码细节剩下的东西基本都是之前学过的了，通过单例的工厂类（Factory.cs）生成敌方坦克，通过场记类（FirstController.cs）实现场景对象的交互，通过委托实现事件的触发……详情就看代码吧～ Bullet.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243using System.Collections;using System.Collections.Generic;using UnityEngine;public class Bullet : MonoBehaviour { private TankType type; void OnCollisionEnter(Collision other) { if (other.gameObject.name.Contains(\"Shell\")) return; Factory factory = Factory.GetInstance(); if (other.gameObject.tag == \"Player\" &amp;&amp; this.type == TankType.Enemy || other.gameObject.tag == \"tankPlayer\" &amp;&amp; this.type == TankType.player) { float hurt = 100f; float current = other.gameObject.GetComponent&lt;Tank&gt;().getHp(); other.gameObject.GetComponent&lt;Tank&gt;().setHp(current - hurt); var anime = factory.GetHitAnimation(); anime.transform.position = transform.position; anime.GetComponent&lt;ParticleSystem&gt;().Play(); } else { var anime = factory.GetNotHitAnimation(); anime.transform.position = transform.position; anime.GetComponent&lt;ParticleSystem&gt;().Play(); } if (this.gameObject.activeSelf) { factory.recycleBullet(this.gameObject);//回收子弹 } } public void setTankType(TankType type) { this.type = type; }} Factory.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138using System.Collections;using System.Collections.Generic;using UnityEngine;public enum TankType : int { player, Enemy }public class Factory : MonoBehaviour { public GameObject player; public GameObject enemy; public GameObject bullet; public GameObject shellExlosion_nothit; public GameObject shellExlosion_hit; private Dictionary&lt;int, GameObject&gt; busyTanks; private Dictionary&lt;int, GameObject&gt; idelTanks; private Dictionary&lt;int, GameObject&gt; busyBullets; private Dictionary&lt;int, GameObject&gt; idelBullets; private List&lt;GameObject&gt; shellExlosions_nothit; private List&lt;GameObject&gt; shellExlosions_hit; private static Factory _instance; public static Factory GetInstance() { if (_instance == null) { _instance = new Factory(); } return _instance; } Factory() { _instance = this; busyTanks = new Dictionary&lt;int, GameObject&gt;(); idelTanks = new Dictionary&lt;int, GameObject&gt;(); busyBullets = new Dictionary&lt;int, GameObject&gt;(); idelBullets = new Dictionary&lt;int, GameObject&gt;(); shellExlosions_hit = new List&lt;GameObject&gt;(); shellExlosions_nothit = new List&lt;GameObject&gt;(); } private void Start() { Enemy.recycleEvent += recycleTank; } public GameObject GetEnemy() { if (idelTanks.Count == 0) { var newTank = Instantiate&lt;GameObject&gt;(enemy); busyTanks.Add(newTank.GetInstanceID(), newTank); newTank.transform.position = new Vector3(Random.Range(-100, 100), 0, Random.Range(-100, 100)); return newTank; } foreach (var pair in idelTanks) { pair.Value.SetActive(true); idelTanks.Remove(pair.Key); busyTanks.Add(pair.Key, pair.Value); pair.Value.transform.position = new Vector3(Random.Range(-100, 100), 0, Random.Range(-100, 100)); return pair.Value; } return null; } public GameObject GetBullet(TankType type) { if (idelBullets.Count == 0) { var newBullet = Instantiate&lt;GameObject&gt;(bullet); newBullet.GetComponent&lt;Bullet&gt;().setTankType(type); busyBullets.Add(newBullet.GetInstanceID(), newBullet); return newBullet; } foreach (var pair in idelBullets) { pair.Value.SetActive(true); idelBullets.Remove(pair.Key); busyBullets.Add(pair.Key, pair.Value); pair.Value.GetComponent&lt;Bullet&gt;().setTankType(type); return pair.Value; } return null; } public GameObject GetHitAnimation() { foreach (var anime in shellExlosions_hit) { if (!anime.GetComponent&lt;ParticleSystem&gt;().isPlaying) { return anime; } } var newAnime = Instantiate&lt;GameObject&gt;(shellExlosion_hit); shellExlosions_hit.Add(newAnime); return newAnime; } public GameObject GetNotHitAnimation() { foreach (var anime in shellExlosions_nothit) { if (!anime.GetComponent&lt;ParticleSystem&gt;().isPlaying) { return anime; } } var newAnime = Instantiate&lt;GameObject&gt;(shellExlosion_nothit); shellExlosions_nothit.Add(newAnime); return newAnime; } public void recycleTank(GameObject tank) { busyTanks.Remove(tank.GetInstanceID()); idelTanks.Add(tank.GetInstanceID(), tank); tank.GetComponent&lt;Rigidbody&gt;().velocity = Vector3.zero; tank.SetActive(false); } public void recycleBullet(GameObject bullet) { busyBullets.Remove(bullet.GetInstanceID()); idelBullets.Add(bullet.GetInstanceID(), bullet); bullet.GetComponent&lt;Rigidbody&gt;().velocity = Vector3.zero; bullet.SetActive(false); }} FirstController.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778using System.Collections;using System.Collections.Generic;using UnityEngine;public class FirstController : SceneController, UserActions{ public void LoadResources() { } static FirstController _instance; public GameObject player; // 玩家坦克 private readonly static int initialTanks = 6; private Factory factory; private bool gameover; public static FirstController GetInstance() { if (_instance == null) { _instance = new FirstController(); } return _instance; } public void moveForward() { player.GetComponent&lt;Rigidbody&gt;().velocity = player.transform.forward * 10; } public void moveBackWard() { player.GetComponent&lt;Rigidbody&gt;().velocity = player.transform.forward * -10; } public void turn(float offsetX) { float x = player.transform.localEulerAngles.y + offsetX * 5; float y = player.transform.localEulerAngles.x; player.transform.localEulerAngles = new Vector3(y, x, 0); } public void shoot() { GameObject bullet = factory.GetBullet(TankType.player); bullet.transform.position = new Vector3(player.transform.position.x, 1.5f, player.transform.position.z) + player.transform.forward * 1.5f; bullet.transform.forward = player.transform.forward; Rigidbody rb = bullet.GetComponent&lt;Rigidbody&gt;(); rb.AddForce(bullet.transform.forward * 20, ForceMode.Impulse); } public bool isGameOver() { return gameover; } private FirstController() { factory = Factory.GetInstance(); player = factory.player; Player.destroyEvent += SetGameOver; for (int i = 0; i &lt; initialTanks; ++i) { factory.GetEnemy(); } } public void SetGameOver() { gameover = true; }} GameDirector.cs 1234567891011121314151617181920using System.Collections;using System.Collections.Generic;using UnityEngine;public class GameDirector : Object { private static GameDirector _instance; public static GameDirector GetInstance() { if (_instance == null) _instance = new GameDirector(); return _instance; } private GameDirector() { currentSceneController = FirstController.GetInstance(); } public SceneController currentSceneController;} IUserControl.cs 12345678910111213141516171819202122232425262728293031323334353637using System.Collections;using System.Collections.Generic;using UnityEngine;public class IUserControl : MonoBehaviour { UserActions actions; // Use this for initialization void Start () { actions = GameDirector.GetInstance().currentSceneController as UserActions; } // Update is called once per frame void Update () { if (!actions.isGameOver()) { if (Input.GetKey(KeyCode.W)) { actions.moveForward(); } if (Input.GetKey(KeyCode.S)) { actions.moveBackWard(); } if (Input.GetKeyDown(KeyCode.Space)) { actions.shoot(); } float offsetX = Input.GetAxis(\"Horizontal1\"); actions.turn(offsetX); } }} myCameraController.cs 1234567891011121314151617181920using System.Collections;using System.Collections.Generic;using UnityEngine;public class myCameraController : MonoBehaviour { Transform Character; public float smoothTime = 0.02f; private Vector3 AVelocity = Vector3.zero; // Use this for initialization void Start() { Character = (GameDirector.GetInstance().currentSceneController as FirstController).player.transform; } // Update is called once per frame void Update() { transform.position = Vector3.SmoothDamp(transform.position, Character.position + Vector3.up * 20, ref AVelocity, smoothTime); }} player.cs 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : Tank { public delegate void destroy(); public static event destroy destroyEvent; void Start() { setHp(500f);//设置初始生命值为500 } void Update() { if (getHp() &lt;= 0) { this.gameObject.SetActive(false); if (destroyEvent != null) { destroyEvent(); } } }} SceneControlelr.cs 12345678using System.Collections;using System.Collections.Generic;using UnityEngine;public interface SceneController{ void LoadResources();} Tank.cs 1234567891011121314151617181920using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class Tank : MonoBehaviour{ private float hp; public float getHp() { return hp; } public void setHp(float hp) { this.hp = hp; }} UserActions.cs 123456789101112using System.Collections;using System.Collections.Generic;using UnityEngine;public interface UserActions{ void moveForward(); void moveBackWard(); void turn(float offsetX); void shoot(); bool isGameOver();}","link":"/Unity3D/Get-Started-with-Unity3D-7/"},{"title":"Get Started with Unity3D - 8","text":"网络对战-天际赛车经历了一个学期的各种学习，我们今天终于迎来了 Unity 制作网游的重要一步——网络模块。网络模块的存在使得游戏可以随时变身客户端／服务端，并且让多人共同进行游戏——没有什么比分享更能让人快乐的了！那么这次我们制作的是《天际赛车》，玩家将驾驶飞行器和同伴一起穿过圆环，争取分数！单人预览： 强大的官方标准资源包当然……这个飞机和控制脚本基本不是我的作品。它们是来自官方的 Standard Assets 包中的喷气式飞机。 导入资源包后，直接打开 Standard Scenes 中的场景，我们就能够看到一个造好的飞机场，和停在上面的一架飞机。运行游戏，我们可以看到，飞机的控制等等官方已经为我们设计好了，我们需要操心的就只有网络模块在之上的应用。 网路模块预备知识如我们前文所说的，客户端之间应该是不能够直接相连的，否则我们难以解决数据的统一问题。那么网络交互的架构到底是如何的呢？ 主机和服务器 如图所示，在众多的客户端中，有一个客户端是脱颖而出的：主机（Host），它在包含一个客户端的同时，还包含了一个服务器（Server），所有的客户端彼此之间并不交互，他们都统一和客户端进行数据交换，以确保数据的统一，并最小化传输代价。当然，Host 的存在并不是必须的。严格来说，大型的网络游戏一般是采用 Server/Client 分离的模式，也就是单独一个程序作为 Server，其余的都是 Client，如此来更好地利用服务器资源和降低模块耦合程度。 实例化与孵化在一个单机中，游戏对象创建称为实例化（Instantiate） 在网络游戏中，网络游戏对象，客户端必须从服务器接受这些对象及其属性，称为孵化（Spawn），并由服务器的孵化系统（Spawning System）管理分布式对象生命周期和状态同步。 网络游戏对象前面我们说到，每个客户端中的游戏对象实际上都是由服务器的孵化系统管理和同步的。但是在我们的实际体验中，每台客户端的显示效果显然是不同的，我们要如何做到这一点呢？这就要涉及到 Unity 的网络游戏对象系统： 网络游戏对象（Networked GameObjects） ：在服务器上注册，由孵化系统（Spawning System）管理的对象，它必须包含 NetworkIdentity 组件，并用 NetworkBehaviour 脚本编程。 玩家游戏对象（player GameObjects）是特殊的网络游戏对象，指一个 client 加入网络游戏，服务器创建并孵化到客户端，由玩家控制的游戏对象。客户端代码可以控制它们的状态，并自动有服务器同步到其他玩家的客户端。例如：联网赛车游戏，每个玩家都有属于自己的赛车。 实战！说了那么多基本知识，没有实战的就毫无意义。我们如何把这部分内容应用到我们的游戏中呢？让我们一步步说来： NetworkManager 如上图，我们首先向场景中添加一个新的空对象，并在其上添加 Network Manager 和 Network Manager HUD 两个组件，前者是整个网络模块的核心，它负责处理程序作为 client 或 host(server) 时应该进行的网络行为，后者是其的 GUI 界面，方便我们在游戏中直接对其进行操作。这样我们就搭建好了网络模块的基石。 让你的飞机做好准备经过上面的设置，我们的程序已经做好了准备，但是我们的游戏对象们都还对网络模块的到来感到一脸懵逼。我们如何让它们融入网络的环境呢？让我们从飞机开始： 找到我们的飞机对象，为其添加 Network Identity 和 Network Transform，前者是为了让网络模块能够认识到其存在并且将其纳入网络对象的行列（注意勾选 Local Player Authority，来表示其是本地客户端所有的对象），后者是为了实时更新各个客户端上该对象的位置。 之后，我们把飞机制作成预制，删除原来实例化好的游戏对象，将预制添加到 Network Manager 的 Player Prefab 中，整个网络环境就算搭建好了！你甚至可以现在就试玩一下……当然，你会发现一些奇怪的事情——为什么所有客户端实例的视角都是跟随 Host 的飞机的？而且我们在任何客户端上的操作都会对所有飞机生效！别急……我们慢慢道来…… 让本地的东西只为本地服务让我们打开 Aeroplane User Control 2Axis.cs，这个脚本是用于接收用户输入信息，并据此控制飞机运动的。看到满屏不认识的代码是否有些小懵逼？不用担心，我们要做的只是在 FixedUpdate 方法中最前面加上短短的一行： 12if (!isLocalPlayer) return; 这段代码告诉 Unity，如果当前对象不是本地的，那么就不会对其进行操作——从而把对对象的控制权交给服务器全权负责。这样一来，我们的输入就只会影响到本地的对象了。 接下来，是最麻烦的摄像机问题。看看场景中的 Cameras，里面可有着不少东西呢。其中，他有一个叫做 JetCameraRig 的子对象，它的属性里面有一个 Target，看上去因为我们删掉了飞机对象，所以他现在指向的是 None——人畜无害的样子呢！不过…… Unity 在设计之初对他动了些手脚，因而当脚本开始运行时，其的 Target 会自动的锁定在 Tag 为 Player 的对象身上！哦，看看我们的预制小飞机，它的 Tag 正好是 Player，因而我们在开启多个客户端的时候，Camera 会屁颠屁颠地自动把自己绑在他找到的第一个 Player 身上——也就是 Host 的飞机了。 那么，简单地去掉 Tag 就好了嘛？基本上是如此的，不过我们还需要在创建对象的时候设置一下这个 Target，代码是这样的： 12345public override void OnStartLocalPlayer(){ var camera = Instantiate(cameraPrefab) as GameObject; camera.transform.GetChild(0).gameObject.GetComponent&lt;UnityStandardAssets.Cameras.AutoCam&gt;().Target = transform;} 不过……这样就万事大吉了吗？并不！你的 Unity 应该已经在疯狂用红色的 Error 抗议你的所作所为了——Target 不是一个可修改的变量！ 还有这种操作？要解决这个问题，我们就要刨根问底一下了。首先我们提着刀就来到了 AutoCam.cs，然而左右巡视一圈…… “Target人呢？？” 看样子 Target 虽然在 AutoCam 的属性面板中，但是却并不是它的直接数据成员。那么问题应该就很显然了——Target 是 AutoCam 的某个基类的数据成员！一路找下去，我们就能在 AbstractTargetFollower.cs 中找到 Target 的踪迹，把它改成以下的样子，就能够真的搞定了： 1234567891011public Transform Target{ set { m_Target = value; } get { return m_Target; }} 赛道一人一个，不要争抢怀着激动的心再来跑一次！……诶诶诶诶？？怎么我的飞机开局都被彼此挤的到处乱飞……一条跑道不够用啊！ 那就多加几条呗。复制几条跑道，放在合适的地方，万事俱备！不过我们怎么让飞机们乖乖地一人一个跑道呢？创建多个空对象，为他们每人配备一个 Network Start Position 组件，再回到我们的 Network Manager，把 Player Spawn Met 改为 Rolin Robin（旋转罗宾法），这样每架飞机都会安分地选一条跑道起飞了～ 剩下的一些微小的工作搞完这些，我们就只有些基础的内容需要再改改了： 辨识本地对象 在 OnStartLocalPlayer 中修改对象的 Mesh Renderer 的 material 的 color 即可 穿过环加分 为所有的环添加带 Trigger 的碰撞体，添加碰撞的处理函数，为一个 static 的 int + 1，之后通过 IMGUI 显示到屏幕上即可 感想本次作业可以说是 Unity3D 开课以来最为有趣的几次作业之一！在本次作业中，我们深入探寻了隐藏在网络游戏背后的秘密，这不仅对我们游戏开发有很大的好处，还能帮助我们融会贯通 web 技术、计算机网络等方面的知识，可谓是一举多得了～ 奇奇怪怪的链接b站视频～","link":"/Unity3D/Get-Started-with-Unity3D-8/"},{"title":"Service Computing 02 - Golang CLI Program - Selpg","text":"设计说明 包引用 初始化 标识、参数预处理 接受输入数据 数据处理 输出结果 使用方法 安装程序 使用范例和参数说明 必需参数：-sNumber，-eNumber 互斥的可选参数：-lNumber，-f 可选参数：-dDestination 可选参数：file_name 测试 生成测试文件 测试与结果 设计说明本程序参照 开发 Linux 命令行实用程序 的设计，以 go 语言替代 C 语言构建。下面我们分版块来讲解实现。完整源代码 包引用123456789101112package mainimport ( \"bufio\" \"io\" \"log\" \"os\" \"os/exec\" \"strings\" flag \"github.com/spf13/pflag\") 在这一部分，我们声明了程序所要用到的所有包： bufio：用于从标准输入流获取数据和将数据写入到标准输出流 io：用于引用 io.EOF 来判断错误是否是文件尾导致 log：用于将错误信息写入到标准错误流 os：用于打开文件和异常退出时发送状态码 os/exec：用于开启 lp 子进程 strings：用于划分、拼接字符串 github.com/spf13/pflag：用于获取程序运行时用户输入的参数和标识 初始化12345678910111213141516// Initializing //startNumber := flag.IntP(\"startpage\", \"s\", 0, \"The page to start printing at [Necessary, no greater than endpage]\")endNumber := flag.IntP(\"endpage\", \"e\", 0, \"The page to end printing at [Necessary, no less than startpage]\")lineNumber := flag.IntP(\"linenumber\", \"l\", 72, \"If this flag is used, a page will consist of a fixed number of characters, which is given by you\")forcePage := flag.BoolP(\"forcepaging\", \"f\", false, \"Change page only if '-f' appears [Cannot be used with -l]\")destinationPrinter := flag.StringP(\"destination\", \"d\", \"\", \"Choose a printer to accept the result as a task\")// StdErr printer //l := log.New(os.Stderr, \"\", 0)// Data holder //bytes := make([]byte, 65535)var data stringvar resultData stringflag.Parse() 在这个部分，我们进行了初始化操作。这包括对于 pflag 中各个标识的设置和变量绑定，标准错误流的绑定，缓冲区 bytes 的创建，读入数据变量、结果数据变量的创建。 在完成这些设置后，我们通过 flag.Parse() 方法使得 pflag 执行对于标识和参数的解析。 标识、参数预处理123456789101112131415161718192021222324252627// Are necessary flags given? //if *startNumber == 0 || *endNumber == 0 { l.Println(\"Necessary flags are not given!\") flag.Usage() os.Exit(1)}// Are flags value valid? //if (*startNumber &gt; *endNumber) || *startNumber &lt; 0 || *endNumber &lt; 0 || *lineNumber &lt;= 0 { l.Println(\"Invalid flag values!\") flag.Usage() os.Exit(1)}// Are lineNumber and forcePage set at the same time? //if *lineNumber != 72 &amp;&amp; *forcePage { l.Println(\"Linenumber and forcepaging cannot be set at the same time!\") flag.Usage() os.Exit(1)}// Too many arguments? //if flag.NArg() &gt; 1 { l.Println(\"Too many arguments!\") flag.Usage() os.Exit(1)} 在这部分，我们检验了所有标识的合法性，这包括： 必须的标识，-s 和 -e 是否被设置？ 标识是否具有一个合法的值 互斥的参数，也就是通过行数分页和通过分页符分页，是否被同时设置 参数数量是否过多 如果任何不合法的参数被使用，那么我们向标准错误流输出错误信息，打印正确使用方法，然后退出程序（并返回一个通用的错误状态码）。 接受输入数据12345678910111213141516171819202122232425262728293031323334353637383940// StdIn or File? //if flag.NArg() == 0 { // StdIn condition // reader := bufio.NewReader(os.Stdin) size, err := reader.Read(bytes) for size != 0 &amp;&amp; err == nil { data = data + string(bytes) size, err = reader.Read(bytes) } // Error if err != io.EOF { l.Println(\"Error occured when reading from StdIn:\\n\", err.Error()) os.Exit(1) }} else { // File condition // file, err := os.Open(flag.Args()[0]) // TODO TEST: is PATH needed? if err != nil { l.Println(\"Error occured when opening file:\\n\", err.Error()) os.Exit(1) } // Read the whole file size, err := file.Read(bytes) for size != 0 &amp;&amp; err == nil { data = data + string(bytes) size, err = file.Read(bytes) } // Error if err != io.EOF { l.Println(\"Error occured when reading file:\\n\", err.Error()) os.Exit(1) }} 在这一部分，我们判断输入方式，并且将数据读入并写在 data 变量中。 对于 标准输入 的模式，也就是没有额外参数的情况：我们首先通过 bufio.NewReader(os.Stdin) 创建一个绑定到标准输入流的读者，然后通过它向缓冲区 bytes 读入数据，并且将其转换为字符串并写入到 data 中。由于缓冲区的大小限制，这个读入过程可能需要进行多次，因而我们迭代该过程，直到确保读完了标准输入流的数据（也就是该次读入没有读入到数据，即 size = 0）为止。在读入遇到错误时，我们输出错误信息，并且退出程序。 对于 文件输入 的模式，也就是有一个参数的情况：我们首先通过 os.Open() 打开文件。在没有错误的情况下，我们通过 file.Read() 迭代地从中读入数据，直到完成读取。如果我们在整个过程中遇到错误，那么输出错误信息，并且退出程序。 在完成这一个部分的处理后，我们的数据信息就存储在了 data 变量中。 数据处理123456789101112131415161718192021222324252627// LineNumber or ForcePaging? //if *forcePage { // ForcePaging // pagedData := strings.SplitAfter(data, \"\\f\") if len(pagedData) &lt; *endNumber { l.Println(\"Invalid flag values! Too large endNumber!\") flag.Usage() os.Exit(1) } resultData = strings.Join(pagedData[*startNumber-1:*endNumber+1], \"\")} else { // LineNumber // lines := strings.SplitAfter(data, \"\\n\") if len(lines) &lt; (*endNumber-1)*(*lineNumber)+1 { l.Println(\"Invalid flag values! Too large endNumber!\") flag.Usage() os.Exit(1) } if len(lines) &lt; *endNumber*(*lineNumber) { resultData = strings.Join(lines[(*startNumber)*(*lineNumber)-(*lineNumber):len(lines)], \"\") } else { resultData = strings.Join(lines[(*startNumber)*(*lineNumber)-(*lineNumber):(*endNumber)*(*lineNumber)], \"\") }} 在这部分，我们对存储在 data 里的字符串进行处理，以满足用户要求。这部分根据分页过程的不同分为两种：按分页符分页和按行分页。 在按 分页符分页 的情况下，我们通过 strings.SplitAfter() 方法来将字符串以 '\\f' 为界分为数个段，每一段即是一页，然后我们根据用户输入的开始页码和结束页码将相应的数据写入 resultData 中。 在 按行数分页 的情况下，我们首先以 '\\n' 为界将字符串分段，然后根据开始页码和结束页码计算出开始行和结束行，并将其间数据写入 resultData 中。 输出结果123456789101112131415161718192021222324252627282930313233writer := bufio.NewWriter(os.Stdout)// StdOut or Printer? //if *destinationPrinter == \"\" { // StdOut // fmt.Printf(\"%s\", resultData)} else { // Printer // cmd := exec.Command(\"lp\", \"-d\"+*destinationPrinter) lpStdin, err := cmd.StdinPipe() if err != nil { l.Println(\"Error occured when trying to send data to lp:\\n\", err.Error()) os.Exit(1) } go func() { defer lpStdin.Close() io.WriteString(lpStdin, resultData) }() out, err := cmd.CombinedOutput() if err != nil { l.Println(\"Error occured when sending data to lp:\\n\", err.Error()) os.Exit(1) } _, err = writer.Write(out) if err != nil { l.Println(\"Error occured when writing information to StdOut:\\n\", err.Error()) os.Exit(1) }} 在这部分，我们以输出方式的不同分为两类：直接输出到标准输出流的和将数据传送给 lp 进行打印工作的。由于二者实际上都需要用到标准输出流（后者是要输出 lp 的信息），所以我们首先创建了与标准输出流绑定的 Writer：writer。 对于直接输出到标准输出流的，我们直接通过 Writer.Write() 方法将转换为 byte 切片的字符串输出即可。 而对于输出到 lp 的，我们首先通过 exec.Command() 创建一个 lp 的子进程，并且通过 cmd.StdinPipe() 获取和其标准输入绑定的管道，然后将数据送入管道即可。同时，我们也需要将 lp 指令的输出转发到标准输出流上，方便用户查看。 在这期间对于错误的处理依旧和前文相同：输出错误并退出程序。 使用方法使用方法基本同 C 版本的 selpg。 安装程序在配置好 golang 环境的前提下，运行： 1go get github.com/siskonemilia/selpg 若成功执行（无回显），则安装成功。 使用范例和参数说明1selpg -sNumber -eNumber [-lNumber/-f] [-dDestination] [file_name] 必需参数：-sNumber，-eNumberselpg 要求用户用两个命令行参数“-sNumber”（例如，“-s10”表示从第 10 页开始）和“-eNumber”（例如，“-e20”表示在第 20 页结束）指定要抽取的页面范围的起始页和结束页。selpg 对所给的页号进行合理性检查；换句话说，它会检查两个数字是否为有效的正整数以及结束页是否不小于起始页。两者是程序执行所必需的。 互斥的可选参数：-lNumber，-fselpg 可以处理两种输入文本： 类型 1：该类文本的页行数固定。这是缺省类型，因此不必给出选项进行说明。也就是说，如果既没有给出“-lNumber”也没有给出“-f”选项，则 selpg 会理解为页有固定的长度（每页 72 行）。例如： selpg -s10 -e20 -l66类型 2：该类型文本的页由 ASCII 换页字符（十进制数值为 12，在 C 中用“\\f”表示）定界。该格式与“每页行数固定”格式相比的好处在于，当每页的行数有很大不同而且文件有很多页时，该格式可以节省磁盘空间。在含有文本的行后面，类型 2 的页只需要一个字符 ― 换页 ― 就可以表示该页的结束。打印机会识别换页符并自动根据在新的页开始新行所需的行数移动打印头。例如： selpg -s10 -e20 -f 可选参数：-dDestinationselpg 还允许用户使用“-dDestination”选项将选定的页直接发送至打印机。这里，“Destination”应该是 lp 命令“-d”选项（请参阅“man lp”）可接受的打印目的地名称。该目的地应该存在 ― selpg 不检查这一点。在运行了带“-d”选项的 selpg 命令后，若要验证该选项是否已生效，请运行命令“lpstat -t”。该命令应该显示添加到“Destination”打印队列的一项打印作业。如果当前有打印机连接至该目的地并且是启用的，则打印机应打印该输出。 可选参数：file_name如果没有给出 file_name，那么 selpg 将从标准输入流读取数据进行处理，否则，selpg 将根据文件名寻找相应文件，并从中读取数据进行处理。 测试该部分参照 使用 selpg 进行程序测试。 生成测试文件为了使得实验结果直观易懂，我们采用固定的程序生成的输入文件进行测试，生成程序如下： 12345# input_file_generator.shfor i in {1..7200}do echo $i &gt;&gt; input_filedone 其生成的结果是一个由 1 到 7200 的，步长为 1 的等差数列，且每行一个数字。即是说，每一行的数字都是该行的编号。 测试与结果 把 input_file 的第 1 页写至标准输出 $selpg -s1 -e1 input_file 结果： 1 2 ... 72 selpg 读取标准输入，而标准输入已被 shell 重定向为来自 input_file 而不是显式命名的文件名参数。输入的第 1 页被写至屏幕 $ selpg -s1 -e1 &lt; input_file 结果： 1 2 ... 72 cat 的标准输出被 shell／内核重定向至 selpg 的标准输入。将第 10 页到第 20 页写至 selpg 的标准输出 $ cat input_file | selpg -s10 -e20 结果： 649 650 ... 1440 selpg 将第 10 页到第 20 页写至标准输出（屏幕）；所有的错误消息被 shell 重定向至 error_file $ selpg -s10 -e20 input_file 2&gt;error_file 结果： 649 650 ... 1440 error_file: 无内容 selpg 将第 10 页到第 20 页写至标准输出；标准输出被 shell 重定向至 res $selpg -s10 -e20 input_file &gt;res 结果（res文件内容）： 649 650 ... 1440 selpg 将第 10 页到第 20 页写至标准输出，标准输出被重定向至 res，selpg 写至标准错误的所有内容都被重定向至 error_file $selpg -s10 -e20 input_file &gt;res 2&gt;error_file 结果（res文件内容）： 649 650 ... 1440 error_file: 无内容 selpg 的标准输出透明地被 shell 重定向，成为 cat 的标准输入，第 10 页到第 20 页被写至该标准输入 $ selpg -s10 -e20 input_file | cat 结果： 649 650 ... 1440 将页长设置为 66 行，这样 selpg 就可以把输入当作被定界为该长度的页那样处理。第 10 页到第 20 页被写至 selpg 的标准输出 $ selpg -s10 -e20 -l66 input_file 结果： 595 596 ... 1320 假定页由换页符定界。第 10 页到第 20 页被写至 selpg 的标准输出 $ selpg -s10 -e20 -f input_file 结果（输入文件没有换页符，所以只有一页）： Invalid flag values! Too large endNumber! Usage of selpg: -d, --destination string Choose a printer to accept the result as a task -e, --endpage int The page to end printing at [Necessary, no less than startpage] -f, --forcepaging Change page only if &apos;-f&apos; appears [Cannot be used with -l] -l, --linenumber int If this flag is used, a page will consist of a fixed number of characters, which is given by you (default 72) -s, --startpage int The page to start printing at [Necessary, no greater than endpage] 第 10 页到第 20 页由管道输送至命令 lp -dlp1，该命令将使输出在打印机 lp1 上打印 $ selpg -s10 -e20 -dlp1 input_file 结果（因为没有打印机）： Error occured when sending data to lp: exit status 1 经测试，程序运行符合预期，工作正常。","link":"/Service-Computing/Golang-CLI-Program-Selpg/"},{"title":"Leetcode 4. Median of Two Sorted Arrays","text":"题目4. Median of Two Sorted Arrays Difficulty: Hard Total Accepted: 301.7K Total Submissions: 1.3M There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example1: nums1 = [1, 3] nums2 = [2] The median is 2.0Exaple2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5题目链接 解题报告AC 截图 题目大意本题要求寻找两个有序序列合并后的序列的「中位数」。同时要求 O(log (m+n)) 级别的时间复杂度。 解题思路在一个序列中寻找一个数，又要求 O(log) 级的时间复杂度，我们很容易想到通过不断分割区间来寻找目标数的二分查找法。那么唯一的问题是如何在两个有序序列上应用针对单条序列的二分查找法了。 创建变量 start1、end1、start2、end2、halfSize，分别标识两个序列当前处理区间的头和尾，以及用于计数左侧较小数个数。通过不断对比两个区间中间数的大小，来使得中间数靠近，直到 halfSize 达到序列长度的一半即可（题解中为从一半减少到1）。 题解1C++ 代码123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int lengthSum = nums1.size() + nums2.size(); return (lengthSum % 2 == 1) ? (double)findMedian(nums1, nums2, 0, nums1.size(), 0, nums2.size(), (lengthSum + 1) / 2): ((double)findMedian(nums1, nums2, 0, nums1.size(), 0,nums2.size(), lengthSum / 2 + 1) + (double)findMedian(nums1, nums2, 0, nums1.size(), 0,nums2.size(), lengthSum / 2)) / 2; } int findMedian(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, const int start1, const int end1, const int start2, const int end2, const int halfSize) { int size1 = end1 - start1, size2 = end2 - start2; if (size1 &lt;= 0) return nums2[start2 + halfSize - 1]; if (size2 &lt;= 0) return nums1[start1 + halfSize - 1]; if (halfSize == 1) return min(nums1[start1], nums2[start2]); int mid1 = (end1 + start1) / 2, mid2 = (end2 + start2) / 2; if (nums1[mid1] &lt;= nums2[mid2]) { if (size1 / 2 + size2 / 2 + 1 &gt;= halfSize) { return findMedian(nums1, nums2, start1, end1, start2, mid2, halfSize); } else { return findMedian(nums1, nums2, mid1 + 1, end1, start2, end2, halfSize - size1 / 2 - 1); } } else { if (size1 / 2 + size2 / 2 + 1 &gt;= halfSize) { return findMedian(nums1, nums2, start1, mid1, start2, end2, halfSize); } else { return findMedian(nums1, nums2, start1, end1, mid2 + 1, end2, halfSize - size2 / 2 - 1); } } }}; AC 截图 题解分析虽然这个题解顺利通过了测试，但是我们发现，前面的最优解还有相当多……那么尝试对于代码进行优化。我们知道，递归方法相对于迭代法需要在每次递归时，对栈进行单独的操作——在空间和时间复杂度上都不如迭代法。 那么，是否可以把递归法转换为迭代法呢——当然可以啦～ 题解2C++ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution { public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int lengthSum = nums1.size() + nums2.size(); return (lengthSum % 2 == 1) ? (double)findMedian(nums1, nums2, 0, nums1.size(), 0, nums2.size(), (lengthSum + 1) / 2) : ((double)findMedian(nums1, nums2, 0, nums1.size(), 0, nums2.size(), lengthSum / 2 + 1) + (double)findMedian(nums1, nums2, 0, nums1.size(), 0, nums2.size(), lengthSum / 2)) / 2; } int findMedian(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int start1, int end1, int start2, int end2, int halfSize) { int size1, size2, mid1, mid2; while (true) { size1 = end1 - start1; size2 = end2 - start2; if (size1 &lt;= 0) return nums2[start2 + halfSize - 1]; if (size2 &lt;= 0) return nums1[start1 + halfSize - 1]; if (halfSize == 1) return min(nums1[start1], nums2[start2]); mid1 = (end1 + start1) / 2; mid2 = (end2 + start2) / 2; if (nums1[mid1] &lt;= nums2[mid2]) { if (size1 / 2 + size2 / 2 + 1 &gt;= halfSize) { end2 = mid2; continue; } else { start1 = mid1 + 1; halfSize -= size1 / 2 + 1; continue; } } else { if (size1 / 2 + size2 / 2 + 1 &gt;= halfSize) { end1 = mid1; continue; } else { start2 = mid2 + 1; halfSize -= size2 / 2 + 1; continue; } } } }}; AC 截图 题解分析嗯？这两个的耗时完全没有区别啊！看来是编译器已经把我的递归优化掉了……那么和第一梯队如此大的时间差又是从何而来呢？ 参加过 ACM 的同学应该都知道，能用 scanf 的代码绝对不用 cin。不过其实 cin 的效率并不算差，只是，我们需要对其进行一些优化才能让他发挥出应有的实力。要想解放 cin 实力的封印，一行代码足矣： ios::sync_with_stdio(false);这会禁用 cin／cout 和 scanf／printf 之间的同步等待，从而大幅提升 cin 的效率——甚至可以直追 scanf。但是这里我们又有一个问题了，我们函数的调用显然是在输入操作之后，怎样才能让这个函数在输入操作前生效呢？当然是有办法的啦： 题解3（最优解）C++ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return nullptr;}();class Solution {public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int lengthSum = nums1.size() + nums2.size(); return (lengthSum % 2 == 1) ? (double)findMedian(nums1, nums2, 0, nums1.size(), 0, nums2.size(), (lengthSum + 1) / 2) : ((double)findMedian(nums1, nums2, 0, nums1.size(), 0, nums2.size(), lengthSum / 2 + 1) + (double)findMedian(nums1, nums2, 0, nums1.size(), 0, nums2.size(), lengthSum / 2)) / 2; } int findMedian(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp;nums2, int start1, int end1, int start2, int end2, int halfSize) { int size1, size2, mid1, mid2; while (true) { size1 = end1 - start1; size2 = end2 - start2; if (size1 &lt;= 0) return nums2[start2 + halfSize - 1]; if (size2 &lt;= 0) return nums1[start1 + halfSize - 1]; if (halfSize == 1) return min(nums1[start1], nums2[start2]); mid1 = (end1 + start1) / 2; mid2 = (end2 + start2) / 2; if (nums1[mid1] &lt;= nums2[mid2]) { if (size1 / 2 + size2 / 2 + 1 &gt;= halfSize) { end2 = mid2; continue; } else { start1 = mid1 + 1; halfSize -= size1 / 2 + 1; continue; } } else { if (size1 / 2 + size2 / 2 + 1 &gt;= halfSize) { end1 = mid1; continue; } else { start2 = mid2 + 1; halfSize -= size2 / 2 + 1; continue; } } } }}; AC 截图 题解分析通过声明一个静态的常量变量，我们使得后面这个自执行的函数甚至可以在编译阶段预执行，从而在输入输出前完成对于 cin/cout 的设置～总时耗也从 56ms 下降到了 16ms，妥妥的第一梯队～看来算法和实现细节都是保证程序执行速度的重要环节呢。","link":"/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/"},{"title":"Leetcode 188. Best Time to Buy and Sell Stock","text":"本题有四个不同难度的版本： 121. Best Time to Buy and Sell Stock 122. Best Time to Buy and Sell Stock II 123. Best Time to Buy and Sell Stock III 188. Best Time to Buy and Sell Stock IV 下面分题进行讲解： 121. Best Time to Buy and Sell Stock Difficulty: Easy Total Accepted: 379.2K Total Submissions: 843.6K Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price.Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.解题思路本题要求很简单，对于一个价格波动的股票，我们需要找到一个买入点和一个卖出点，使得最终收益最大化。因而我们只需要创建一个数组，存储从一开始到第 i 个价格的最低价格，然后用当前价格减去它，即可得到当前卖出的最大收益，并最终得到全局卖出的最大收益。 题解（最优解） 123456789101112131415161718192021222324static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int size = prices.size(); int *minPrice = new int[size]; int maxProfit = 0; if (size) { minPrice[0] = prices[0]; for (int i = 1; i &lt; size; ++i) { minPrice[i] = min(minPrice[i-1], prices[i]); maxProfit = max(maxProfit, prices[i] - minPrice[i]); } } return maxProfit; }}; 122. Best Time to Buy and Sell Stock II Difficulty: Easy Total Accepted: 258.8K Total Submissions: 520.4K Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.解题思路本题相比上题只是多了一个「可任意次数买卖的条件」，不过这对我们而言反而是一件好事。因为由此一来，我们实际上可以赚取到理论最大收益，所以我们只需要统计所有股票涨的价格即可。 题解（最优解） 123456789101112131415161718192021static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int size = prices.size(); int *minPrice = new int[size]; int maxProfit = 0; for (int i = 1; i &lt; size; ++i) { if (prices[i] &gt; prices[i - 1]) { maxProfit += prices[i] - prices[i - 1]; } } return maxProfit; }}; 123. Best Time to Buy and Sell Stock III Difficulty: Hard Total Accepted: 127.2K Total Submissions: 398.0K Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.解题思路本题相对要复杂些，题目将交易的次数限制为两次，所以我们不能单纯地去找最优的那一次。所以我们实际上需要去寻找两个不交叉的交易段，也就是一共四个时间点（买入1、买入2、卖出1、卖出2）。进一步想，我们可以如此维护这四个变量： 若当前价格使得买入后财富损失最小，则记录当前值 若当前价格使得在 1 的前提下卖出收益最大，则记录当前值 若当前价格使得在 2 的前提下买入综合收益最大，则记录当前值 若当前价格使得在 3 的前提下卖出综合收益最大，则记录当前值 最后在步骤四记录的价格便是本题结果了。为什么我们可以这样做呢？实际上，我们在步骤四中维护的值是「在之前的某点第一次卖出后，所能获取的最大的收益」，是一个全局最优值。至于证明过程就留给各位读者自行解决了。 题解（最优解） 12345678910111213141516171819202122232425static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { if (prices.size() &lt; 2) return 0; int buy1 = INT_MIN, buy2 = INT_MIN, sell1 = 0, sell2 = 0; for (auto&amp; price : prices) { sell2 = max(buy2 + price, sell2); buy2 = max(sell1 - price, buy2); sell1 = max(buy1 + price, sell1); buy1 = max(-price, buy1); } return (sell2 &gt; 0) ? sell2 : 0; }}; 188. Best Time to Buy and Sell Stock IV Difficulty: Hard Total Accepted: 133K Total Submissions: 520K Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.解题思路实际上是上一题的拓展，我们只需要把上一题固定的变量数量变为可变的就可以求解得出了。但是需要注意的是，直接如此使用可能会导致内存爆炸，建议加一个在 k 足够大时，调用前面第二题的方法的逻辑 题解（最优解） 123456789101112131415161718192021222324252627282930313233343536373839404142434445static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();class Solution {public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) { if (prices.size() &lt; 2) return 0; if (k &lt; 1) return 0; if (k * 2 &gt; prices.size()) return easyAdd(prices); vector&lt;int&gt; buys; vector&lt;int&gt; sells; for (int i = 0; i &lt; k; ++i) { buys.push_back(INT_MIN); sells.push_back(0); } for (auto&amp; price : prices) { buys[0] = max(-price, buys[0]); for (auto iter1 = buys.begin(), iter2 = sells.begin(); iter1 != buys.end();) { *iter2 = max(*iter2, *(iter1++) + price); *iter1 = max(*iter1, *(iter2++) - price); } *(sells.rbegin()) = max(*(sells.rbegin()), *(buys.rbegin()) + price); } return *(sells.rbegin()); } int easyAdd(vector&lt;int&gt;&amp; prices) { int sum = 0; int previousPrice = prices[0]; for (auto&amp; price : prices) { sum += max(price - previousPrice, 0); previousPrice = price; } return sum; }};","link":"/Leetcode/Leetcode-188-Best-Time-to-Buy-and-Sell-Stock/"},{"title":"Leetcode 41. First Missing Positive","text":"题目41. First Missing Positive Difficulty: Hard Total Accepted: 152.5K Total Submissions: 571.7K Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1, 2, 0] Output: 3Example 2: Input: [3,4,-1,1] Output: 2Example 3: Input: [7,8,9,11,12] Output: 1Note: Your algorithm should run in O(n) time and uses constant extra space. 题目链接 解题报告AC 截图 题目大意本题要求寻找到一串未排序的整数中，缺失的最小的正整数。同时要求 $O(n)$ 级的时间复杂度和常量级的空间开销。 解题思路最容易想到的解题方法莫过于从 1 开始，将正整数依次在整个数组中寻找一遍。但是这种在无序数组上进行的扫描，时间复杂度为 $O(n^2)$，显然是不符合要求的。 另一个容易想到的方法是建立一个等规模的布尔数组，初始值为 false，然后扫描一次原始数组，将对应下标的布尔值置为 true。最后扫描一遍布尔数组，即可以以 $O(n)$ 的时间复杂度完成。但是这种方法需要开辟一个变长的空间，不符合题目「常量级空间开销」的要求。 那么要如何优化这两种方法，来满足题目要求呢？ 从第一种方法出发，既然无序的数组上扫描会超时，那么我们就尝试在 $O(n)$ 时间复杂度内构建一个“特殊的”有序数组即可。 从第二种方法出发，既然不允许变长的额外空间开销，那么我们就尝试使用原数组的空间来作为“布尔数组”即可。 两种方法的优化最后都指向同一个解法：先对原数组进行操作，使之可以在一次扫描后得出结果。 那么如何进行操作呢？我们知道，我们的目标是寻找缺失的最小的正整数，那么我们可以吧所有数字放到其对应的位置（比如数字 1 放到下标为 0 的位置上，数字 4 放到下标为 3 的位置上），这样一来，array[index] == index + 1 这些布尔值就构成了第二种方法中的“布尔数组”，不满足这个条件的最小的 index，对应的数字 index + 1 就是题解。 构建数组的过程也是简单的，顺序扫描整个数组，不断将当前位置的数字和其应该处于的位置上的数字进行交换，就可以在 $O(n)$ 的时间复杂度下完成操作。再加上最后的扫描求解，整个解法的复杂度为 $O(n)$. 题解1C++ 代码12345678910111213141516171819202122class Solution {public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) { int index, length; length = nums.size(); for (index = 0; index &lt; length; ++index) { while (nums[index] &gt; 0 &amp;&amp; nums[index] &lt;= length &amp;&amp; nums[index] != nums[nums[index] - 1]) { swap(nums[index], nums[nums[index] - 1]); } } for (index = 0; index &lt; length; ++index) { if (nums[index] != index + 1) { return index + 1; } } return length + 1; }}; AC 截图 题解分析虽然这个题解顺利通过了测试，但是竟然还有 16.03% 的更优解？是我算法的问题吗？ 打开最优解的示例代码一看： 12345678910111213141516171819class Solution {public: // time: O(n), space: O(1) int firstMissingPositive(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; i ++) { while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i]-1] != nums[i]) { swap(nums[i], nums[nums[i] - 1]); } } for (int i = 0; i &lt; n; i ++) { if (nums[i] != i + 1) return i + 1; } return n+1; }}; 乍一眼看过去……这不和我是一样的吗？而且 i++ 的效率显然不如 ++i，怎么可能还比我快？他甚至还在每个 for 循环中重新声明变量 i，这肯定是比我直接声明好进行复用要更慢啊！不信邪的我也改了一下自己的代码，于是有了题解2…… 题解2（最优解）c++ 代码12345678910111213141516171819202122class Solution {public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) { int length; length = nums.size(); for (int index = 0; index &lt; length; ++index) { while (nums[index] &gt; 0 &amp;&amp; nums[index] &lt;= length &amp;&amp; nums[index] != nums[nums[index] - 1]) { swap(nums[index], nums[nums[index] - 1]); } } for (int index = 0; index &lt; length; ++index) { if (nums[index] != index + 1) { return index + 1; } } return length + 1; }}; AC 截图 题解分析看样子确实是重新声明的写法会更快……但……为什么复用的效率反而不如每次重新声明高？这不科学！我不接受！ 如何找到问题的源头呢？当然是反汇编啦～ 测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;class Solution {public: int solve1(vector&lt;int&gt;&amp; nums) { int length; length = nums.size(); for (int index = 0; index &lt; length; index++) { while (nums[index] &gt; 0 &amp;&amp; nums[index] &lt;= length &amp;&amp; nums[index] != nums[nums[index] - 1]) { swap(nums[index], nums[nums[index] - 1]); } } for (int index = 0; index &lt; length; index++) { if (nums[index] != index + 1) { return index + 1; } } return length + 1; } int solve2(vector&lt;int&gt;&amp; nums) { int index, length; length = nums.size(); for (index = 0; index &lt; length; index++) { while (nums[index] &gt; 0 &amp;&amp; nums[index] &lt;= length &amp;&amp; nums[index] != nums[nums[index] - 1]) { swap(nums[index], nums[nums[index] - 1]); } } for (index = 0; index &lt; length; index++) { if (nums[index] != index + 1) { return index + 1; } } return length + 1; }};int main(){ Solution ins; vector&lt;int&gt; input = { 1, 2, 0 }; auto ans = ins.solve1(input); ans = ins.solve2(input); return 0;} Windows 汇编：solve1 Windows 汇编：solve2 令人吃惊的是：两者的汇编代码几乎是完全一样的！唯一的区别在于：由于 index 和 length 的声明先后顺序不同，其在内存中的地址（相对于ebp）在两个函数中对调了。这虽然没能验证反复声明反而更快的结果，但至少说明了 在 for 循环初始化语句中声明变量，不会比在外部声明更耗时。同时也告诉我们，单纯通过高级语言编写中的直觉推测程序在机器上执行的效率是危险的。 那么，为什么 solve2 会更快呢？事实上，经过测试，在 Windows VS 环境下，二者速度是基本一致的。那么是编译器和环境的问题吗？ 查找 Leetcode 的编译环境，我了解到其使用的是 G++ 6.4，C++14 标准。于是我在 MacOS 环境下对于其使用 g++ 进行编译，并且利用 objdump 得到汇编结果，通过重定向保存到 main.s 文件内： 12g++ -g -c main.cpp -std=c++14objdump -d -S main.o &gt; main.s g++ on MacOS 汇编：solve1 g++ on MacOS 汇编：solve2 然而结果依旧如故——二者几乎是完全一样的！至此我就拿它毫无办法了……根据网上查询的结果推测，可能是空间高度受限的情况下，生命周期长的 index 导致了高速缓冲数据的频繁不命中，但是这个说法依旧有很多问题……希望哪位大佬能够不吝赐教。 附上完整的汇编代码（macos）： g++ on MacOS 汇编","link":"/Leetcode/Leetcode-41-First-Missing-Positive/"},{"title":"Leetcode 685. Redundant Connection II","text":"题目685. Redundant Connection II Difficulty: Hard Total Accepted: 11.2K Total Submissions: 39.7K In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents. The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, …, N), with one additional directed edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v. Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given directed graph will be like this: 1 / \\ v v 2--&gt;3Example 2: Input: [[1,2], [2,3], [3,4], [4,1], [1,5]] Output: [4,1] Explanation: The given directed graph will be like this: 5 &lt;- 1 -&gt; 2 ^ | | v 4 &lt;- 3Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array. 解题报告AC 截图 题目大意该问题给出一组有向图内的边，并且给出等同数量的节点，构成一个可以通过 删掉一条边 而成为 有根树 的有向图。在有多个答案时，输出最后出现的可用边。 解题思路该题乍一看情况非常复杂，因为要从一个有向图转换为有根树，需要消除图中所有的回环，以及所有入度大于 1 的节点（后称「双源」节点）。但是冷静下来想想，题目其实已经给出了相当优厚的条件——只能删掉一条边。 根据这个条件，我们可以反推回输入数据的情况：该有向图只可能是下列三种情况的一种。 有一个回环，没有「双源」节点 有一个「双源」节点，没有回环 有一个「双源」节点，并且该节点也在一个回环内 考虑第一种情况，因为只删掉一条边就可以构成有根树，那么最后形成环的那条边，肯定就是我们要找的边，因而在扫描一边所有边的时候监控整个图的连通性即可，一旦发现成环，我们就删掉那条边。 考虑第二种情况，在没有回环的情况下，两条边可以 任意地删除，因而删除触发形成双源节点条件的边即可，因其相对位于集合的后部，处理方式同第一种。 考虑第三种情况，因为这个时候双源节点接入的两条边中有一条会参与成环，因而要同时解除成环和双源，我们只能 删掉参与成环和双源节点的唯一边。同时，为了保证不会漏掉这种重叠情况，在前两种情况的判定中，我们 不能在判定后立刻作出相应操作，而要等待整个边集合扫描完后再处理。 那么接下来，我们来考虑如何判定双源与回环的问题。 （这实际上是一个简化的 并查集 问题，有兴趣的同学可以了解一下）我们维护一个「祖先」数组，它标定整个图中每个节点的祖先。每当一条边由点 A 指向点 B 时，我们令点 B 的祖先为点 A 的祖先。这样，当一条边指向一个有祖先的节点时，就会发生「双源」；当一条边的两端祖先相同时，就会发生「回环」。 必须要考虑的是，当「双源」发生时，对双源节点的祖先查找可能引导向两个结果，如何对两个结果进行处理会是一个问题。 题解 1结果截图 C++ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return nullptr;}();class Solution {public: int parent1, parent2; int subParent1, subParent2; vector&lt;int&gt; *doubleSourceEdge, *circularEdge; int doubleSourceNode; int subParent; int sameParent; vector&lt;int&gt; findRedundantDirectedConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) { int size = edges.size(); int *parent = new int[size + 1]; int *father = new int[size + 1]; doubleSourceEdge = circularEdge = nullptr; doubleSourceNode = subParent = 0; memset(parent, 0, (size + 1) * sizeof(int)); for (auto &amp;iter : edges) { if (doubleSourceNode) { auto temp1 = findParentFork(parent, father, iter[0]), temp2 = findParentFork(parent, father, iter[1]); parent1 = temp1[0]; parent2 = temp2[0]; subParent1 = temp1[1]; subParent2 = temp2[1]; } else { parent1 = findParent(parent, iter[0]); parent2 = findParent(parent, iter[1]); } if (parent[iter[1]]) { // Double source if (parent1 == parent2) { return iter; } if (circularEdge) { return vector&lt;int&gt;({father[iter[1]], iter[1]}); } else { doubleSourceNode = iter[1]; doubleSourceEdge = new vector&lt;int&gt;({father[iter[1]], iter[1]}); } subParent = parent2; } if (doubleSourceNode) { if ((sameParent = parent1) == parent2 || (sameParent = parent1) == subParent2 || (sameParent = parent2) == subParent1) { if (findParent(parent, doubleSourceNode) == sameParent) { return vector&lt;int&gt;({father[doubleSourceNode], doubleSourceNode}); } else { return *doubleSourceEdge; } } } else if (parent1 == parent2) { // Circular path circularEdge = new vector&lt;int&gt;({iter[0], iter[1]}); } parent[iter[1]] = parent1; father[iter[1]] = iter[0]; } if (doubleSourceNode) { return vector&lt;int&gt;({father[doubleSourceNode], doubleSourceNode}); } else { return *circularEdge; } } int findParent(int *parent, int index) { if (index == parent[index] || parent[index] == 0) return index; else return findParent(parent, parent[index]); } vector&lt;int&gt; findParentFork(int *parent, int *father, int index) { if (index == parent[index] || parent[index] == 0) return vector&lt;int&gt;({index, 0}); else { if (index == doubleSourceNode) return vector&lt;int&gt;({findParent(parent, father[index]), findParent(parent, subParent)}); else return findParentFork(parent, father, father[index]); } }}; 改进思路在题解 1 中，我们通过在一次扫描中监控前两种情况来达成要求。在检测到其中一种情况发生后，我们将继续扫描，直到第三种情况发生或者到达终点。这个算法很好的达到了我们的预期效果，但是有很多问题。 首先，在触发「双源」后，后续扫描复杂度陡增，严重影响了程序运行效率。其次，过于复杂的逻辑判断大大增加了编程难度。最后，在“寻找祖先”的过程中，大量可以复用的信息被浪费掉。 那么有没有什么优化的办法呢？ 首先，我们考虑一下这三种情况。实际上我们不必在扫描时判断如此多的内容。首先，我们进行一次扫描，查看是否有「双源」的发生。若有，我们去除触发双源的边，再进行一次查找，此时如果没有回环的发生，那么这条边就是目标边，否则，就说明是另一条「双源」边在回环内，那条边也就是目标边。如果没有发生「双源」，则是简单的回环问题，找到成环边即可。 然后，我们考虑一下信息复用的问题。由动态规划的思想，我们可以在每次寻找祖先的过程中，更新整个路径上的所有祖先，从而大大减少后续的查找祖先的时间。 具体实现见题解 2。 题解 2（最优解）结果截图 C++ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static int fast = []() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); return 0;}();class Solution {public: int parent1, parent2; vector&lt;int&gt; doubleSourceEdge1, doubleSourceEdge2; vector&lt;int&gt; findRedundantDirectedConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) { int size = edges.size(); int *father = new int[size + 1]; doubleSourceEdge1 = doubleSourceEdge2 = nullptr; memset(father, 0, (size + 1) * sizeof(int)); // Looking for node which has two sources for (auto &amp;iter : edges) { if (father[iter[1]]) { // found doubleSourceEdge1 = { father[iter[1]], iter[1] }; doubleSourceEdge2 = iter; // break; } father[iter[1]] = iter[0]; } for (int i = 1; i &lt;= size; ++i) father[i] = i; // Looking for an edge which forms a circular path for (auto &amp;iter: edges) { if (doubleSourceEdge2 &amp;&amp; iter == *doubleSourceEdge2) continue; parent1 = findParent(father, iter[0]); parent2 = findParent(father, iter[1]); if (parent1 == parent2) { // found if (doubleSourceEdge1.empty()) return iter; else return doubleSourceEdge1; } father[iter[1]] = iter[0]; } return doubleSourceEdge2; } int findParent(int *&amp;father, int index) { if (index == father[index]) return index; else return father[index] = findParent(father, father[index]); }};","link":"/Leetcode/Leetcode-685-Redundant-Connection-II/"},{"title":"Leetcode 839. Similar String Groups","text":"题目839. Similar String Groups Difficulty: Hard Total Accepted: 4.7K Total Submissions: 14K Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y. For example, &quot;tars&quot; and &quot;rats&quot; are similar (swapping at positions 0 and 2), and &quot;rats&quot; and &quot;arts&quot; are similar, but &quot;star&quot; is not similar to &quot;tars&quot;, &quot;rats&quot;, or &quot;arts&quot;. Together, these form two connected groups by similarity: {&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;} and {&quot;star&quot;}. Notice that &quot;tars&quot; and &quot;arts&quot; are in the same group even though they are not similar. Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list A of strings. Every string in A is an anagram of every other string in A. How many groups are there? Example 1: Input: [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;] Output: 2Note: A.length &lt;= 2000 A[i].length &lt;= 1000 A.length * A[i].length &lt;= 20000 All words in A consist of lowercase letters only. All words in A have the same length and are anagrams of each other. The judging time limit has been increased for this question. 解题报告AC 截图 题目大意对于任意两个字符串，若其中一个能够由另一个字符串通过交换字符串中两个字符的位置来得到，那么就称二者 相似。我们将这种相似关系视作而两个字符串间有一条边连通。如此以来，我们构建了一个由字符串作为节点，以相似关系作为边的无向图。本题的问题就是该无向图中存在几个连通分量。 解题思路此类连通性问题一般可以通过两种方法求解。一种是遍历，即是通过 深度优先搜索 或者 广度优先搜索 来发现每一个连通分量。另一种是通过 并查集 来构建连通分量。在这里，我们首先考虑通过遍历求解（我们选取的是深度优先搜索），但是很不幸…… 超时题解结果截图 C++ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();int group[2000];class Solution {public: int size; // string size int numSimilarGroups(vector&lt;string&gt;&amp; A) { if (A.empty()) return 0; size = A[0].size(); return traverseMethod(A); } int traverseMethod(vector&lt;string&gt;&amp; A) { unordered_set&lt;string&gt; unvisitedStrings(A.begin(), A.end()); queue&lt;string&gt; toVisit; int result = 0; while (!unvisitedStrings.empty()) { // Push the first string into the queue // ++result; toVisit.push(*unvisitedStrings.begin()); unvisitedStrings.erase(unvisitedStrings.begin()); // Find the connected component // while (!toVisit.empty()) { // Get the front string // string toTest(toVisit.front()); toVisit.pop(); // Traverse all possible results from toVisit.front() // for (int i = 0; i &lt; size; ++i) { for (int t = i + 1; t &lt; size; ++t) { if (toTest[i] != toTest[t]) { swap(toTest[i], toTest[t]); if (unvisitedStrings.count(toTest)) { toVisit.push(toTest); unvisitedStrings.erase(toTest); if (unvisitedStrings.empty()) return result; } swap(toTest[i], toTest[t]); } } } } } return result; }}; 结果分析遍历算法虽然简单，但是其时间复杂度非常高。以上面的实现为例，其时间复杂度高达 O(size * size * length * log(length))，对于像结果截图中那样超长的字符串显然就无能为力地超时了。因而我们考虑使用并查集方法： 题解1结果截图 C++ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();int group[2000];class Solution {public: int size; // string size int length; // vector length int numSimilarGroups(vector&lt;string&gt;&amp; A) { if (A.empty()) return 0; size = A[0].size(); length = A.size(); return unionFindingMethod(A); } int findGroup(int index) { if (group[index] == index) return index; return group[index] = findGroup(group[index]); } bool isSimilar(const string&amp; str1, const string&amp; str2) { int different = 0; for (int i = 0; i &lt; size; ++i) { if (str1[i] != str2[i]) { if (different &gt; 1) return false; ++different; } } return true; } int unionFindingMethod(vector&lt;string&gt;&amp; A) { int result = 0; length = A.size(); // int groupI, groupT; // Initially, each node belongs to its own group // for (int i = 0; i &lt; length; ++i) group[i] = i; for (int i = 0; i &lt; length; ++i) { for (int t = i + 1; t &lt; length; ++t) { // groupI = findGroup(i); // groupT = findGroup(t); if (isSimilar(A[i], A[t])) { group[findGroup(i)] = findGroup(t); } } } for (int i = 0; i &lt; length; ++i) result += (group[i] == i); return result; }}; 结果分析虽然并查集方法在规定的时间内成功通过了所有的测试样例，但是通过分析我们发现，其时间复杂度实际上是 O(length * length * size)，因而相对于遍历方法，并查集方法更适合于较大 size 的情景。注意到题目中的 Note，我们知道 size * length &lt;= 20000，因而对于较大的 size，其 length 则会较小，所以我们可以通过判断 size 的大小来决定使用哪种方法进行我们的查找。 题解2（最优解）结果截图 C++ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();int group[2000];class Solution {public: int size; // string size int length; // vector length int numSimilarGroups(vector&lt;string&gt;&amp; A) { if (A.empty()) return 0; size = A[0].size(); length = A.size(); if (size &lt; 20) return traverseMethod(A); else return unionFindingMethod(A); } int findGroup(int index) { if (group[index] == index) return index; return group[index] = findGroup(group[index]); } bool isSimilar(const string&amp; str1, const string&amp; str2) { int different = 0; for (int i = 0; i &lt; size; ++i) { if (str1[i] != str2[i]) { if (different &gt; 1) return false; ++different; } } return true; } int unionFindingMethod(vector&lt;string&gt;&amp; A) { int result = 0; length = A.size(); // int groupI, groupT; // Initially, each node belongs to its own group // for (int i = 0; i &lt; length; ++i) group[i] = i; for (int i = 0; i &lt; length; ++i) { for (int t = i + 1; t &lt; length; ++t) { // groupI = findGroup(i); // groupT = findGroup(t); if (isSimilar(A[i], A[t])) { group[findGroup(i)] = findGroup(t); } } } for (int i = 0; i &lt; length; ++i) result += (group[i] == i); return result; } int traverseMethod(vector&lt;string&gt;&amp; A) { unordered_set&lt;string&gt; unvisitedStrings(A.begin(), A.end()); queue&lt;string&gt; toVisit; int result = 0; while (!unvisitedStrings.empty()) { // Push the first string into the queue // ++result; toVisit.push(*unvisitedStrings.begin()); unvisitedStrings.erase(unvisitedStrings.begin()); // Find the connected component // while (!toVisit.empty()) { // Get the front string // string toTest(toVisit.front()); toVisit.pop(); // Traverse all possible results from toVisit.front() // for (int i = 0; i &lt; size; ++i) { for (int t = i + 1; t &lt; size; ++t) { if (toTest[i] != toTest[t]) { swap(toTest[i], toTest[t]); if (unvisitedStrings.count(toTest)) { toVisit.push(toTest); unvisitedStrings.erase(toTest); if (unvisitedStrings.empty()) return result; } swap(toTest[i], toTest[t]); } } } } } return result; }}; 结果分析虽然我们对于 size 的判断一定程度上确定了 length 的大小，但是我们不能忽略 size 和 length 都较小的情况。因而我们加入对 length 的判断，从而超越了原本的最优解： Even Better结果截图 C++ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104static const auto runfirst = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;}();int group[2000];class Solution {public: int size; // string size int length; // vector length int numSimilarGroups(vector&lt;string&gt;&amp; A) { if (A.empty()) return 0; size = A[0].size(); length = A.size(); if (size &gt; 19 || length &lt; 50) return unionFindingMethod(A); else return traverseMethod(A); } int findGroup(int index) { if (group[index] == index) return index; return group[index] = findGroup(group[index]); } bool isSimilar(const string&amp; str1, const string&amp; str2) { int different = 0; for (int i = 0; i &lt; size; ++i) { if (str1[i] != str2[i]) { if (different &gt; 1) return false; ++different; } } return true; } int unionFindingMethod(vector&lt;string&gt;&amp; A) { int result = 0; length = A.size(); // Initially, each node belongs to its own group // for (int i = 0; i &lt; length; ++i) group[i] = i; for (int i = 0; i &lt; length; ++i) { for (int t = i + 1; t &lt; length; ++t) { if (isSimilar(A[i], A[t])) { group[findGroup(t)] = findGroup(i); } } } for (int i = 0; i &lt; length; ++i) result += (group[i] == i); return result; } int traverseMethod(vector&lt;string&gt;&amp; A) { // Time complexity: O(size * size * length * log(length)) unordered_set&lt;string&gt; unvisitedStrings(A.begin(), A.end()); queue&lt;string&gt; toVisit; int result = 0; while (!unvisitedStrings.empty()) { // Push the first string into the queue // ++result; toVisit.push(*unvisitedStrings.begin()); unvisitedStrings.erase(unvisitedStrings.begin()); // Find the connected component // while (!toVisit.empty()) { // Get the front string // string toTest(toVisit.front()); toVisit.pop(); // Traverse all possible results from toVisit.front() // for (int i = 0; i &lt; size; ++i) { for (int t = i + 1; t &lt; size; ++t) { if (toTest[i] != toTest[t]) { swap(toTest[i], toTest[t]); if (unvisitedStrings.count(toTest)) { toVisit.push(toTest); unvisitedStrings.erase(toTest); if (unvisitedStrings.empty()) return result; } swap(toTest[i], toTest[t]); } } } } } return result; }};","link":"/Leetcode/Leetcode-839-Similar-String-Groups/"},{"title":"Service Computing 01 - Private Cloud Service","text":"由于作者水平有限，内容可能存在错漏，若有发现，还望您在评论区指出。 本博客内容仅适用于 VMWare Workstation，Virtual Box 上的操作可能有所不同。 使用 VMWare Workstation 让 PC 提供云桌面服务 1. 当我们搭建云桌面服务的时候，我们到底在做什么？ 2. 从安装虚拟机开始 2.1. 恼人的网卡 2.2. 关于 yum 源 2.3. 关于复制虚拟机 2.4. 关于虚拟机环境配置 2.5. 远程桌面 配置 CentOS 的图形化桌面 配置 Xrdp 远程桌面环境 1. 当我们搭建云桌面服务的时候，我们到底在做什么？桌面云这个东西相信大家都不陌生，比较诸如阿里、腾讯，亦或是 Vultr，都在提供类似的服务（VPS）。对于使用者而言，我们就是拿到了一个 IP 地址，一个账号，一个密码，然后就可以通过各种方式远程控制一台电脑了。我们这次的作业就是要实现一个类似的东西。 那么，我们是不是只需要安装一个 Linux 虚拟机，然后令其访问公网就好了呢？可是为什么这次的操作指南如此冗长呢？ 答案当然是“不是”了。作为一个云服务的提供商，我们要做的不仅仅是让虚拟机能被外部网络访问。为了方便管理所有的 VPS 实例（也就是每个虚拟机），我们需要建立一个子网来连接所有的虚拟机。用图来说会比较直观： 对于非 VPS 的云桌面来说，每一个系统都是真正独立的计算机，因而其架构图如上。每个计算机直接与 Internet 相连（有些服务商可能是通过端口映射和 Internet 相连），同时，每台计算机与一台路由或者交换机相连，构建一个局域网，方便服务商的管理。 而对于 VPS 的桌面云系统来说，其架构图如下： 每个服务器中存在有多个虚拟系统，如此将一台服务器分割成多个虚拟专享服务器，来充分分割细化服务器资源。每个虚拟机通过桥接模式参与到 Internet 连接中，再通过仅主机模式构成一个子网。同时服务器之间通过连接路由器/交换机构成子网，虚拟机通过端口映射连入其中，方便服务提供商管理。 那么我们这次作业想要搭建的是怎样的呢？ 我们为主机创建了两张虚拟网卡，它们分别构建了一个子网络。其中 NAT 模式的虚拟网卡使得子网内的所有虚拟机可以共享主机的物理网络，而仅主机模式的虚拟网卡则仅作为局域网的 DHCP 服务器使用。 2. 从安装虚拟机开始推荐从各个大学的 FTP 站点下载光盘映像文件，可以享受校园网的超高带宽。推荐您下载 CentOS7，其自带的浙江大学源能让你的 yum 也享受到校园网内联的舒爽。 关于 CPU 之类的设置看老师的指南就好，下面来说说网卡的配置。 2.1. 恼人的网卡在前面一节我们说了我们要为 主机 创建两张虚拟网卡，不过在 VMWare 中，这两张网卡实际上已经创建好了，你可以在 编辑-&gt;虚拟网络编辑器 中找到他们。其中，仅主机模式的是 VMnet1，NAT 模式的是 VMnet8。剩下的工作，就是为 虚拟机 创建两张网卡，来分别连接到这两个虚拟网络适配器上。 在 虚拟机-&gt;设置 中，我们可以添加虚拟机的设备，选择网络适配器，添加两张网卡。其中一张是 NAT 模式，它会自动地通过 VMnet1 来共享主机的网络连接。另一张，我们选择 仅主机模式，他则会连接到 VMnet8 来接入到这个局域网中。 如此设置完成并安装虚拟机后，进入虚拟机，我们会惊喜地发现——依旧不能上网。冷静一下……这并不是因为你没有进行正确的设置，而是 CentOS7 默认不会启用你为他配置的两张网卡而已。通过如下命令可以启用： 123cd /etc/sysconfig/network-scripts/ls # 查看有哪些网卡，找到你创建的那两张，比如 cfg-ens33vi cfg-ens33 修改 ONBOOT=yes 后，保存并退出。然后执行以下命令重启网络服务即可： 1service network restart 2.2. 关于 yum 源实际上 CentOS7 自带的有浙江大学的镜像源，能够利用高速的教育网来完成 yum 的包安装和更新。不过如果你需要更换源，可以按如下操作： 备份/etc/yum.repos.d/CentOS-Base.repo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup下载相应的repo文件，然后放入/etc/yum.repos.d/ mv yourfile /etc/yum.repos.d/CentOS-Base.repo重新生成 yum 缓存 yum clean all yum makecache如此即可。 注：如果不清楚工具在哪个 yum 包中，可以使用如下命令查找： yum whatprovides [tool name]2.3. 关于复制虚拟机云服务的提供商通常不会止步于单个系统，那么如何批量生产这些满足要求的系统就是个问题了。复制虚拟机便是一个不错的方案。在 VMWare Workstation 中，该操作首先会创建一个当前虚拟机的快照（可以理解为当前状态的完整记录），然后用快照生成一个与原虚拟机独立的系统。 在这里 VM 和 VB 都提供了两种不同的复制方式：链接复制 和 完整复制。其中，链接复制的虚拟机虽然和原虚拟机在运行上是独立的，但是仍旧使用原来系统的磁盘空间，而所有对于原虚拟机快照中文件的修改将会被存储在一个“差量磁盘”上。这种方法的好处是省去了创建新虚拟磁盘的时间，使得两个虚拟机共享一套快照文件，节约磁盘空间。坏处是二者不能完全独立，仍旧共用磁盘空间。而后者则是单独开辟虚拟磁盘，并在之上创建虚拟机。 你可以在 虚拟机-&gt;管理-&gt;克隆 中进行相关操作。需要注意的是，虚拟机中网卡的 MAC 地址必须不同（可以在虚拟机的设置中重新生成），而 IP 地址则无需担心，因为我们配置的主机虚拟网卡均配置了 DHCP 服务，子网中的设备会自动获得不冲突的 IP 地址。 2.4. 关于虚拟机环境配置 VMWare Tools 和 VB 的增强套件差不多的东西，开启虚拟机后在 虚拟机-&gt;安装VMWare Tools 处安装即可。 Kernel Headers 其实是内核的头文件。部分开发软件（CUDA，PSXE）会需要。直接 yum install kernel-devel即可安装 远程连接（ssh） CentOS 7 原生支持 ssh，只需要在客户机上面使用命令 ssh username@ipadderss 即可连接到虚拟机的终端。 但是这里引入了一个问题：虽然虚拟机可以访问外网，但是外部网络如何访问虚拟机呢？ 进入 编辑-&gt;虚拟网络编辑器，在虚拟机中使用 ifconfig 找到虚拟机的 ip 地址（NAT 模式网卡的）。然后在主机的 NAT 模式的虚拟网卡下为虚拟机的地址设置一个端口映射即可。然后我们就可以通过 ssh username@hostip:setport访问到虚拟机了。 2.5. 远程桌面我们之前完成了 ssh 的配置，可以让外部用户通过这个工具方便地连接到 Linux 终端。但是 CLI 毕竟是极客们的狂欢，我们还得为普通用户准备一个 GUI 的方案…… 配置 CentOS 的图形化桌面安装图形化桌面组件（如果没有在系统安装时就加载的话）： yum groupinstall &quot;GNOME Desktop&quot;设置图形化组建为启动目标 ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target重新启动 shutdown -r now你可以看到我们的 CentOS 已经具有了图形化界面。 配置 Xrdp 远程桌面环境Windows 自带的远程桌面使用的是 rdp 协议，而 Linux 中需要通过额外的组件 Xrdp 来支持这种协议的远程桌面。首先，我们需要配置 EPEL 源，这是对于 CentOS 原生 yum 源的补充。 首先： yum search epel结果里会有 epel-release-latest.noarch安装 EPEL 源 yum install -y epel-release-latest.noarch然后就可以安装 Xrdp 组件啦： yum install xrdp tigervnc-server安装完成之后，该服务默认并为启动，我们启动它，并且为他添加开机启动 systemctl start xrdp systemctl enable xrdp之后，我们可以看看现在系统的端口调用： netstat -antup | grep xrdp不出意外的话，你应该能看到： tcp 0 0 0.0.0.0:3389 0.0.0.0:* LISTEN 1508/xrdp tcp 0 0 127.0.0.1:3350 0.0.0.0:* LISTEN 1507/xrdp-sesman3389 端口就是 Xrdp 用来监听 rdp 请求的端口。不过为了让 rdp 正常使用，我们还需要配置防火墙（控制网络入口）和 SELinux（控制程序访问权限）： firewall-cmd --permanent --add-port=3389/tcp firewall-cmd --reload chcon --type=bin_t /usr/sbin/xrdp chcon --type=bin_t /usr/sbin/xrdp-sesman配置到此全部完成，试试用 Windows 自带的远程桌面连接虚拟机吧～初始化耗时可能较久，请耐心等待哦～","link":"/Service-Computing/Service-Computing-01-Private-Cloud-Service/"},{"title":"Get Started with Unity3D - 4","text":"Escape with Unity-Chan!Github仓库 B站视频 和 Unity 酱一起逃出生天！ Unity 酱来到了一座美丽的森林，但是好像森林里并不只有她一人……WASD 控制方向 + 右键控制视角来躲避追逐而来的敌人，带着 Unity 酱逃出森林吧（并不能）！ 先来看几张预览图吧！ 游戏设计目标 创建一个地图和若干巡逻兵 \b每个巡逻兵走一个3~5个边的凸多边型，位置数据是相对地址。即每次确定下一个目标位置，用自己当前位置为原点计算 巡逻兵碰撞到障碍物，则会自动选下一个点为目标 巡逻兵在设定范围内感知到玩家，会自动追击玩家 失去玩家目标后，继续巡逻 计分：玩家每次甩掉一个巡逻兵计一分，与巡逻兵碰撞游戏结束 在此基础上我们做了一些小的改变： 第二点中，由于多数同学实现的是一个矩阵分割的地图，而我们制作的是一个开放式的森林地图，巡逻兵不适宜用固定的图形作为巡逻路径。因此，我们采用完全随机的模式来决定巡逻兵的移动路径。 第六点中，因为我们巡逻兵使用的是随机速度，我们想把它体现在分数上。因而每甩掉一个巡逻兵会增加相当于巡逻兵移动速度的分数。 程序设计要求 必须使用订阅与发布模式传消息 Subject：OnLostGoal Publisher：Monster Subscriber：ScoreRecorder 工厂模式生产巡逻兵 操作方法 WASD 控制 Unity 酱前后移动（向后移动速度较慢）和左右旋转 按住右键可以通过鼠标自由旋转视角 设计模式那点事本次我们要求使用两种设计模式：发布-订阅模式和工厂模式（其实还有导演场记和单例模式），其中后者我们已经在之前的作业中领略不少，便不在此赘述了。重点来说说发布-订阅模式，这也是我觉得目前最好用的模式之一。 订阅-发布模式如果你用过 Qt，你一定听说过信号-槽。如果你用过 JavaScript，那你一定对事件不陌生。而如果你用过 UWP，那么这个就完全对你来说不陌生了！是的，订阅-发布的本质就是提供了一种可异步的，去耦合的对象间交互模式。简单来说，发布者会发布信息（Qt 中的信号，JavaScript 中的事件），然后所有的订阅者都会收到信息并对其进行相应的处理（Qt 中的槽函数，JavaScript 中的事件处理函数）。 单是这么说可能还是有些抽象。对于咱们程序员来说，最直观的方式莫过于上代码啦～以下便是一个简单的订阅-发布模式实现： 1234567891011121314151617181920212223242526272829public class Publisher { public static delegate returnType Message(Type Content); // 此处声明了委托（发布-订阅关系）的类型（或者说订阅函数的范式、签名） // 使用此类型的委托的返回类型都是 returnType，参数都是一个 Type public static event Message MessageSent; // 使用 Message 类型创建一个委托，或者说一个发布-订阅关系 /* * ... */ var HandledMessage = MessageSent(Some Messages); // 此处发布了信息，内容是 Some Messages，这会通知所有订阅者对其进行处理 // 并且用 HandledMessage 来接收处理函数的返回值（可能是多个） /* * ... */}public class Subcriber { Subcriber() { Publisher.MessageSent += MessageHandler; // 此处表示订阅 MessageSent 信息，并且用 MessageHandler 作为处理函数 } public returnType MessageHandler(Type content) { /* Do something with the content */ }} 资源库中从不缺乏惊喜Assets Store 可以说是 Unity 小型开发中极为核心的一环，他就好比安卓的 Google Play（应用市场），或者是 IOS 的 App Store。如果把一个 Unity 程序比做一个人。那么引擎就是它的骨架，代码就是他的灵魂，而 Assets 则是它的血肉。没有他，我们的灵魂再怎么深邃，也会缺乏最直观的美感。那么来看看我们在那里面都发现了些什么吧！ Unity-Chan 作为一款免费的模型，Unity-Chan 可以说是做到了很多收费模型都做不到的程度。它有精细的贴图，恰到好处的设计，丰富的动作，以及\b完全开源的组件。有了它，你的游戏瞬间就会变得丰富多彩了～ Fantasy Monster 作为免费模型，Fantasy Monster也是相当良心的一款了。完备的动画、多样的造型，甚至还有攻击特效～一站式备齐你所要的一切（Monster）～ Nature Starter Kit 2 你还在为地形设计抓耳挠腮吗？你苦苦羡慕别人的光影效果吗？试试 Nature Starter Kit 2，让你的项目从此高端大气上（烧）档（显）次（卡）！体验不一样的 Unity 从此开始！ 代码即是灵魂扯了这么多，代码才是一个项目核心中的核心，下面便是这个项目中的主要代码～其中的 Animator 相关代码需要在 Unity 的预设中首先创建好 AnimationController，至于究竟如何，就交由各位自行探索啦～ GameDirector.cs 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;public class GameDirector : System.Object{ private static GameDirector _instance; public SceneController currentSceneController { get; set; } public static GameDirector getInstance() { if (_instance == null) { _instance = new GameDirector(); } return _instance; } public int getFPS() { return Application.targetFrameRate; } public void setFPS(int fps) { Application.targetFrameRate = fps; }} SceneController.cs 12345678using System.Collections;using System.Collections.Generic;using UnityEngine;public interface SceneController{ void LoadResources();} FirstController.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System.Collections;using System.Collections.Generic;using UnityEngine;public class FirstController : MonoBehaviour, SceneController{ public GameObject player; public GameObject mycamera; public List&lt;GameObject&gt; monsters; public MyFactory mF; private bool isGameOver = false; public bool isStart = false; void Awake() { mycamera = (GameObject)Resources.Load(\"Prefabs/CameraContainer\"); player = (GameObject)Resources.Load(\"Prefabs/Character\"); GameDirector director = GameDirector.getInstance(); director.currentSceneController = this; } void Start() { mF = Singleton&lt;MyFactory&gt;.Instance;//获得工厂单例 monsters = mF.getMonsters();//从工厂获得所有的怪物 MonsterController.hitPlayerEvent += gameOver;//订阅怪物撞击玩家的事件 player = Instantiate(player); player.transform.position = new Vector3(-53, 1.1F, 60); mycamera = Instantiate(mycamera); } public bool getGameOver() { return isGameOver; } public void gameOver() { player.GetComponent&lt;Animator&gt;().SetTrigger(\"Lose\"); this.isGameOver = true; } public void start() { Singleton&lt;ScoreRecorder&gt;.Instance.reset(); mF.Reput(); isStart = true; } public void LoadResources() { // }} MyFactory.cs 12345678910111213141516171819202122232425262728293031323334353637383940using System.Collections;using System.Collections.Generic;using UnityEngine;public class MyFactory : MonoBehaviour { public GameObject monster; private List&lt;GameObject&gt; _monsters; private int min_x = -80; private int max_x = 80; private int min_z = -80; private int max_z = 80; public void Awake() { monster = (GameObject)Resources.Load(\"Prefabs/Monster\"); } public List&lt;GameObject&gt; getMonsters() { List&lt;GameObject&gt; Monsters = new List&lt;GameObject&gt; (); for (int i = 0; i &lt; 9; ++i) { GameObject newMonster = Instantiate&lt;GameObject&gt;(monster); newMonster.transform.position = new Vector3(500, 2, 500); // 流放 Monsters.Add(newMonster); } _monsters = Monsters; return Monsters; } public void Reput() { foreach (var amonster in _monsters) { amonster.transform.position = new Vector3(Random.Range(min_x, max_x), 2, Random.Range(min_z, max_z)); monster.GetComponent&lt;MonsterController&gt;().GetNewPosition(); } }} MonsterController.cs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889using System.Collections;using System.Collections.Generic;using UnityEngine;public class MonsterController : MonoBehaviour { private Vector3 NextPosition; private int speed; private CharacterController cc; private Animator anim; FirstController fc; public delegate void hitPlayer (); public delegate void playerLost (int score); public static event hitPlayer hitPlayerEvent; public static event playerLost playerLostEvent; // Use this for initialization void Start () { NextPosition = transform.position; cc = GetComponent&lt;CharacterController&gt;(); anim = GetComponent&lt;Animator&gt;(); speed = (int)Random.Range(3, 11); fc = GameDirector.getInstance().currentSceneController as FirstController; } // Update is called once per frame void FixedUpdate () { if (fc.getGameOver()) return; var diff = NextPosition - transform.position + Vector3.up * transform.position.y; while (diff.magnitude &lt; 0.1) { GetNewPosition(); diff = NextPosition - transform.position + Vector3.up * transform.position.y; } transform.LookAt(transform.position + diff); if (diff.magnitude &gt; speed) cc.SimpleMove(diff / diff.magnitude * speed); else cc.SimpleMove(diff); } public void GetNewPosition() { NextPosition = new Vector3(transform.position.x + Random.Range(-50, 50), 0, transform.position.z + Random.Range(-50, 50)); } void OnTriggerStay(Collider other) { if (fc.getGameOver()) return; if (other.gameObject.tag == \"Player\") { NextPosition = new Vector3(other.gameObject.transform.position.x, 0, other.gameObject.transform.position.z); } } void OnControllerColliderHit(ControllerColliderHit hit) { if (fc.getGameOver()) return; if (hit == null) return; if (hit.gameObject.tag == \"Player\") { anim.SetTrigger(\"Attack\"); hitPlayerEvent(); } else if (hit.gameObject.tag == \"Trees\") { GetNewPosition(); } } private void OnTriggerExit(Collider other) { if (fc.getGameOver()) return; if (other.gameObject.tag == \"Player\") { playerLostEvent(speed); GetNewPosition(); } }} PlayerController.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerController : MonoBehaviour { CharacterController cc; Animator anim; FirstController fc; private void Awake() { cc = GetComponent&lt;CharacterController&gt;(); anim = GetComponent&lt;Animator&gt;(); fc = GameDirector.getInstance().currentSceneController as FirstController; } // Use this for initialization void Start () { } // Update is called once per frame void FixedUpdate () { if (fc.getGameOver()) return; float h = Input.GetAxis(\"Horizontal\"); float v = Input.GetAxis(\"Vertical\"); if (v &gt; 0.1) { anim.SetBool(\"WalkingBack\", false); anim.SetBool(\"Run\", true); transform.Rotate(0, h * 4, 0); cc.SimpleMove(transform.forward * 10 * v); } else if (v &lt; -0.1) { anim.SetBool(\"WalkingBack\", true); anim.SetBool(\"Run\", false); transform.Rotate(0, h * 4, 0); cc.SimpleMove(transform.forward * v * 3); } else { transform.Rotate(0, h * 4, 0); anim.SetBool(\"Run\", false); anim.SetBool(\"WalkingBack\", false); } }} ScoreRecorder.cs 123456789101112131415161718192021222324252627using System.Collections;using System.Collections.Generic;using UnityEngine;public class ScoreRecorder : MonoBehaviour { private int _score = 0; public void Start() { MonsterController.playerLostEvent += Score; } public void Score(int score) { _score += score; } public int GetScore() { return _score; } public void reset() { _score = 0; }} UserGUI.cs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class UserGUI : MonoBehaviour{ private bool isGameOver = false; public string scoreText; public string gameOverText; public ScoreRecorder sR; FirstController fc; void Start() { fc = GameDirector.getInstance().currentSceneController as FirstController; sR = Singleton&lt;ScoreRecorder&gt;.Instance; scoreText = \"Score: 0\"; gameOverText = \"Playing...\"; } void Update() { if (isGameOver) {//显示结束游戏 gameOverText = \"Game Over!\"; return; } else { gameOverText = \"Playing...\"; isGameOver = fc.getGameOver();//检查游戏是否结束 scoreText = \"Score: \" + sR.GetScore();//显示分数 return; } } void OnGUI() { if (fc.isStart) { GUI.Label(new Rect(10, 10, 100, 30), gameOverText); GUI.Label(new Rect(10, 50, 100, 30), scoreText); } else { if (GUI.Button(new Rect(10, 10, 100, 30), \"Start\")) { fc.start(); } } }} MyCameraController.cs 1234567891011121314151617181920212223242526272829303132using CameraController;using System.Collections;using System.Collections.Generic;using UnityEngine;public class MyCameraController : MonoBehaviour { Transform Character; public float smoothTime = 0.01f; private Vector3 AVelocity = Vector3.zero; Vector3 oldPosition, newPosition; // Use this for initialization void Start () { Character = (GameDirector.getInstance().currentSceneController as FirstController).player.transform; oldPosition = newPosition = Vector3.zero; } // Update is called once per frame void Update () { transform.position = Vector3.SmoothDamp(transform.position, Character.position, ref AVelocity, smoothTime); newPosition = Input.mousePosition; if (Input.GetMouseButton((int)MouseButtonDown.MBD_RIGHT)) { transform.Rotate(0, (newPosition - oldPosition).x, 0); } else { transform.rotation = Character.rotation; } oldPosition = newPosition; }} 特别鸣谢 陈旭东大神的 blog 旭东大神的指导博客～详尽易懂，也让我知道原来 Unity 的世界可以如此精彩！ Unity-Chan制作团队官网 本作主角模型的制作团队，没有他们的努力和开源精神就不会有活力四射的 Unity 酱。 Nature Starter Kit 2 一款非常优秀的场景包，同时兼有相当华丽的镜头滤镜脚本，是免费玩家的不二之选。","link":"/Unity3D/Get-Started-with-Unity3D-4/"},{"title":"从零开始的随机森林（2）：决策树","text":"Attention: This blog is a reading note of Tree - Decision Tree with sklearn source code in Chinese, which is written in English. As missing or misunderstanding might be included, please reference the original text if needed. We believe that the original text containing some misunderstandings on information theory itself, and we correct it in our version. 在上一篇博客中，我们介绍了有关信息论的原理和一些直观的理解，这是构建决策树（Decision Tree）算法的基础。在本篇中，我们将介绍分类决策树和回归决策树，以及在 Scikit-learn 开源库中其对应的实现。由于 sk-learn 使用 CART 算法构建决策树，我们也将主要聚焦于这个算法，同时会提及另外两种常用算法：ID3 和 C4.5 算法的原理和优劣。 构建决策树开始之前，我们稍微回顾一下决策树的定义。决策树是一种树形结构，其中每个内部节点表示一个属性上的测试，每个分支代表一个测试输出，每个叶节点代表一种类别。在实际运行中，一组数据自决策树根结点出发，在每个内部节点通过测试后，最后归结到相应的叶节点，从而被判定为叶节点的类别，或者被赋予叶节点的常数值（回归树）。对于一颗理想的决策树，其叶节点应只包含一种类别的数据（分类树）或者一个常数值（回归树）。尽管我们通常不能（也不会）达到理想状态，但这是我们训练模型的方向。训练过程的本质是通过节点数据的分裂，使得子节点中同类数据（分类树）或同值（或近似值）数据（回归树）的比例增加，这也就是我们在前一篇中所说的“纯度增加”。最终在叶子节点中（由于不是理想树，其中样本仍可能由不同值和不同类构成），取样本最多的类（分类树）或平均值（回归树）为所有节点内样本的预测值。 分裂标准（Criterion）在前面我们讲到了如何使用一个构建好的决策树进行预测，为了构建一颗决策树，我们需要解决的一个核心问题是：怎么样决定每个节点的数据如何被分到数个子节点上呢？ 对于分类树而言，我们需要回忆一下前一篇所提到的熵的概念。在决策树中，我们希望通过分裂节点来“纯化”数据，最小化数据的“不纯度”（其实就是熵）。在前一篇，我们通过“信息增益”来衡量引入一个新的随机变量（此处为基于数据的特征的分裂）所确定（即纯化）的信息量。由于在信息增益公式 $IG=H(Y)-H(Y,X)$ 中，$H(Y)$ 是一个不变量，所以 Ross 教授在 1986 年提出的经典算法：ID3，在决策树中实际上使用的是交叉熵 $H(Y,X)$ 来衡量引入一个（基于特征 $X$ 的）分裂所带来的数据纯化效果，其中对字段概率 $p$ 的估计为： $$\\hat{p}_{k}=\\frac{1}{N}\\sum I(y_i=k)$$ 即节点中类 k 数据的比例，N 为节点内数据总量。在每个分裂子问题中，我们的目标就是找到： $$\\underset{X}{argmax}(IG(Y, X))=\\underset{X}{argmin}(H(Y,X))$$ 这个公式也隐式地指出了，ID3 的分支数量由 $X$ 的可能取值数量决定。而这可能导致 ID3 会优先选择分支较多的特征，而这种特征有可能是实际上无意义的（比如用户 ID，其信息增益最大并非因为其和分类在意义上相关，仅仅只是分支众多）。为了避免这种情况，Ross 又在 1993 年提出了 C4.5 算法。 C4.5 算法是对 ID3 的改进，其引入了一个新的标准：信息增益比率（Gain Ratio），这个标准通过分裂信息（Split Information）来惩罚拥有过多分支的项的得分，来达到权衡分支数量和纯化效果的效果： $$SplitInformation(Y, A) = -\\sum_{i=1}^{n_A}\\frac{Y_i}{Y}log\\frac{Y_i}{Y}$$ $$GainRatio=\\frac{IG(Y, X)}{SplitInformation(Y, A)}$$ 其中，$n_A$ 是 A 的可能取值数量，$Y_i$ 是第 i 个分支内的样本数。这样一来，当分支数量过大时，由于 $SplitInformation$ 的增加，尽管 $IG(Y, X)$ 会增长，但是最终评判标准 $GainRatio$ 却可能降低，从而实现了对于过大数目分支的抑制。虽然 C4.5 解决了分支数量问题，但是大大增加了计算复杂度，导致算法运行缓慢。作为修正，在 1984 年，L.Breiman 等人提出了 CART 算法。 相比于 ID3 或者 C4.5，CART 的两个重要改进分别是该用基尼（Gini）系数作为评判标准，以及只构建二叉决策树。其中，一个节点的基尼系数的定义如下： $$Gini(Y)=\\sum_{i=1}^{n}\\frac{Y_i}{Y}（1-\\frac{Y_i}{Y}）$$ 取 $n=2$，并通过选取特征（划分方法）使得基尼系数增益（即父节点和子节点的基尼系数之差）最大，并如此迭代到算法终止条件，可得 CART 二叉决策树。在该算法中，基尼系数实际上是对于交叉熵的一种拟合。在二分类问题下，他们之间的误差如下图： 上面我们均在讨论决策树用于分类问题的情况，但决策树实际上也可用于回归问题，此时我们又称其为回归树。回归树与分类树最大的区别在于其评判标准。需要注意的是，我们不能单纯地使用交叉熵或者基尼系数的连续形式来评判连续量从而实现回归树，因为他们需要我们对于信息分布具有完全的了解，而在实际问题中，我们实际获得的信息只有连续量的离散取值而已。因为上面诸多限制，CART 算法引入了 方差减益（Variance Reduction） 来作为回归树的分裂标准。直观地讲，其通过计算子节点和根节点的均方差（但实际上没有用到均值差平方和）来衡量一个分裂的好坏。因为我们的回归树的理想目标是使得每个节点的信息纯度最大，方差越小的数据拥有越高的纯度。公式为： $$\\begin{aligned}V(S)=\\frac{1}{|S|^2}\\sum_{i\\in S}\\sum_{j\\in S}\\frac12(x_i-x_j)^2\\\\I_V(N) = V(S) - (V(S_L) + V(S_R))\\end{aligned}$$ 其中 $S,\\ S_L,\\ S_R$ 分别为当前节点、左子节点、右子节点的样本集合。该算法有较高的计算时间复杂度。 Sk-learn 源码中的 Criterion在 Sk-learn 中，对于分类决策树，开发者们实现了基尼系数和交叉熵两种方法，而对于回归树，开发者们则选择了 平均平方误差，又称 均方差（Mean Square Error, MSE），来作为评判标准（以此减少计算的时间复杂度）。均方差公式如下： $$\\frac 1{|S|}(\\sum_{i\\in S_L}(y_i-\\overline y_L)^2+\\sum_{i\\in S_R}(y_i - \\overline y_R)^2)$$ 同样处于时间复杂度的考虑，Sk-learn 将上面的公式进一步简化： $$\\frac 1{|S|}\\sum(y_i-\\overline y)^2 \\approx \\frac{\\sum y^2}{|S|}-\\overline y^2$$ 最终呈现在代码上，是如下的两个片段： 123456789101112131415161718192021222324# ./sklearn/tree/_criterion.pyx# @Lines: 765-777# In class: RegressionCriterionfor p in range(start, end): i = samples[p] if sample_weight != NULL: w = sample_weight[i] for k in range(self.n_outputs): y_ik = self.y[i, k] w_y_ik = w * y_ik self.sum_total[k] += w_y_ik self.sq_sum_total += w_y_ik * y_ik self.weighted_n_node_samples += w# @Lines: 893-895# In class: MSEimpurity = self.sq_sum_total / self.weighted_n_node_samplesfor k in range(self.n_outputs): impurity -= (sum_total[k] / self.weighted_n_node_samples)**2.0 除开算法之外，Sk-learn 还通过 Cython 实现并复用样本数组达到了更高的执行效率（减少了解释开销和分配内存开销）。 分裂（Split）按我们前面所述，你可能会发现一个问题：如果我们每次都通过 Criterion 来选择一个最优分裂策略（Sk-learn 称之为 best-splitter），在数据量大的情况下，尤其是在回归树中，可能是一个难以完成甚至无法完成的任务。另一方面，一个最优的分裂策略以为着很大可能的过拟合，","link":"/Machine-Learning/从零开始的随机森林（2）：决策树/"},{"title":"Setup ethereum on your Mac","text":"你适合使用本教程吗？ 环境要求 安装 Geth 我们需要做什么？ 等等，在开始之前…… Step 1: 创建创世区块并初始化区块链 什么是创世区块？ 配置创世区块 初始化区块链 Step 2: 启动区块链！ 服务端，启动！ 建立 Geth JavaScript 客户端 开始挖矿吧！ 区块字段分析 进行交易吧！ Step 3: 部署智能合约并调用 我们的第一个智能合约 在线 Remix 调试 部署智能合约 交易字段分析 Step 4: 多节点的私有链 多节点环境搭建 节点间交易 你适合使用本教程吗？本教程将带领你从零开始在 MacOS 上搭建一个以太坊环境，并且设置一个你自己的私有节点，然后完成挖矿和交易。在它上面，你可以测试你的智能合约代码，或是干任何你想做的事情~在最后，我们也会带领你在上面撰写一个你自己的智能合约，并尝试运行它。 环境要求 运行在 MacOS 上的计算机 配置好的 Homebrew 环境 一些计算机和以太坊的知识 安装 GethGeth 是 ‘Go Ethereum’ 的缩写。顾名思义，他是以太坊节点客户端的 go 语言版本。为了搭建我们的以太坊环境，Geth 使我们需要的第一件东西。 打开你的终端，并且运行以下命令来安装 Geth 123456brew update # update your homebrewbrew tap ethereum/ethereum # switch to the repository repositorybrew install ethereum# install Geth 在 Homebrew 的工作完成后，Geth 就已经被成功安装到你的 Mac 上了。接下来就让我们正式走入以太坊的世界吧！ 我们需要做什么？从搭建一个私有的以太坊节点到运行智能合约，我们需要经过以下几步： 创建创世区块并初始化区块链 启动区块链并尝试挖矿和交易 部署智能合约并调用 那么让我们来一步步配置吧~ 等等，在开始之前……在我们开始配置前，我推荐你为你的节点创建一个文件夹，他将被用于存储以太坊的账号信息和数据库。傻瓜式代码如下： 12345cd ~mkdir ethereumcd ethereummkdir private# We're now in ~/ethereum/ Step 1: 创建创世区块并初始化区块链什么是创世区块？创世区块是一个区块链的第一个区块。同时，创世区块也会初始化节点的行为。 配置创世区块因而要开启一条新的区块链，首先我们需要配置好我们创世区块，新建一个配置文件 genesis.json，并用 vim 打开它： 1touch genesis.json &amp;&amp; vim genesis.json 将以下内容复制进区块，并且按 ESC 后输入 :wq 退出 vim 并保存文件： 1234567891011{ \"config\": { \"chainId\": 143, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"alloc\": {}, \"difficulty\" : \"0x50\", \"gasLimit\" : \"0x8880000\"} 你可能注意到这个 JSON 文件有许多 字段，让我们来一个个解释一下吧： chainId: 用于唯一标识整条区块链的编号 homesteadBlock: 以太坊的早期版本需要的配置值，可留为 0。 eip155Block/eip158Block: EIP 是指 “Ethereum Improvement Proposals”，他们被设计来代替 homesteadBlock 处理硬分叉等事宜，在私有链上我们无需设置，同样设置为 0 即可。 difficulty: 顾名思义，挖矿的初始难度。其的含义是“平均每 difficulty 次 hash 值的尝试就会生成一个有效的区块” gasLimit: 智能合约的消耗上限 alloc: 允许将以太币分配到一个特定的地址 之后，以太坊程序会根据这个文件中的配置信息来确定链上的创世区块。 初始化区块链那么让我们初始化这条区块链吧，在终端中使用以下命令： 1geth --datadir private init genesis.json 你将看到如下输出： INFO [11-01|23:00:31.705] Maximum peer count ETH=25 LES=0 total=25 INFO [11-01|23:00:31.712] Allocated cache and file handles database=/Users/siskon/ethereum/private/geth/chaindata cache=16 handles=16 INFO [11-01|23:00:31.721] Writing custom genesis block INFO [11-01|23:00:31.722] Persisted trie from memory database nodes=0 size=0.00B time=21.494µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [11-01|23:00:31.723] Successfully wrote genesis state database=chaindata hash=248492…15aeed INFO [11-01|23:00:31.723] Allocated cache and file handles database=/Users/siskon/ethereum/private/geth/lightchaindata cache=16 handles=16 INFO [11-01|23:00:31.725] Writing custom genesis block INFO [11-01|23:00:31.725] Persisted trie from memory database nodes=0 size=0.00B time=3.118µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [11-01|23:00:31.725] Successfully wrote genesis state database=lightchaindata hash=248492…15aeed这些信息分别表示：当前允许的最大 peer 数量，分配的缓存和文件处理者（为一个 database），写入自定义的创世区块，从内存数据库中读取持久化的 trie，成功写入了创世区块。 Geth 将在 private 目录下初始化区块链，并且以 genesis.json 作为创世区块的配置文件。之后该区块链产生的所有账号信息以及数据库信息都会被存储在该文件夹中。 Step 2: 启动区块链！服务端，启动！运行以下命令： 1geth --port 3000 --networkid 58343 --nodiscover --datadir=./private --maxpeers=1 --rpc --rpcport 8543 --rpcaddr 127.0.0.1 --rpccorsdomain \"*\" --rpcapi \"eth,net,web3,personal,miner\" 这次也是一堆参数呢~不要慌，让我们一段段来解读： port: 以太坊服务所运行在的网络端口号 networkid: 你的以太坊网络的唯一标识，你可以设置为任意值，但是不能和以太坊的保留值冲突。因而我们建议您在 100 ~ 10000 内随便选一个数比较好~ nodiscover: 隐身！（无法被探查，只能手动添加用户） datadir: 区块链数据存储目录 maxpeers: 最大网络用户数，设为 0 时代表禁用网络。 rpc: 启动 HTTP-RPC 服务器（后面的几个参数都是在配置这个服务器） rpcapi: \b需要使用的 RPC API，你会在稍后看到他们的身影。 如果一切正常，你会看到如下输出： INFO [11-01|23:00:43.170] Maximum peer count ETH=0 LES=0 total=0 INFO [11-01|23:00:43.178] Starting peer-to-peer node instance=Geth/v1.8.14-stable/darwin-amd64/go1.11 INFO [11-01|23:00:43.178] Allocated cache and file handles database=/Users/siskon/ethereum/private/geth/chaindata cache=768 handles=128 INFO [11-01|23:00:43.190] Initialised chain configuration config=&quot;{ChainID: 143 Homestead: 0 DAO: &lt;nil&gt; DAOSupport: false EIP150: &lt;nil&gt; EIP155: 0 EIP158: 0 Byzantium: &lt;nil&gt; Constantinople: &lt;nil&gt; Engine: unknown}&quot; INFO [11-01|23:00:43.190] Disk storage enabled for ethash caches dir=/Users/siskon/ethereum/private/geth/ethash count=3 INFO [11-01|23:00:43.190] Disk storage enabled for ethash DAGs dir=/Users/siskon/.ethash count=2 INFO [11-01|23:00:43.190] Initialising Ethereum protocol versions=&quot;[63 62]&quot; network=58343 INFO [11-01|23:00:43.190] Loaded most recent local header number=0 hash=248492…15aeed td=80 INFO [11-01|23:00:43.190] Loaded most recent local full block number=0 hash=248492…15aeed td=80 INFO [11-01|23:00:43.190] Loaded most recent local fast block number=0 hash=248492…15aeed td=80 INFO [11-01|23:00:43.192] Regenerated local transaction journal transactions=0 accounts=0 INFO [11-01|23:00:43.193] Starting P2P networking INFO [11-01|23:00:43.195] RLPx listener up self=&quot;enode://354d42e030694bf418e58ab30bd4afaeb48a7d922e0d61cc81b4b1fe1e45e8335ed6fb9fe0611ef7369172e6c8dcda2f4c4646a3676b1cec5d5e8006112166d5@[::]:3000?discport=0&quot; INFO [11-01|23:00:43.198] IPC endpoint opened url=/Users/siskon/ethereum/private/geth.ipc INFO [11-01|23:00:43.199] HTTP endpoint opened url=http://127.0.0.1:8543 cors=* vhosts=localhost这些信息分别表示：当前最大 peer 数量，启动 P2P 节点，分配缓存和文件管理者，初始化链的配置，允许硬盘存储上的缓存和 DAG，初始化以太坊协议，加在最近的头部、全区块、快速区块，重新生成本地交易记录，开启 P2P 网络，RLPx 监听启动，IPC 和 HTTP 启动。 建立 Geth JavaScript 客户端那么到目前为止，我们已经成功地启动了区块链服务，但是我们尚未真正地开始我们的挖矿大业（没有创建客户端，或者说矿工）。那么我们现在就开始吧！因为当前的终端窗口正在执行服务端的进程，所以我们按 Command + N 创建一个新的终端窗口，并在其中运行命令： 1geth attach http://127.0.0.1:8543 通过这个命令，我们建立了一个 Geth JavaScript 客户端，并且连接到了位于 8543 端口的以太坊 RPC-HTTP 服务器，并且启动一个 JavaScript 终端来接收命令。如果一切顺利，那么你会看到输出如下： Welcome to the Geth JavaScript console! instance: Geth/v1.8.14-stable/darwin-amd64/go1.11 modules: eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 web3:1.0 &gt;开始挖矿吧！personal.addAccount(&apos;password&apos;) miner.start()我们首先通过 personal.addAccount(‘password’) 向区块链注册了一个密码为 password 的账号，然后通过调用 miner.start()，我们就开始了挖矿。耐心等待片刻，你就可以看到服务器的状态栏里开始出现挖矿成功的提示了： INFO [11-01|21:47:34.729] Successfully sealed new block number=1 hash=ff0b6d…f94c77 elapsed=47.040s INFO [11-01|21:47:34.734] 🔨 mined potential block number=1 hash=ff0b6d…f94c77如果要查看当前矿工进程挖到的以太币数量，你可以运行： web3.fromWei(eth.getBalance(eth.coinbase), &quot;ether&quot;)而要停止挖矿，则运行： miner.stop()等等！eth.coinbase 是个啥？！因为大多数矿工可能同时拥有多个账号，而只希望将挖到的以太币存储在其中一个账号中，所以 coinbase 应运而生。它作为矿工节点的默认账号而存在，也是你通过 eth.accounts[0] 获取到的账号，同时也是你之前创建的那个账号。如果需要多个账号，继续通过 newAccount 创建即可。 既然挖到了区块，不如看看这个区块长什么样子吧！ 区块字段分析12345678910111213141516171819202122{ difficulty: 131072, extraData: \"0xd78301080e846765746886676f312e31318664617277696e\", gasLimit: 142990849, gasUsed: 0, hash: \"0xa42a8cd5055e1e0769badad4fc07f3b3b018c816c0c19fc0bd2221ea593ee052\", logsBloom: \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", miner: \"0x0eea1b6dda7118e54b2e47763f5a15cec6fd3f59\", mixHash: \"0x415ed9fce5ddae95f2e55aa3855c478076d804f0743b7a9f822dba4afd714b65\", nonce: \"0x7db6abd5e75c529f\", number: 1, parentHash: \"0x248492021566b9fc031421e8ed6d2a1d8d8a78027dd5ff17e6079ea39d15aeed\", receiptsRoot: \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", sha3Uncles: \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", size: 536, stateRoot: \"0x2f810b73ac2c825648eee23e3743fea7e3c397098638845950a5182ea9e01784\", timestamp: 1541084676, totalDifficulty: 131152, transactions: [], transactionsRoot: \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", uncles: []} 逐字段分析如下： difficulty: 当前区块的设定难度 extraData: 区块的额外数据 gasLimit: 区块最多允许使用的 gas 量 gasUsed: 区块中交易使用掉的 gas 量 hash: 区块的哈希值 logsBloom: 当前区块的 bloom filter miner: 挖出该区块的矿工账号 mixHash: 由 nonce 值得出，参与验证 PoW nonce: 用于验证 PoW 的随机值 number: 区块编号 parentHash: 上一个区块的哈希值 receiptsRoot: 当前区块的回执的哈希根值 sha3Uncles: 区块的 uncle 数据的 SHA3 size: 区块大小 stateRoot: 区块的最终状态的哈希根值 timestamp: 时间戳 totalDifficulty: 整个链耗费在当前区块的时间 transactions: 区块所包含的所有交易 transactionsRoot: 所有交易的哈希根值 uncles: uncle 哈希的数组 进行交易吧！为了完成一笔交易，我们得拥有复数的账号才可以。因此我们再创建一个账号： personal.addAccount(&apos;password&apos;)为了完成支付，我们必须先将付款账号（也就是初始的账号）解锁： personal.unlockAccount(eth.accounts[0], &apos;password&apos;)然后，我们就可以申请一笔交易啦： eth.sendTransaction({from: eth.accounts[0], to: eth.accounts[1], value: web3.toWei(10,&quot;ether&quot;)})申请完成后，我们可以得到注意交易需要由矿工来确认，所以如果没在挖矿的话交易是没办法被真的写到链上的。在至少挖到了一个区块后，再查询第二个账户的余额： &gt; web3.fromWei(eth.getBalance(eth.accounts[1]), &quot;ether&quot;) 10已经到账啦~那么我们再根据之前 sendTransaction 方法返回的交易号来查询一下我们的交易吧！ &gt; eth.getTransaction(&quot;0xf11705da1551866649f2bebca1b43516beb9a4908d1af8a3a6887bba4b7d89b9&quot;) { blockHash: &quot;0x581b5d0f2e5796ffceb87e7bae4a50a53c59359ce8aaffcf0b33c892a5c67b84&quot;, blockNumber: 10, from: &quot;0x0eea1b6dda7118e54b2e47763f5a15cec6fd3f59&quot;, gas: 90000, gasPrice: 18000000000, hash: &quot;0xf11705da1551866649f2bebca1b43516beb9a4908d1af8a3a6887bba4b7d89b9&quot;, input: &quot;0x&quot;, nonce: 0, r: &quot;0x7223003484c508eb9dd33dbbe8f0d5ec9597d7bc7ee4d7ab0f7de588ebc3462b&quot;, s: &quot;0x26058effb045702385bc37f569f20734be7f6861df8e56c7537e595fee994263&quot;, to: &quot;0xac720f92b431049a8b3dac8e043bbc3d6a72166e&quot;, transactionIndex: 0, v: &quot;0x141&quot;, value: 10000000000000000000 }其他都无需多言，需要注意的是 value 虽然是本次交易传送的以太币数量，但是由于是 Wei 作为计价单位，所以看上去会很多，实际上换算成以太币需要去掉 18 个 0！ Step 3: 部署智能合约并调用智能合约可是区块链的精髓所在。有了智能合约，区块链就从原来冷冰冰的账本，变成了一个能够自动处理事务的银行私人管家！那么我们要如何开始我们的智能合约之旅呢？ 在以太坊上，智能合约最主要的语言形式是 Solidity，我们可以通过这个语言写出我们需要的合约并将其部署在区块链上的交易中以执行和调用。那么我们要怎么将代码写到交易中呢？ 事实上我们并非直接部署 Solidity 到交易中，而是通过编译器将其转换为字节码（类似于 JAVA 文件转换为 Class 文件一样），然后写到交易中由矿工代为执行。那么……我们是不是要大费周章地去新装一堆环境然后搞个编译器呢？不！自从官方推出了 Remix 在线编译器 后，我们只需在网页上动动鼠标就可以完成编译的过程了！ 我们的第一个智能合约在这里我们就不详细地讲解 Solidity 的语法了，直接给出一个可用的小程序： 12345678910111213141516171819202122232425contract Mortal { /* Define variable owner of the type address */ address owner; /* This function is executed at initialization and sets the owner of the contract */ function Mortal() { owner = msg.sender; } /* Function to recover the funds on the contract */ function kill() { if (msg.sender == owner) selfdestruct(owner); }}contract Greeter is Mortal { /* Define variable greeting of the type string */ string greeting; /* This runs when the contract is executed */ function Greeter(string _greeting) public { greeting = _greeting; } /* Main function */ function greet() constant returns (string) { return greeting; }} 这个程序就是 Hello World！。通过 Remix 编译，我们可以获取到这段代码的字节码和 ABI……不过我们甚至可以更方便，直接获取到部署的命令！不过在尝试部署之前，我们可以先通过 Remix 进行测试和调试、运行。 在线 Remix 调试在右侧 Deploy 边栏写入 “Hello World” 之后点击按钮即可部署一个智能合约到测试用的区块链上： 然后下方的控制台会显示合约所部署到的交易： 复制 transaction hash 到 Debugger 下，我们就可以进行编译生成类汇编语言的 Debug 了： 当然，我们也可以通过点击右侧区块中的函数名来快速执行我们的合约并查看执行结果： 部署智能合约说回部署的事情，将 Remix 所生成的 JS 代码复制下来： 1234567891011121314var _greeting = 'Hello World!' ;var greeterContract = web3.eth.contract([{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"greet\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_greeting\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]);var greeter = greeterContract.new( _greeting, { from: web3.eth.accounts[0], data: '0x608060405234801561001057600080fd5b5060405161039b38038061039b83398101806040528101908080518201929190505050336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508060019080519060200190610089929190610090565b5050610135565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106100d157805160ff19168380011785556100ff565b828001600101855582156100ff579182015b828111156100fe5782518255916020019190600101906100e3565b5b50905061010c9190610110565b5090565b61013291905b8082111561012e576000816000905550600101610116565b5090565b90565b610257806101446000396000f30060806040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806341c0e1b514610051578063cfae321714610068575b600080fd5b34801561005d57600080fd5b506100666100f8565b005b34801561007457600080fd5b5061007d610189565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100bd5780820151818401526020810190506100a2565b50505050905090810190601f1680156100ea5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610187576000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16ff5b565b606060018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156102215780601f106101f657610100808354040283529160200191610221565b820191906000526020600020905b81548152906001019060200180831161020457829003601f168201915b50505050509050905600a165627a7a72305820e7a453f2653248be25eef5f4870cb92a6174544f192881558a1f84efc3b9719a0029', gas: '4700000' }, function (e, contract){ console.log(e, contract); if (typeof contract.address !== 'undefined') { console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash); } }) 把这段代码写入客户端终端中，然后令客户端继续挖矿，并在挖到至少一个矿后停止。我们就可以调用我们部署的代码了！由于 Remix 帮我们设置了一个部署完成后通知的回调函数，我们甚至可以看到： &gt; null [object Object] Contract mined! address: 0xa84ea2e3143ee1d5c402e2c99cc8cfe560aba926 transactionHash: 0x2709ca5ecd874090be80fba698db565a454d02ad1f092752ac4916c6b22f28ba然后我们可以尝试调用： &gt; greeter.greet() &quot;Hello World!&quot;大功告成~ 交易字段分析我们注意到，智能合约实际上是部署在交易上的。那么在部署之后，交易的字段变成什么样子了呢？不如我们通过交易号看一看吧。 12345678910111213141516{ blockHash: \"0x5269b326b34d29e44b0d0929f46d12fb80cdd77c6df82628e2afd94c5c94a81e\", blockNumber: 116, from: \"0x0eea1b6dda7118e54b2e47763f5a15cec6fd3f59\", gas: 4700000, gasPrice: 18000000000, hash: \"0x2709ca5ecd874090be80fba698db565a454d02ad1f092752ac4916c6b22f28ba\", input: \"0x608060405234801561001057600080fd5b5060405161039b38038061039b83398101806040528101908080518201929190505050336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508060019080519060200190610089929190610090565b5050610135565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106100d157805160ff19168380011785556100ff565b828001600101855582156100ff579182015b828111156100fe5782518255916020019190600101906100e3565b5b50905061010c9190610110565b5090565b61013291905b8082111561012e576000816000905550600101610116565b5090565b90565b610257806101446000396000f30060806040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806341c0e1b514610051578063cfae321714610068575b600080fd5b34801561005d57600080fd5b506100666100f8565b005b34801561007457600080fd5b5061007d610189565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100bd5780820151818401526020810190506100a2565b50505050905090810190601f1680156100ea5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610187576000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16ff5b565b606060018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156102215780601f106101f657610100808354040283529160200191610221565b820191906000526020600020905b81548152906001019060200180831161020457829003601f168201915b50505050509050905600a165627a7a72305820e7a453f2653248be25eef5f4870cb92a6174544f192881558a1f84efc3b9719a00290000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000c48656c6c6f20576f726c64210000000000000000000000000000000000000000\", nonce: 8, r: \"0x524ca3d00964056cfef915056077d784716d0a49c739abe561f420b79dde9e61\", s: \"0x486ea3fb3baeab3f2e08616737a386b879b4868af7f1295b8d81c1749a74df6\", to: null, transactionIndex: 0, v: \"0x141\", value: 0} 逐字段分析如下： blockHash: 交易所属区块的哈希值 blockNumber: 交易所属区块的编号 from: 交易发起者 gas: 交易发起者为本交易支出的 gas 量，多余的会返还给发起者 gasPrice: 交易发起者为每个 gas 付出的 Wei 量 hash: 交易的哈希值 input: 包含 data 的字节码 r|s|v: 用于校验 ECDSA 签名 nonce: 该交易是发起者的第几笔交易 to: 以太币接收方，为 null 表示这个交易用于部署智能合约 value: 交易的以太币个数，为 0 表示这个交易用于部署智能合约 Step 4: 多节点的私有链多节点环境搭建为了统一环境，我们把之前的 private 文件夹直接删除吧~新建两个文件夹：node1 和 node2。然后我们开启两个终端，分别在两个文件夹内，以相同的网络 id 和不同的端口号创建区块链节点，并以控制台模式启动节点： 123# Node1geth --datadir ./node1/ init genesis.jsongeth --datadir node1 --nodiscover --networkid 51024 --port 30123 console 123# Node2geth --datadir ./node2/ init genesis.jsongeth --datadir node2 --nodiscover --networkid 51024 --port 30124 console 然后我们在第一个节点的控制台中运行以下命令获得节点信息： 123456789101112131415161718192021222324252627&gt; admin.nodeInfo{ enode: \"enode://e7c783dee74c2c83e9f8242b511f0c56d218822bd0ed65380232da0f8fb13bdbff1b54122d75d689fd0c8cac8aed9ae6042cdde161212a6753e36b586a0db123@[::]:30123?discport=0\", id: \"e7c783dee74c2c83e9f8242b511f0c56d218822bd0ed65380232da0f8fb13bdbff1b54122d75d689fd0c8cac8aed9ae6042cdde161212a6753e36b586a0db123\", ip: \"::\", listenAddr: \"[::]:30123\", name: \"Geth/v1.8.14-stable/darwin-amd64/go1.11\", ports: { discovery: 0, listener: 30123 }, protocols: { eth: { config: { chainId: 143, eip150Hash: \"0x0000000000000000000000000000000000000000000000000000000000000000\", eip155Block: 0, eip158Block: 0, homesteadBlock: 0 }, difficulty: 80, genesis: \"0x248492021566b9fc031421e8ed6d2a1d8d8a78027dd5ff17e6079ea39d15aeed\", head: \"0x248492021566b9fc031421e8ed6d2a1d8d8a78027dd5ff17e6079ea39d15aeed\", network: 51024 } }} 注意到 enode 这个字段了吗，它是一个可以标识该节点的协议链接。将他复制，在第二个节点的终端中运行如下命令，参数就是第一个节点的 enode： 12&gt; admin.addPeer(\"enode://e7c783dee74c2c83e9f8242b511f0c56d218822bd0ed65380232da0f8fb13bdbff1b54122d75d689fd0c8cac8aed9ae6042cdde161212a6753e36b586a0db123@[::]:30123?discport=0\")true 之后，我们回到第一个节点，运行如下命令，可以看到两个节点已经建立了连接： 1234567891011121314151617181920&gt; admin.peers[{ caps: [\"eth/63\"], id: \"d1b4c55a40bd1e193b52e9087e804e91a3451eabdc1df0506e3eadeee49a6d82554edfe467abc3d94014db218fb9951aeb75fe6ea9f42daf63fd4594b349578e\", name: \"Geth/v1.8.14-stable/darwin-amd64/go1.11\", network: { inbound: true, localAddress: \"[::1]:30123\", remoteAddress: \"[::1]:60853\", static: false, trusted: false }, protocols: { eth: { difficulty: 80, head: \"0x248492021566b9fc031421e8ed6d2a1d8d8a78027dd5ff17e6079ea39d15aeed\", version: 63 } }}] 节点间交易接下来，我们尝试在两个节点间进行交易。首先，我们需要在两个节点上分别创建账号，然后在第一个节点上开始挖矿，来获取交易所需的资金。 12345678&gt; personal.newAccount('password')// Run this command on both nodes&gt; miner.start()// wait for mining&gt; miner.stop()&gt; web3.fromWei(eth.getBalance(eth.accounts[0]), \"ether\")50 如上所示，我们已经得到了 50 个以太币。那么接下来我们尝试将其中的 10 个转账给另一个节点上的账户吧！ 12345personal.unlockAccount(eth.accounts[0], 'password')eth.sendTransaction({from: eth.accounts[0], to: \"0x42ad6fb8f0249ed50968611aa4403c29a1f30ea6\", value: web3.toWei(10,\"ether\")})miner.start()// wait for miningminer.stop() 注意，这里的 to 字段是第二个节点的账号哈希，可以通过在第二个终端\b上执行 eth.account[0] 获取到。然后我们可以在第二个终端上运行如下命令看到我们转账的结果： 12&gt; web3.fromWei(eth.getBalance(eth.accounts[0]), \"ether\")10 至此，多节点环境的搭建和交易的执行完毕。","link":"/Ethereum/Setup-ethereum-on-your-Mac/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"SSAD","slug":"SSAD","link":"/tags/SSAD/"},{"name":"Github Pages","slug":"Github-Pages","link":"/tags/Github-Pages/"},{"name":"Gitment","slug":"Gitment","link":"/tags/Gitment/"},{"name":"Unity3D","slug":"Unity3D","link":"/tags/Unity3D/"},{"name":"Service Computing","slug":"Service-Computing","link":"/tags/Service-Computing/"},{"name":"Cloud Service","slug":"Cloud-Service","link":"/tags/Cloud-Service/"},{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"VPS server","slug":"VPS-server","link":"/tags/VPS-server/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"Remote Floder","slug":"Remote-Floder","link":"/tags/Remote-Floder/"},{"name":"Assignment","slug":"Assignment","link":"/tags/Assignment/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"Decision Tree","slug":"Decision-Tree","link":"/tags/Decision-Tree/"},{"name":"Ensemble Learning","slug":"Ensemble-Learning","link":"/tags/Ensemble-Learning/"},{"name":"WEB","slug":"WEB","link":"/tags/WEB/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Blockchain","slug":"Blockchain","link":"/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","link":"/tags/Ethereum/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"SSAD","slug":"SSAD","link":"/categories/SSAD/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Unity3D","slug":"Unity3D","link":"/categories/Unity3D/"},{"name":"Service Computing","slug":"Service-Computing","link":"/categories/Service-Computing/"},{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"},{"name":"Tips","slug":"Tips","link":"/categories/Tips/"},{"name":"Others","slug":"Others","link":"/categories/Others/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/categories/Machine-Learning/"},{"name":"WEB Assignments","slug":"WEB-Assignments","link":"/categories/WEB-Assignments/"},{"name":"Ethereum","slug":"Ethereum","link":"/categories/Ethereum/"}]}