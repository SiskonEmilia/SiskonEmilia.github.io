<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Coding.Siskon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Coding.Siskon">
<meta property="og:url" content="https://siskonemilia.github.io/index.html">
<meta property="og:site_name" content="Coding.Siskon">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coding.Siskon">
  
    <link rel="alternate" href="/atom.xml" title="Coding.Siskon" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Coding.Siskon</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Simple Blog of SiskonEmilia</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://siskonemilia.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Leetcode-685-Redundant-Connection-II" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Leetcode/Leetcode-685-Redundant-Connection-II/" class="article-date">
  <time datetime="2018-09-26T14:11:15.000Z" itemprop="datePublished">2018-09-26</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Leetcode/Leetcode-685-Redundant-Connection-II/">Leetcode 685. Redundant Connection II</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="685-Redundant-Connection-II"><a href="#685-Redundant-Connection-II" class="headerlink" title="685. Redundant Connection II"></a>685. Redundant Connection II</h3><ul>
<li><strong>Difficulty:</strong> Hard</li>
<li><strong>Total Accepted:</strong> 11.2K</li>
<li><strong>Total Submissions:</strong> 39.7K</li>
</ul>
<p>In this problem, a rooted tree is a <strong>directed</strong> graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.</p>
<p>The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, …, N), with one additional directed edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</p>
<p>The resulting graph is given as a 2D-array of <code>edges</code>. Each element of <code>edges</code> is a pair <code>[u, v]</code> that represents a directed edge connecting nodes <code>u</code> and <code>v</code>, where <code>u</code> is a parent of child <code>v</code>.</p>
<p>Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [[1,2], [1,3], [2,3]]
Output: [2,3]
Explanation: The given directed graph will be like this:
  1
 / \
v   v
2--&gt;3
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [[1,2], [2,3], [3,4], [4,1], [1,5]]
Output: [4,1]
Explanation: The given directed graph will be like this:
5 &lt;- 1 -&gt; 2
     ^    |
     |    v
     4 &lt;- 3
</code></pre><p><strong>Note:</strong></p>
<ul>
<li>The size of the input 2D-array will be between 3 and 1000.</li>
<li>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</li>
</ul>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="AC-截图"><a href="#AC-截图" class="headerlink" title="AC 截图"></a>AC 截图</h3><img src="/Leetcode/Leetcode-685-Redundant-Connection-II/finalresult.png" title="FinalResult">
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>该问题给出一组有向图内的边，并且给出等同数量的节点，构成一个可以通过 <strong>删掉一条边</strong> 而成为 <strong>有根树</strong> 的有向图。在有多个答案时，输出最后出现的可用边。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题乍一看情况非常复杂，因为要从一个有向图转换为有根树，需要消除图中所有的回环，以及所有入度大于 1 的节点（后称「双源」节点）。但是冷静下来想想，题目其实已经给出了相当优厚的条件——<strong>只能删掉一条边</strong>。</p>
<p>根据这个条件，我们可以反推回输入数据的情况：该有向图只可能是下列三种情况的一种。</p>
<ul>
<li>有一个回环，没有「双源」节点</li>
<li>有一个「双源」节点，没有回环</li>
<li>有一个「双源」节点，并且该节点也在一个回环内</li>
</ul>
<p>考虑第一种情况，因为只删掉一条边就可以构成有根树，那么最后形成环的那条边，肯定就是我们要找的边，因而在扫描一边所有边的时候监控整个图的连通性即可，<strong>一旦发现成环，我们就删掉那条边</strong>。</p>
<p>考虑第二种情况，在没有回环的情况下，两条边可以 <strong>任意地删除</strong>，因而删除触发形成双源节点条件的边即可，因其相对位于集合的后部，处理方式同第一种。</p>
<p>考虑第三种情况，因为这个时候双源节点接入的两条边中有一条会参与成环，因而要同时解除成环和双源，我们只能 <strong>删掉参与成环和双源节点的唯一边</strong>。同时，为了保证不会漏掉这种重叠情况，在前两种情况的判定中，我们 <strong>不能在判定后立刻作出相应操作</strong>，而要等待整个边集合扫描完后再处理。</p>
<p>那么接下来，我们来考虑如何判定双源与回环的问题。</p>
<p>（这实际上是一个简化的 <strong>并查集</strong> 问题，有兴趣的同学可以了解一下）我们维护一个「祖先」数组，它标定整个图中每个节点的祖先。每当一条边由点 A 指向点 B 时，我们令点 B 的祖先为点 A 的祖先。这样，当一条边指向一个有祖先的节点时，就会发生「双源」；当一条边的两端祖先相同时，就会发生「回环」。</p>
<p>必须要考虑的是，当「双源」发生时，对双源节点的祖先查找可能引导向两个结果，如何对两个结果进行处理会是一个问题。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h3><h4 id="结果截图"><a href="#结果截图" class="headerlink" title="结果截图"></a>结果截图</h4><img src="/Leetcode/Leetcode-685-Redundant-Connection-II/midresult.png" title="MidResult">
<h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> runfirst = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> parent1, parent2;</span><br><span class="line">  <span class="keyword">int</span> subParent1, subParent2;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *doubleSourceEdge, *circularEdge;</span><br><span class="line">  <span class="keyword">int</span> doubleSourceNode;</span><br><span class="line">  <span class="keyword">int</span> subParent;</span><br><span class="line">  <span class="keyword">int</span> sameParent;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantDirectedConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = edges.size();</span><br><span class="line">    <span class="keyword">int</span> *parent = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> *father = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    doubleSourceEdge = circularEdge = <span class="literal">nullptr</span>;</span><br><span class="line">    doubleSourceNode = subParent = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">memset</span>(parent, <span class="number">0</span>, (size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter : edges) &#123;</span><br><span class="line">      <span class="keyword">if</span> (doubleSourceNode) &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp1 = findParentFork(parent, father, iter[<span class="number">0</span>]),</span><br><span class="line">          temp2 = findParentFork(parent, father, iter[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        parent1 = temp1[<span class="number">0</span>];</span><br><span class="line">        parent2 = temp2[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        subParent1 = temp1[<span class="number">1</span>];</span><br><span class="line">        subParent2 = temp2[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        parent1 = findParent(parent, iter[<span class="number">0</span>]);</span><br><span class="line">        parent2 = findParent(parent, iter[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (parent[iter[<span class="number">1</span>]]) &#123;</span><br><span class="line">        <span class="comment">// Double source</span></span><br><span class="line">        <span class="keyword">if</span> (parent1 == parent2) &#123;</span><br><span class="line">          <span class="keyword">return</span> iter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (circularEdge) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;father[iter[<span class="number">1</span>]], iter[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          doubleSourceNode = iter[<span class="number">1</span>];</span><br><span class="line">          doubleSourceEdge = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;father[iter[<span class="number">1</span>]], iter[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subParent = parent2;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (doubleSourceNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sameParent = parent1) == parent2 || (sameParent = parent1) == subParent2 || (sameParent = parent2) == subParent1) &#123;</span><br><span class="line">          <span class="keyword">if</span> (findParent(parent, doubleSourceNode) == sameParent) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;father[doubleSourceNode], doubleSourceNode&#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *doubleSourceEdge;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (parent1 == parent2) &#123;</span><br><span class="line">        <span class="comment">// Circular path</span></span><br><span class="line">        circularEdge = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;iter[<span class="number">0</span>], iter[<span class="number">1</span>]&#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      parent[iter[<span class="number">1</span>]] = parent1;</span><br><span class="line">      father[iter[<span class="number">1</span>]] = iter[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (doubleSourceNode) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;father[doubleSourceNode], doubleSourceNode&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> *circularEdge;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> *parent, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == parent[index] || parent[index] == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> findParent(parent, parent[index]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findParentFork(<span class="keyword">int</span> *parent, <span class="keyword">int</span> *father, <span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == parent[index] || parent[index] == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;index, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (index == doubleSourceNode) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;findParent(parent, father[index]),</span><br><span class="line">        findParent(parent, subParent)&#125;);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> findParentFork(parent, father, father[index]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h4><p>在题解 1 中，我们通过在一次扫描中监控前两种情况来达成要求。在检测到其中一种情况发生后，我们将继续扫描，直到第三种情况发生或者到达终点。这个算法很好的达到了我们的预期效果，但是有很多问题。</p>
<p>首先，在触发「双源」后，后续扫描复杂度陡增，严重影响了程序运行效率。其次，过于复杂的逻辑判断大大增加了编程难度。最后，在“寻找祖先”的过程中，大量可以复用的信息被浪费掉。</p>
<p>那么有没有什么优化的办法呢？</p>
<p>首先，我们考虑一下这三种情况。实际上我们不必在扫描时判断如此多的内容。首先，我们进行一次扫描，查看是否有「双源」的发生。若有，我们去除触发双源的边，再进行一次查找，此时如果没有回环的发生，那么这条边就是目标边，否则，就说明是另一条「双源」边在回环内，那条边也就是目标边。如果没有发生「双源」，则是简单的回环问题，找到成环边即可。</p>
<p>然后，我们考虑一下信息复用的问题。由动态规划的思想，我们可以在每次寻找祖先的过程中，更新整个路径上的所有祖先，从而大大减少后续的查找祖先的时间。</p>
<p>具体实现见题解 2。</p>
<h3 id="题解-2（最优解）"><a href="#题解-2（最优解）" class="headerlink" title="题解 2（最优解）"></a>题解 2（最优解）</h3><h4 id="结果截图-1"><a href="#结果截图-1" class="headerlink" title="结果截图"></a>结果截图</h4><img src="/Leetcode/Leetcode-685-Redundant-Connection-II/finalresult.png" title="FinalResult">
<h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fast = []() &#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> parent1, parent2;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; doubleSourceEdge1, doubleSourceEdge2;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantDirectedConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = edges.size();</span><br><span class="line">    <span class="keyword">int</span> *father = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    doubleSourceEdge1 = doubleSourceEdge2 = <span class="literal">nullptr</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">memset</span>(father, <span class="number">0</span>, (size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Looking for node which has two sources</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter : edges) &#123;</span><br><span class="line">      <span class="keyword">if</span> (father[iter[<span class="number">1</span>]]) &#123;</span><br><span class="line">        <span class="comment">// found</span></span><br><span class="line">        doubleSourceEdge1 = &#123;</span><br><span class="line">          father[iter[<span class="number">1</span>]], iter[<span class="number">1</span>]</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        doubleSourceEdge2 = iter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// break;</span></span><br><span class="line">      &#125;</span><br><span class="line">      father[iter[<span class="number">1</span>]] = iter[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; ++i) father[i] = i;</span><br><span class="line">    <span class="comment">// Looking for an edge which forms a circular path</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter: edges) &#123;</span><br><span class="line">      <span class="keyword">if</span> (doubleSourceEdge2 &amp;&amp; iter == *doubleSourceEdge2) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      parent1 = findParent(father, iter[<span class="number">0</span>]);</span><br><span class="line">      parent2 = findParent(father, iter[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (parent1 == parent2) &#123;</span><br><span class="line">        <span class="comment">// found</span></span><br><span class="line">        <span class="keyword">if</span> (doubleSourceEdge1.empty())</span><br><span class="line">          <span class="keyword">return</span> iter;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">          <span class="keyword">return</span> doubleSourceEdge1;</span><br><span class="line">      &#125;</span><br><span class="line">      father[iter[<span class="number">1</span>]] = iter[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doubleSourceEdge2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> *&amp;father, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == father[index])</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> father[index] = findParent(father, father[index]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Leetcode/Leetcode-685-Redundant-Connection-II/" data-id="cjmjc48wa002m7orstrm3kqrx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/">Leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Make-Full-Use-of-Your-VPS-Server" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Tips/Make-Full-Use-of-Your-VPS-Server/" class="article-date">
  <time datetime="2018-09-21T01:12:18.000Z" itemprop="datePublished">2018-09-21</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tips/">Tips</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Tips/Make-Full-Use-of-Your-VPS-Server/">Make Full Use of Your VPS Server</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【预告】相信很多小伙伴都有一个自己的 VPS 服务器，可是大多数人只是在上面挂载一个 SS/SSR 服务器（这篇里也有讲），然后就对它不管不问了……看看你们 VPS 的 CPU 利用率，这难道不是在暴殄天物嘛！如果你和我一样有 VPS 资源被白白浪费的苦恼，那么这篇文章或许能解决你的问题～【本文长期更新】</p>
        
          <p class="article-more-link">
            <a href="/Tips/Make-Full-Use-of-Your-VPS-Server/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Tips/Make-Full-Use-of-Your-VPS-Server/" data-id="cjmjc48uq000a7orsvt9e4488" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VPS-server/">VPS server</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode-124-Binary-Tree-Maximum-Path-Sum" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Leetcode/Leetcode-124-Binary-Tree-Maximum-Path-Sum/" class="article-date">
  <time datetime="2018-09-20T12:31:21.000Z" itemprop="datePublished">2018-09-20</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Leetcode/Leetcode-124-Binary-Tree-Maximum-Path-Sum/">Leetcode 124. Binary Tree Maximum Path Sum</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a>124. Binary Tree Maximum Path Sum</h3><ul>
<li><strong>Difficulty:</strong> Hard</li>
<li><strong>Total Accepted:</strong> 145.3K</li>
<li><strong>Total Submissions:</strong> 519.8K</li>
</ul>
<p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="AC-截图"><a href="#AC-截图" class="headerlink" title="AC 截图"></a>AC 截图</h3><img src="/Leetcode/Leetcode-124-Binary-Tree-Maximum-Path-Sum/finalresult.png" title="FinalResult">
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个非空的二叉树，我们需要找到一个路径，使得路径上所有节点的值的和最大。需要注意的是，该路径最少需要包含一个节点，同时这个路径可以不沿着树边「由父到子」的方向走，但是不可以回头。同时，这个路径也不需要经过根结点。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很简单的 DFS + 贪心算法就可以求解。因为路径可以不经过根节点，因而任何子过程都有可能产生一个最优解。为了记录这些最优解，我们建立一个全局变量来记录当前的最优解。考虑一条路径，以最上层的节点的视角，其有三种可能的形状：向左/右子树延伸，同时向两个子树延伸，以及一个裸节点。</p>
<p>其中，第一种情况和第三种情况的路径可以被上层节点复用，来构成新的路径；而第二种情况的路径则不能拓展，因为路径不能回头，因而不可能有分叉。因而，在每个子过程中，我们获取左右子树的非第二种情况的最大 sum 的路径，将其中大于 0 的都与节点的值相加，并尝试更新全局最大值。然后选择其中最大的大于零的 sum，与节点的值相加，并返回该值，作为「非第二种情况的最大值」。</p>
<p>然后，不要忘记加上 <code>iostream</code> 的加速装置～我们的最优解就出炉啦：</p>
<h3 id="题解（最优解）"><a href="#题解（最优解）" class="headerlink" title="题解（最优解）"></a>题解（最优解）</h3><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> runfirst = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> globalMax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      globalMax = root-&gt;val;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> maxSum = root-&gt;val, temp;</span><br><span class="line"></span><br><span class="line">      temp = subtreeMax(root-&gt;left);</span><br><span class="line">      <span class="keyword">if</span> (temp &gt; <span class="number">0</span>)</span><br><span class="line">        maxSum += temp;</span><br><span class="line">        </span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; temp;</span><br><span class="line">      </span><br><span class="line">      temp = subtreeMax(root-&gt;right);</span><br><span class="line">      <span class="keyword">if</span> (temp &gt; <span class="number">0</span>)</span><br><span class="line">        maxSum += temp;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span> (maxSum &gt; globalMax)</span><br><span class="line">        globalMax = maxSum;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> globalMax;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subtreeMax</span><span class="params">(TreeNode* subroot)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (subroot == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span> val = subroot-&gt;val, temp1, temp2;</span><br><span class="line"></span><br><span class="line">      temp1 = subtreeMax(subroot-&gt;left);</span><br><span class="line">      temp2 = subtreeMax(subroot-&gt;right);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (temp1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (temp1 &gt; temp2) &#123;</span><br><span class="line">            val += temp1;</span><br><span class="line">            <span class="keyword">if</span> (val + temp2 &gt; globalMax)</span><br><span class="line">              globalMax = val + temp2;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            val += temp2;</span><br><span class="line">            <span class="keyword">if</span> (val + temp1 &gt; globalMax)</span><br><span class="line">              globalMax = val + temp1;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          val += temp1;</span><br><span class="line">          <span class="keyword">if</span> (val &gt; globalMax)</span><br><span class="line">            globalMax = val;</span><br><span class="line">          <span class="keyword">return</span> val; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (temp2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        val += temp2;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; globalMax)</span><br><span class="line">          globalMax = val;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (val &gt; globalMax)</span><br><span class="line">        globalMax = val;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Leetcode/Leetcode-124-Binary-Tree-Maximum-Path-Sum/" data-id="cjmjc48uh00067ors6t7lcuvq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/">Leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode-4-Median-of-Two-Sorted-Arrays" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/" class="article-date">
  <time datetime="2018-09-16T08:08:02.000Z" itemprop="datePublished">2018-09-16</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/">Leetcode 4. Median of Two Sorted Arrays</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h3><ul>
<li><strong>Difficulty:</strong> Hard</li>
<li><strong>Total Accepted:</strong> 301.7K</li>
<li><strong>Total Submissions:</strong> 1.3M</li>
</ul>
<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
<p><strong>Example1:</strong></p>
<pre><code>nums1 = [1, 3]
nums2 = [2]

The median is 2.0
</code></pre><p><strong>Exaple2:</strong></p>
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
</code></pre><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="AC-截图"><a href="#AC-截图" class="headerlink" title="AC 截图"></a>AC 截图</h3><img src="/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/finalresult.png" title="FinalResult">
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>本题要求寻找两个有序序列合并后的序列的「中位数」。同时要求 O(log (m+n)) 级别的时间复杂度。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>在一个序列中寻找一个数，又要求 O(log) 级的时间复杂度，我们很容易想到通过不断分割区间来寻找目标数的二分查找法。那么唯一的问题是如何在两个有序序列上应用针对单条序列的二分查找法了。</p>
<p>创建变量 <code>start1</code>、<code>end1</code>、<code>start2</code>、<code>end2</code>、<code>halfSize</code>，分别标识两个序列当前处理区间的头和尾，以及用于计数左侧较小数个数。通过不断对比两个区间中间数的大小，来使得中间数靠近，直到 <code>halfSize</code> 达到序列长度的一半即可（题解中为从一半减少到1）。</p>
<h3 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h3><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lengthSum = nums1.size() + nums2.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (lengthSum % <span class="number">2</span> == <span class="number">1</span>) ?</span><br><span class="line">      (<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), (lengthSum + <span class="number">1</span>) / <span class="number">2</span>):</span><br><span class="line">      ((<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>,nums2.size(), lengthSum / <span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">      (<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>,nums2.size(), lengthSum / <span class="number">2</span>)) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findMedian</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">const</span> <span class="keyword">int</span> start1,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">int</span> end1, <span class="keyword">const</span> <span class="keyword">int</span> start2, <span class="keyword">const</span> <span class="keyword">int</span> end2,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">int</span> halfSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size1 = end1 - start1, size2 = end2 - start2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size1 &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + halfSize - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (size2 &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums1[start1 + halfSize - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (halfSize == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid1 = (end1 + start1) / <span class="number">2</span>, mid2 = (end2 + start2) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums1[mid1] &lt;= nums2[mid2]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (size1 / <span class="number">2</span> + size2 / <span class="number">2</span> + <span class="number">1</span> &gt;= halfSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMedian(nums1, nums2, start1, end1, start2, mid2, halfSize);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findMedian(nums1, nums2, mid1 + <span class="number">1</span>, end1, start2, end2,</span><br><span class="line">                          halfSize - size1 / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (size1 / <span class="number">2</span> + size2 / <span class="number">2</span> + <span class="number">1</span> &gt;= halfSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMedian(nums1, nums2, start1, mid1, start2, end2, halfSize);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findMedian(nums1, nums2, start1, end1, mid2 + <span class="number">1</span>, end2,</span><br><span class="line">                          halfSize - size2 / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="AC-截图-1"><a href="#AC-截图-1" class="headerlink" title="AC 截图"></a>AC 截图</h4><img src="/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/solve1.png" title="AC">
<h4 id="题解分析"><a href="#题解分析" class="headerlink" title="题解分析"></a>题解分析</h4><p>虽然这个题解顺利通过了测试，但是我们发现，前面的最优解还有相当多……那么尝试对于代码进行优化。我们知道，递归方法相对于迭代法需要在每次递归时，对栈进行单独的操作——在空间和时间复杂度上都不如迭代法。</p>
<p>那么，是否可以把递归法转换为迭代法呢——当然可以啦～</p>
<h3 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h3><h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lengthSum = nums1.size() + nums2.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (lengthSum % <span class="number">2</span> == <span class="number">1</span>) ?</span><br><span class="line">      (<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), (lengthSum + <span class="number">1</span>) / <span class="number">2</span>) : </span><br><span class="line">      ((<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), lengthSum / <span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">      (<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), lengthSum / <span class="number">2</span>)) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findMedian</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> halfSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size1, size2, mid1, mid2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      size1 = end1 - start1;</span><br><span class="line">      size2 = end2 - start2;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size1 &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + halfSize - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (size2 &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums1[start1 + halfSize - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (halfSize == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">      mid1 = (end1 + start1) / <span class="number">2</span>;</span><br><span class="line">      mid2 = (end2 + start2) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nums1[mid1] &lt;= nums2[mid2]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size1 / <span class="number">2</span> + size2 / <span class="number">2</span> + <span class="number">1</span> &gt;= halfSize) &#123;</span><br><span class="line">          end2 = mid2;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          start1 = mid1 + <span class="number">1</span>;</span><br><span class="line">          halfSize -= size1 / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size1 / <span class="number">2</span> + size2 / <span class="number">2</span> + <span class="number">1</span> &gt;= halfSize) &#123;</span><br><span class="line">          end1 = mid1;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          start2 = mid2 + <span class="number">1</span>;</span><br><span class="line">          halfSize -= size2 / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="AC-截图-2"><a href="#AC-截图-2" class="headerlink" title="AC 截图"></a>AC 截图</h4><img src="/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/solve2.png" title="AC">
<h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="题解分析"></a>题解分析</h4><p>嗯？这两个的耗时完全没有区别啊！看来是编译器已经把我的递归优化掉了……那么和第一梯队如此大的时间差又是从何而来呢？</p>
<p>参加过 ACM 的同学应该都知道，能用 <code>scanf</code> 的代码绝对不用 <code>cin</code>。不过其实 <code>cin</code> 的效率并不算差，只是，我们需要对其进行一些优化才能让他发挥出应有的实力。要想解放 <code>cin</code> 实力的封印，一行代码足矣：</p>
<pre><code>ios::sync_with_stdio(false);
</code></pre><p>这会禁用 cin／cout 和 scanf／printf 之间的同步等待，从而大幅提升 cin 的效率——甚至可以直追 scanf。但是这里我们又有一个问题了，我们函数的调用显然是在输入操作之后，怎样才能让这个函数在输入操作前生效呢？当然是有办法的啦：</p>
<h3 id="题解3（最优解）"><a href="#题解3（最优解）" class="headerlink" title="题解3（最优解）"></a>题解3（最优解）</h3><h4 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> runfirst = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> lengthSum = nums1.size() + nums2.size();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (lengthSum % <span class="number">2</span> == <span class="number">1</span>) ?</span><br><span class="line">        (<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), (lengthSum + <span class="number">1</span>) / <span class="number">2</span>) :</span><br><span class="line">        ((<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), lengthSum / <span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">        (<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), lengthSum / <span class="number">2</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMedian</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums2,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> start1, <span class="keyword">int</span> end1,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> start2, <span class="keyword">int</span> end2,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> halfSize)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> size1, size2, mid1, mid2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            size1 = end1 - start1;</span><br><span class="line">            size2 = end2 - start2;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (size1 &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + halfSize - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (size2 &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums1[start1 + halfSize - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (halfSize == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">            mid1 = (end1 + start1) / <span class="number">2</span>;</span><br><span class="line">            mid2 = (end2 + start2) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums1[mid1] &lt;= nums2[mid2]) &#123;</span><br><span class="line">              <span class="keyword">if</span> (size1 / <span class="number">2</span> + size2 / <span class="number">2</span> + <span class="number">1</span> &gt;= halfSize) &#123;</span><br><span class="line">                end2 = mid2;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                start1 = mid1 + <span class="number">1</span>;</span><br><span class="line">                halfSize -= size1 / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (size1 / <span class="number">2</span> + size2 / <span class="number">2</span> + <span class="number">1</span> &gt;= halfSize) &#123;</span><br><span class="line">                end1 = mid1;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                start2 = mid2 + <span class="number">1</span>;</span><br><span class="line">                halfSize -= size2 / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="AC-截图-3"><a href="#AC-截图-3" class="headerlink" title="AC 截图"></a>AC 截图</h4><img src="/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/finalresult.png" title="FinalResult">
<h4 id="题解分析-2"><a href="#题解分析-2" class="headerlink" title="题解分析"></a>题解分析</h4><p>通过声明一个静态的常量变量，我们使得后面这个自执行的函数甚至可以在编译阶段预执行，从而在输入输出前完成对于 cin/cout 的设置～总时耗也从 56ms 下降到了 16ms，妥妥的第一梯队～看来算法和实现细节都是保证程序执行速度的重要环节呢。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/" data-id="cjmjc48wh002p7orsphpf1gxz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/">Leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Service-Computing-01-Private-Cloud-Service" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Service-Computing/Service-Computing-01-Private-Cloud-Service/" class="article-date">
  <time datetime="2018-09-08T10:59:32.000Z" itemprop="datePublished">2018-09-08</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Service-Computing/">Service Computing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Service-Computing/Service-Computing-01-Private-Cloud-Service/">Service Computing 01 - Private Cloud Service</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于作者水平有限，<strong>内容可能存在错漏，若有发现，还望您在评论区指出。</strong> 本博客内容仅适用于 VMWare Workstation，Virtual Box 上的操作可能有所不同。</p>
<h1 id="使用-VMWare-Workstation-让-PC-提供云桌面服务"><a href="#使用-VMWare-Workstation-让-PC-提供云桌面服务" class="headerlink" title="使用 VMWare Workstation 让 PC 提供云桌面服务"></a>使用 VMWare Workstation 让 PC 提供云桌面服务</h1>
        
          <p class="article-more-link">
            <a href="/Service-Computing/Service-Computing-01-Private-Cloud-Service/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Service-Computing/Service-Computing-01-Private-Cloud-Service/" data-id="cjmjc48wn002s7orsptcge6ek" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cloud-Service/">Cloud Service</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Service-Computing/">Service Computing</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode-41-First-Missing-Positive" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Leetcode/Leetcode-41-First-Missing-Positive/" class="article-date">
  <time datetime="2018-09-07T01:55:24.000Z" itemprop="datePublished">2018-09-07</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Leetcode/Leetcode-41-First-Missing-Positive/">Leetcode 41. First Missing Positive</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41. First Missing Positive"></a>41. First Missing Positive</h3><ul>
<li><strong>Difficulty:</strong> Hard</li>
<li><strong>Total Accepted:</strong> 152.5K</li>
<li><strong>Total Submissions:</strong> 571.7K </li>
</ul>
<p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [1, 2, 0]
Output: 3
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [3,4,-1,1]
Output: 2
</code></pre><p><strong>Example 3:</strong></p>
<pre><code>Input: [7,8,9,11,12]
Output: 1
</code></pre><p><strong>Note:</strong></p>
<p>Your algorithm should run in O(n) time and uses constant extra space.</p>
<p><a href="https://leetcode.com/problems/first-missing-positive/description/" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="AC-截图"><a href="#AC-截图" class="headerlink" title="AC 截图"></a>AC 截图</h3><img src="/Leetcode/Leetcode-41-First-Missing-Positive/finalresult.png" title="FinalResult">
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>本题要求寻找到一串未排序的整数中，缺失的最小的正整数。同时要求 $O(n)$ 级的时间复杂度和常量级的空间开销。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>最容易想到的解题方法莫过于从 1 开始，将正整数依次在整个数组中寻找一遍。但是这种在无序数组上进行的扫描，时间复杂度为 $O(n^2)$，显然是不符合要求的。</p>
<p>另一个容易想到的方法是建立一个等规模的布尔数组，初始值为 <code>false</code>，然后扫描一次原始数组，将对应下标的布尔值置为 <code>true</code>。最后扫描一遍布尔数组，即可以以 $O(n)$ 的时间复杂度完成。但是这种方法需要开辟一个变长的空间，不符合题目「常量级空间开销」的要求。</p>
<p>那么要如何优化这两种方法，来满足题目要求呢？</p>
<p>从第一种方法出发，既然无序的数组上扫描会超时，那么我们就尝试在 $O(n)$ 时间复杂度内构建一个“特殊的”有序数组即可。</p>
<p>从第二种方法出发，既然不允许变长的额外空间开销，那么我们就尝试使用原数组的空间来作为“布尔数组”即可。</p>
<p>两种方法的优化最后都指向同一个解法：先对原数组进行操作，使之可以在一次扫描后得出结果。</p>
<p>那么如何进行操作呢？我们知道，我们的目标是寻找缺失的最小的正整数，那么我们可以吧所有数字放到其对应的位置（比如数字 1 放到下标为 0 的位置上，数字 4 放到下标为 3 的位置上），这样一来，<code>array[index] == index + 1</code> 这些布尔值就构成了第二种方法中的“布尔数组”，不满足这个条件的最小的 <code>index</code>，对应的数字 <code>index + 1</code> 就是题解。</p>
<p>构建数组的过程也是简单的，顺序扫描整个数组，不断将当前位置的数字和其应该处于的位置上的数字进行交换，就可以在 $O(n)$ 的时间复杂度下完成操作。再加上最后的扫描求解，整个解法的复杂度为 $O(n)$.</p>
<h3 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h3><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> index, length;</span><br><span class="line">        length = nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; length; ++index) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[index] &gt; <span class="number">0</span> &amp;&amp; nums[index] &lt;= length &amp;&amp; </span><br><span class="line">                    nums[index] != nums[nums[index] - <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums[index], nums[nums[index] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; length; ++index) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] != index + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="AC-截图-1"><a href="#AC-截图-1" class="headerlink" title="AC 截图"></a>AC 截图</h4><img src="/Leetcode/Leetcode-41-First-Missing-Positive/result1.png" title="AC">
<h4 id="题解分析"><a href="#题解分析" class="headerlink" title="题解分析"></a>题解分析</h4><p>虽然这个题解顺利通过了测试，但是竟然还有 16.03% 的更优解？是我算法的问题吗？</p>
<p>打开最优解的示例代码一看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// time: O(n), space: O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i]<span class="number">-1</span>] != nums[i]) &#123;</span><br><span class="line">                swap(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>乍一眼看过去……这不和我是一样的吗？而且 i++ 的效率显然不如 ++i，怎么可能还比我快？他甚至还在每个 for 循环中重新声明变量 i，这肯定是比我直接声明好进行复用要更慢啊！不信邪的我也改了一下自己的代码，于是有了题解2……</p>
<h3 id="题解2（最优解）"><a href="#题解2（最优解）" class="headerlink" title="题解2（最优解）"></a>题解2（最优解）</h3><h4 id="c-代码"><a href="#c-代码" class="headerlink" title="c++ 代码"></a>c++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        length = nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; length; ++index) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[index] &gt; <span class="number">0</span> &amp;&amp; nums[index] &lt;= length &amp;&amp; </span><br><span class="line">                    nums[index] != nums[nums[index] - <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums[index], nums[nums[index] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; length; ++index) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] != index + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="AC-截图-2"><a href="#AC-截图-2" class="headerlink" title="AC 截图"></a>AC 截图</h4><img src="/Leetcode/Leetcode-41-First-Missing-Positive/finalresult.png" title="FinalResult">
<h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="题解分析"></a>题解分析</h4><p>看样子确实是重新声明的写法会更快……但……<strong>为什么复用的效率反而不如每次重新声明高？这不科学！我不接受！</strong></p>
<p>如何找到问题的源头呢？当然是反汇编啦～</p>
<p>测试代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">solve1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    length = nums.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (nums[index] &gt; <span class="number">0</span> &amp;&amp; nums[index] &lt;= length &amp;&amp;</span><br><span class="line">        nums[index] != nums[nums[index] - <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(nums[index], nums[nums[index] - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[index] != index + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">solve2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index, length;</span><br><span class="line">    length = nums.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (nums[index] &gt; <span class="number">0</span> &amp;&amp; nums[index] &lt;= length &amp;&amp;</span><br><span class="line">        nums[index] != nums[nums[index] - <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(nums[index], nums[nums[index] - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[index] != index + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Solution ins;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">auto</span> ans = ins.solve1(input); ans = ins.solve2(input);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://siskonemilia.github.io/Leetcode/Leetcode-41-First-Missing-Positive/winasm1.s">Windows 汇编：solve1</a></p>
<p><a href="https://siskonemilia.github.io/Leetcode/Leetcode-41-First-Missing-Positive/winasm2.s">Windows 汇编：solve2</a></p>
<p>令人吃惊的是：两者的汇编代码几乎是完全一样的！唯一的区别在于：由于 <code>index</code> 和 <code>length</code> 的声明先后顺序不同，其在内存中的地址（相对于ebp）在两个函数中对调了。这虽然没能验证反复声明反而更快的结果，但至少说明了 <strong>在 for 循环初始化语句中声明变量，不会比在外部声明更耗时</strong>。同时也告诉我们，<strong>单纯通过高级语言编写中的直觉推测程序在机器上执行的效率是危险的</strong>。</p>
<p>那么，为什么 <code>solve2</code> 会更快呢？事实上，经过测试，在 Windows VS 环境下，二者速度是基本一致的。那么是编译器和环境的问题吗？</p>
<p>查找 Leetcode 的编译环境，我了解到其使用的是 G++ 6.4，C++14 标准。于是我在 MacOS 环境下对于其使用 g++ 进行编译，并且利用 objdump 得到汇编结果，通过重定向保存到 <code>main.s</code> 文件内：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -c main.cpp -std=c++14</span><br><span class="line">objdump -d -S main.o &gt; main.s</span><br></pre></td></tr></table></figure>
<p><a href="https://siskonemilia.github.io/Leetcode/Leetcode-41-First-Missing-Positive/macasm1.s">g++ on MacOS 汇编：solve1</a></p>
<p><a href="https://siskonemilia.github.io/Leetcode/Leetcode-41-First-Missing-Positive/macasm2.s">g++ on MacOS 汇编：solve2</a></p>
<p>然而结果依旧如故——二者几乎是完全一样的！至此我就拿它毫无办法了……根据网上查询的结果推测，可能是空间高度受限的情况下，生命周期长的 <code>index</code> 导致了高速缓冲数据的频繁不命中，但是这个说法依旧有很多问题……希望哪位大佬能够不吝赐教。</p>
<p>附上完整的汇编代码（macos）：</p>
<p><a href="https://siskonemilia.github.io/Leetcode/Leetcode-41-First-Missing-Positive/main.s">g++ on MacOS 汇编</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Leetcode/Leetcode-41-First-Missing-Positive/" data-id="cjmjc48w4002j7ors7gj3i4lq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/">Leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Get-Started-with-Unity3D-8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Unity3D/Get-Started-with-Unity3D-8/" class="article-date">
  <time datetime="2018-06-26T13:38:35.000Z" itemprop="datePublished">2018-06-26</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Unity3D/Get-Started-with-Unity3D-8/">Get Started with Unity3D - 8</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="网络对战-天际赛车"><a href="#网络对战-天际赛车" class="headerlink" title="网络对战-天际赛车"></a>网络对战-天际赛车</h2><p>经历了一个学期的各种学习，我们今天终于迎来了 Unity 制作网游的重要一步——网络模块。网络模块的存在使得游戏可以随时变身客户端／服务端，并且让多人共同进行游戏——没有什么比分享更能让人快乐的了！那么这次我们制作的是《天际赛车》，玩家将驾驶飞行器和同伴一起穿过圆环，争取分数！单人预览：</p>
<img src="/Unity3D/Get-Started-with-Unity3D-8/GIF.gif" title="preview">
        
          <p class="article-more-link">
            <a href="/Unity3D/Get-Started-with-Unity3D-8/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Unity3D/Get-Started-with-Unity3D-8/" data-id="cjmjc48vz002g7orsin49zkcs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/">Unity3D</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Get-Started-with-Unity3D-7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Unity3D/Get-Started-with-Unity3D-7/" class="article-date">
  <time datetime="2018-06-19T13:42:42.000Z" itemprop="datePublished">2018-06-19</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Unity3D/Get-Started-with-Unity3D-7/">Get Started with Unity3D - 7</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="坦克大战-人工智障版"><a href="#坦克大战-人工智障版" class="headerlink" title="坦克大战 - 人工智障版"></a>坦克大战 - 人工智障版</h2><p><a href="http://www.chenxd59.cn/?p=213" target="_blank" rel="noopener">参考博客</a></p>
<p><a href="https://www.bilibili.com/video/av25222632/" target="_blank" rel="noopener">B站视频</a></p>
<p>游戏预览：</p>
        
          <p class="article-more-link">
            <a href="/Unity3D/Get-Started-with-Unity3D-7/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Unity3D/Get-Started-with-Unity3D-7/" data-id="cjmjc48vu002d7orshdu18vcb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/">Unity3D</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Get-Started-with-Unity3D-6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Unity3D/Get-Started-with-Unity3D-6/" class="article-date">
  <time datetime="2018-06-05T16:33:14.000Z" itemprop="datePublished">2018-06-06</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Unity3D/Get-Started-with-Unity3D-6/">Get Started with Unity3D - 6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="天色天歌天音-Unity-换装游戏"><a href="#天色天歌天音-Unity-换装游戏" class="headerlink" title="天色天歌天音 - Unity 换装游戏"></a>天色天歌天音 - Unity 换装游戏</h2><p><a href="https://www.bilibili.com/video/av24432762/" target="_blank" rel="noopener">B站视频</a></p>
<p>注：视频有声音，请开大音量食用。</p>
<p>游戏预览：</p>
<img src="/Unity3D/Get-Started-with-Unity3D-6/GIF.gif" title="preview">
        
          <p class="article-more-link">
            <a href="/Unity3D/Get-Started-with-Unity3D-6/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Unity3D/Get-Started-with-Unity3D-6/" data-id="cjmjc48uf00057ors4hbcr7of" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/">Unity3D</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Get-Started-with-Unity3D-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Unity3D/Get-Started-with-Unity3D-5/" class="article-date">
  <time datetime="2018-05-28T15:35:31.000Z" itemprop="datePublished">2018-05-28</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Unity3D/Get-Started-with-Unity3D-5/">Get Started with Unity3D - 5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Escape-with-Unity-Chan-v2-0"><a href="#Escape-with-Unity-Chan-v2-0" class="headerlink" title="Escape with Unity-Chan v2.0 !"></a>Escape with Unity-Chan v2.0 !</h2><p><a href="https://www.bilibili.com/video/av23296354/" target="_blank" rel="noopener">B站视频</a></p>
<p><strong>和Unity酱逃出生天第二弹！</strong> 这次Unity酱来到了精灵森林，在本次游戏中，你将看到环绕着Unity酱上下飞舞的光精灵，在森林中驻足的水精灵和火精灵……以及动听的背景音乐！</p>
<p>效果预览：</p>
<img src="/Unity3D/Get-Started-with-Unity3D-5/1.gif" title="preview">
        
          <p class="article-more-link">
            <a href="/Unity3D/Get-Started-with-Unity3D-5/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Unity3D/Get-Started-with-Unity3D-5/" data-id="cjmjc48uc00037ors10a42esg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/">Unity3D</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Service-Computing/">Service Computing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tips/">Tips</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unity3D/">Unity3D</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB-Assignments/">WEB Assignments</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cloud-Service/">Cloud Service</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github-Pages/">Github Pages</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitment/">Gitment</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Remote-Floder/">Remote Floder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Service-Computing/">Service Computing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity3D/">Unity3D</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VPS-server/">VPS server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/">Windows</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/Cloud-Service/" style="font-size: 10px;">Cloud Service</a> <a href="/tags/Github-Pages/" style="font-size: 10px;">Github Pages</a> <a href="/tags/Gitment/" style="font-size: 10px;">Gitment</a> <a href="/tags/JavaScript/" style="font-size: 12.5px;">JavaScript</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Remote-Floder/" style="font-size: 10px;">Remote Floder</a> <a href="/tags/Service-Computing/" style="font-size: 10px;">Service Computing</a> <a href="/tags/Unity3D/" style="font-size: 20px;">Unity3D</a> <a href="/tags/VPS-server/" style="font-size: 10px;">VPS server</a> <a href="/tags/WEB/" style="font-size: 17.5px;">WEB</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/Leetcode/Leetcode-685-Redundant-Connection-II/">Leetcode 685. Redundant Connection II</a>
          </li>
        
          <li>
            <a href="/Tips/Make-Full-Use-of-Your-VPS-Server/">Make Full Use of Your VPS Server</a>
          </li>
        
          <li>
            <a href="/Leetcode/Leetcode-124-Binary-Tree-Maximum-Path-Sum/">Leetcode 124. Binary Tree Maximum Path Sum</a>
          </li>
        
          <li>
            <a href="/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/">Leetcode 4. Median of Two Sorted Arrays</a>
          </li>
        
          <li>
            <a href="/Service-Computing/Service-Computing-01-Private-Cloud-Service/">Service Computing 01 - Private Cloud Service</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Emilia<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a><br>
      <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_uv"> 
          Visitors: <span id="busuanzi_value_site_uv">loading...</span>
      </span>
    </div>
  </div>
  
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>