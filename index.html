<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Coding.Siskon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Coding.Siskon">
<meta property="og:url" content="https://siskonemilia.github.io/index.html">
<meta property="og:site_name" content="Coding.Siskon">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coding.Siskon">
  
    <link rel="alternate" href="/atom.xml" title="Coding.Siskon" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Coding.Siskon</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Simple Blog of SiskonEmilia</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://siskonemilia.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Golang-CLI-Program-Selpg" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Service-Computing/Golang-CLI-Program-Selpg/" class="article-date">
  <time datetime="2018-10-07T15:23:48.000Z" itemprop="datePublished">2018-10-07</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Service-Computing/">Service Computing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Service-Computing/Golang-CLI-Program-Selpg/">Service Computing 02 - Golang CLI Program - Selpg</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- TOC -->
<ul>
<li><a href="#设计说明">设计说明</a><ul>
<li><a href="#包引用">包引用</a></li>
<li><a href="#初始化">初始化</a></li>
<li><a href="#标识参数预处理">标识、参数预处理</a></li>
<li><a href="#接受输入数据">接受输入数据</a></li>
<li><a href="#数据处理">数据处理</a></li>
<li><a href="#输出结果">输出结果</a></li>
</ul>
</li>
<li><a href="#使用方法">使用方法</a><ul>
<li><a href="#安装程序">安装程序</a></li>
<li><a href="#使用范例和参数说明">使用范例和参数说明</a><ul>
<li><a href="#必需参数-snumber-enumber">必需参数：-sNumber，-eNumber</a></li>
<li><a href="#互斥的可选参数-lnumber-f">互斥的可选参数：-lNumber，-f</a></li>
<li><a href="#可选参数-ddestination">可选参数：-dDestination</a></li>
<li><a href="#可选参数file_name">可选参数：file_name</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#测试">测试</a><ul>
<li><a href="#生成测试文件">生成测试文件</a></li>
<li><a href="#测试与结果">测试与结果</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="设计说明"><a href="#设计说明" class="headerlink" title="设计说明"></a>设计说明</h2><p>本程序参照 <a href="https://www.ibm.com/developerworks/cn/linux/shell/clutil/index.html" target="_blank" rel="noopener">开发 Linux 命令行实用程序</a> 的设计，以 go 语言替代 C 语言构建。下面我们分版块来讲解实现。<a href="https://github.com/SiskonEmilia/Selpg/blob/master/selpg.go" target="_blank" rel="noopener">完整源代码</a></p>
<h3 id="包引用"><a href="#包引用" class="headerlink" title="包引用"></a>包引用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line">	flag <span class="string">"github.com/spf13/pflag"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在这一部分，我们声明了程序所要用到的所有包：</p>
<ul>
<li><code>bufio</code>：用于从标准输入流获取数据和将数据写入到标准输出流</li>
<li><code>io</code>：用于引用 <code>io.EOF</code> 来判断错误是否是文件尾导致</li>
<li><code>log</code>：用于将错误信息写入到标准错误流</li>
<li><code>os</code>：用于打开文件和异常退出时发送状态码</li>
<li><code>os/exec</code>：用于开启 <code>lp</code> 子进程</li>
<li><code>strings</code>：用于划分、拼接字符串</li>
<li><code>github.com/spf13/pflag</code>：用于获取程序运行时用户输入的参数和标识</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initializing //</span></span><br><span class="line">startNumber := flag.IntP(<span class="string">"startpage"</span>, <span class="string">"s"</span>, <span class="number">0</span>, <span class="string">"The page to start printing at [Necessary, no greater than endpage]"</span>)</span><br><span class="line">endNumber := flag.IntP(<span class="string">"endpage"</span>, <span class="string">"e"</span>, <span class="number">0</span>, <span class="string">"The page to end printing at [Necessary, no less than startpage]"</span>)</span><br><span class="line">lineNumber := flag.IntP(<span class="string">"linenumber"</span>, <span class="string">"l"</span>, <span class="number">72</span>, <span class="string">"If this flag is used, a page will consist of a fixed number of characters, which is given by you"</span>)</span><br><span class="line">forcePage := flag.BoolP(<span class="string">"forcepaging"</span>, <span class="string">"f"</span>, <span class="literal">false</span>, <span class="string">"Change page only if '-f' appears [Cannot be used with -l]"</span>)</span><br><span class="line">destinationPrinter := flag.StringP(<span class="string">"destination"</span>, <span class="string">"d"</span>, <span class="string">""</span>, <span class="string">"Choose a printer to accept the result as a task"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// StdErr printer //</span></span><br><span class="line">l := log.New(os.Stderr, <span class="string">""</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Data holder //</span></span><br><span class="line">bytes := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">65535</span>)</span><br><span class="line"><span class="keyword">var</span> data <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> resultData <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">flag.Parse()</span><br></pre></td></tr></table></figure>
<p>在这个部分，我们进行了初始化操作。这包括对于 <code>pflag</code> 中各个标识的设置和变量绑定，标准错误流的绑定，缓冲区 <code>bytes</code> 的创建，读入数据变量、结果数据变量的创建。</p>
<p>在完成这些设置后，我们通过 <code>flag.Parse()</code> 方法使得 <code>pflag</code> 执行对于标识和参数的解析。</p>
<h3 id="标识、参数预处理"><a href="#标识、参数预处理" class="headerlink" title="标识、参数预处理"></a>标识、参数预处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Are necessary flags given? //</span></span><br><span class="line"><span class="keyword">if</span> *startNumber == <span class="number">0</span> || *endNumber == <span class="number">0</span> &#123;</span><br><span class="line">  l.Println(<span class="string">"Necessary flags are not given!"</span>)</span><br><span class="line">  flag.Usage()</span><br><span class="line">  os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Are flags value valid? //</span></span><br><span class="line"><span class="keyword">if</span> (*startNumber &gt; *endNumber) || *startNumber &lt; <span class="number">0</span> || *endNumber &lt; <span class="number">0</span> || *lineNumber &lt;= <span class="number">0</span> &#123;</span><br><span class="line">  l.Println(<span class="string">"Invalid flag values!"</span>)</span><br><span class="line">  flag.Usage()</span><br><span class="line">  os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Are lineNumber and forcePage set at the same time? //</span></span><br><span class="line"><span class="keyword">if</span> *lineNumber != <span class="number">72</span> &amp;&amp; *forcePage &#123;</span><br><span class="line">  l.Println(<span class="string">"Linenumber and forcepaging cannot be set at the same time!"</span>)</span><br><span class="line">  flag.Usage()</span><br><span class="line">  os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Too many arguments? //</span></span><br><span class="line"><span class="keyword">if</span> flag.NArg() &gt; <span class="number">1</span> &#123;</span><br><span class="line">  l.Println(<span class="string">"Too many arguments!"</span>)</span><br><span class="line">  flag.Usage()</span><br><span class="line">  os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这部分，我们检验了所有标识的合法性，这包括：</p>
<ul>
<li>必须的标识，<code>-s</code> 和 <code>-e</code> 是否被设置？</li>
<li>标识是否具有一个合法的值</li>
<li>互斥的参数，也就是通过行数分页和通过分页符分页，是否被同时设置</li>
<li>参数数量是否过多</li>
</ul>
<p>如果任何不合法的参数被使用，那么我们向标准错误流输出错误信息，打印正确使用方法，然后退出程序（并返回一个通用的错误状态码）。</p>
<h3 id="接受输入数据"><a href="#接受输入数据" class="headerlink" title="接受输入数据"></a>接受输入数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StdIn or File? //</span></span><br><span class="line"><span class="keyword">if</span> flag.NArg() == <span class="number">0</span> &#123;</span><br><span class="line">  <span class="comment">// StdIn condition //</span></span><br><span class="line">  reader := bufio.NewReader(os.Stdin)</span><br><span class="line"></span><br><span class="line">  size, err := reader.Read(bytes)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> size != <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">    data = data + <span class="keyword">string</span>(bytes)</span><br><span class="line">    size, err = reader.Read(bytes)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Error</span></span><br><span class="line">  <span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">    l.Println(<span class="string">"Error occured when reading from StdIn:\n"</span>, err.Error())</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// File condition //</span></span><br><span class="line">  file, err := os.Open(flag.Args()[<span class="number">0</span>]) <span class="comment">// TODO TEST: is PATH needed?</span></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    l.Println(<span class="string">"Error occured when opening file:\n"</span>, err.Error())</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read the whole file</span></span><br><span class="line">  size, err := file.Read(bytes)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> size != <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">    data = data + <span class="keyword">string</span>(bytes)</span><br><span class="line">    size, err = file.Read(bytes)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Error</span></span><br><span class="line">  <span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">    l.Println(<span class="string">"Error occured when reading file:\n"</span>, err.Error())</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一部分，我们判断输入方式，并且将数据读入并写在 <code>data</code> 变量中。</p>
<p>对于 <strong>标准输入</strong> 的模式，也就是没有额外参数的情况：我们首先通过 <code>bufio.NewReader(os.Stdin)</code> 创建一个绑定到标准输入流的读者，然后通过它向缓冲区 <code>bytes</code> 读入数据，并且将其转换为字符串并写入到 <code>data</code> 中。由于缓冲区的大小限制，这个读入过程可能需要进行多次，因而我们迭代该过程，直到确保读完了标准输入流的数据（也就是该次读入没有读入到数据，即 <code>size = 0</code>）为止。在读入遇到错误时，我们输出错误信息，并且退出程序。</p>
<p>对于 <strong>文件输入</strong> 的模式，也就是有一个参数的情况：我们首先通过 <code>os.Open()</code> 打开文件。在没有错误的情况下，我们通过 <code>file.Read()</code> 迭代地从中读入数据，直到完成读取。如果我们在整个过程中遇到错误，那么输出错误信息，并且退出程序。</p>
<p>在完成这一个部分的处理后，我们的数据信息就存储在了 <code>data</code> 变量中。</p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LineNumber or ForcePaging? //</span></span><br><span class="line"><span class="keyword">if</span> *forcePage &#123;</span><br><span class="line">  <span class="comment">// ForcePaging //</span></span><br><span class="line">  pagedData := strings.SplitAfter(data, <span class="string">"\f"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pagedData) &lt; *endNumber &#123;</span><br><span class="line">    l.Println(<span class="string">"Invalid flag values! Too large endNumber!"</span>)</span><br><span class="line">    flag.Usage()</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resultData = strings.Join(pagedData[*startNumber<span class="number">-1</span>:*endNumber+<span class="number">1</span>], <span class="string">""</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// LineNumber //</span></span><br><span class="line">  lines := strings.SplitAfter(data, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(lines) &lt; (*endNumber<span class="number">-1</span>)*(*lineNumber)+<span class="number">1</span> &#123;</span><br><span class="line">    l.Println(<span class="string">"Invalid flag values! Too large endNumber!"</span>)</span><br><span class="line">    flag.Usage()</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(lines) &lt; *endNumber*(*lineNumber) &#123;</span><br><span class="line">    resultData = strings.Join(lines[(*startNumber)*(*lineNumber)-(*lineNumber):<span class="built_in">len</span>(lines)], <span class="string">""</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resultData = strings.Join(lines[(*startNumber)*(*lineNumber)-(*lineNumber):(*endNumber)*(*lineNumber)], <span class="string">""</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这部分，我们对存储在 <code>data</code> 里的字符串进行处理，以满足用户要求。这部分根据分页过程的不同分为两种：按分页符分页和按行分页。</p>
<p>在按 <strong>分页符分页</strong> 的情况下，我们通过 <code>strings.SplitAfter()</code> 方法来将字符串以 <code>&#39;\f&#39;</code> 为界分为数个段，每一段即是一页，然后我们根据用户输入的开始页码和结束页码将相应的数据写入 <code>resultData</code> 中。</p>
<p>在 <strong>按行数分页</strong> 的情况下，我们首先以 <code>&#39;\n&#39;</code> 为界将字符串分段，然后根据开始页码和结束页码计算出开始行和结束行，并将其间数据写入 <code>resultData</code> 中。</p>
<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">writer := bufio.NewWriter(os.Stdout)</span><br><span class="line"></span><br><span class="line"><span class="comment">// StdOut or Printer? //</span></span><br><span class="line"><span class="keyword">if</span> *destinationPrinter == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="comment">// StdOut //</span></span><br><span class="line">  fmt.Printf(<span class="string">"%s"</span>, resultData)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Printer //</span></span><br><span class="line">  cmd := exec.Command(<span class="string">"lp"</span>, <span class="string">"-d"</span>+*destinationPrinter)</span><br><span class="line">  lpStdin, err := cmd.StdinPipe()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    l.Println(<span class="string">"Error occured when trying to send data to lp:\n"</span>, err.Error())</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> lpStdin.Close()</span><br><span class="line">    io.WriteString(lpStdin, resultData)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  out, err := cmd.CombinedOutput()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    l.Println(<span class="string">"Error occured when sending data to lp:\n"</span>, err.Error())</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _, err = writer.Write(out)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    l.Println(<span class="string">"Error occured when writing information to StdOut:\n"</span>, err.Error())</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这部分，我们以输出方式的不同分为两类：直接输出到标准输出流的和将数据传送给 <code>lp</code> 进行打印工作的。由于二者实际上都需要用到标准输出流（后者是要输出 <code>lp</code> 的信息），所以我们首先创建了与标准输出流绑定的 <code>Writer</code>：<code>writer</code>。</p>
<p>对于直接输出到标准输出流的，我们直接通过 <code>Writer.Write()</code> 方法将转换为 byte 切片的字符串输出即可。</p>
<p>而对于输出到 <code>lp</code> 的，我们首先通过 <code>exec.Command()</code> 创建一个 <code>lp</code> 的子进程，并且通过 <code>cmd.StdinPipe()</code> 获取和其标准输入绑定的管道，然后将数据送入管道即可。同时，我们也需要将 <code>lp</code> 指令的输出转发到标准输出流上，方便用户查看。</p>
<p>在这期间对于错误的处理依旧和前文相同：输出错误并退出程序。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>使用方法基本同 C 版本的 <code>selpg</code>。</p>
<h3 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h3><p>在配置好 golang 环境的前提下，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/siskonemilia/selpg</span><br></pre></td></tr></table></figure>
<p>若成功执行（无回显），则安装成功。</p>
<h3 id="使用范例和参数说明"><a href="#使用范例和参数说明" class="headerlink" title="使用范例和参数说明"></a>使用范例和参数说明</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selpg -sNumber -eNumber [-lNumber/-f] [-dDestination] [file_name]</span><br></pre></td></tr></table></figure>
<h4 id="必需参数：-sNumber，-eNumber"><a href="#必需参数：-sNumber，-eNumber" class="headerlink" title="必需参数：-sNumber，-eNumber"></a>必需参数：-sNumber，-eNumber</h4><p><code>selpg</code> 要求用户用两个命令行参数“-sNumber”（例如，“-s10”表示从第 10 页开始）和“-eNumber”（例如，“-e20”表示在第 20 页结束）指定要抽取的页面范围的起始页和结束页。<code>selpg</code> 对所给的页号进行合理性检查；换句话说，它会检查两个数字是否为有效的正整数以及结束页是否不小于起始页。两者是程序执行所必需的。</p>
<h4 id="互斥的可选参数：-lNumber，-f"><a href="#互斥的可选参数：-lNumber，-f" class="headerlink" title="互斥的可选参数：-lNumber，-f"></a>互斥的可选参数：-lNumber，-f</h4><p>selpg 可以处理两种输入文本：</p>
<p><strong>类型 1</strong>：该类文本的页行数固定。这是缺省类型，因此不必给出选项进行说明。也就是说，如果既没有给出“-lNumber”也没有给出“-f”选项，则 <code>selpg</code> 会理解为页有固定的长度（每页 72 行）。例如：</p>
<pre><code>selpg -s10 -e20 -l66
</code></pre><p><strong>类型 2</strong>：该类型文本的页由 ASCII 换页字符（十进制数值为 12，在 C 中用“\f”表示）定界。该格式与“每页行数固定”格式相比的好处在于，当每页的行数有很大不同而且文件有很多页时，该格式可以节省磁盘空间。在含有文本的行后面，类型 2 的页只需要一个字符 ― 换页 ― 就可以表示该页的结束。打印机会识别换页符并自动根据在新的页开始新行所需的行数移动打印头。例如：</p>
<pre><code>selpg -s10 -e20 -f 
</code></pre><h4 id="可选参数：-dDestination"><a href="#可选参数：-dDestination" class="headerlink" title="可选参数：-dDestination"></a>可选参数：-dDestination</h4><p><code>selpg</code> 还允许用户使用“-dDestination”选项将选定的页直接发送至打印机。这里，“Destination”应该是 lp 命令“-d”选项（请参阅“man lp”）可接受的打印目的地名称。该目的地应该存在 ― <code>selpg</code> 不检查这一点。在运行了带“-d”选项的 <code>selpg</code> 命令后，若要验证该选项是否已生效，请运行命令“lpstat -t”。该命令应该显示添加到“Destination”打印队列的一项打印作业。如果当前有打印机连接至该目的地并且是启用的，则打印机应打印该输出。</p>
<h4 id="可选参数：file-name"><a href="#可选参数：file-name" class="headerlink" title="可选参数：file_name"></a>可选参数：file_name</h4><p>如果没有给出 file_name，那么 <code>selpg</code> 将从标准输入流读取数据进行处理，否则，<code>selpg</code> 将根据文件名寻找相应文件，并从中读取数据进行处理。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>该部分参照 <a href="https://www.ibm.com/developerworks/cn/linux/shell/clutil/index.html#6" target="_blank" rel="noopener">使用 selpg</a> 进行程序测试。</p>
<h3 id="生成测试文件"><a href="#生成测试文件" class="headerlink" title="生成测试文件"></a>生成测试文件</h3><p>为了使得实验结果直观易懂，我们采用固定的程序生成的输入文件进行测试，生成程序如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input_file_generator.sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..7200&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> &gt;&gt; input_file</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>其生成的结果是一个由 1 到 7200 的，步长为 1 的等差数列，且每行一个数字。即是说，每一行的数字都是该行的编号。</p>
<h3 id="测试与结果"><a href="#测试与结果" class="headerlink" title="测试与结果"></a>测试与结果</h3><ol>
<li><p>把 <code>input_file</code> 的第 1 页写至标准输出</p>
<pre><code>$selpg -s1 -e1 input_file
</code></pre><p> 结果：</p>
<pre><code>1
2
...
72
</code></pre></li>
<li><p><code>selpg</code> 读取标准输入，而标准输入已被 shell 重定向为来自 <code>input_file</code> 而不是显式命名的文件名参数。输入的第 1 页被写至屏幕</p>
<pre><code>$ selpg -s1 -e1 &lt; input_file
</code></pre><p> 结果：</p>
<pre><code>1
2
...
72
</code></pre></li>
<li><p><code>cat</code> 的标准输出被 shell／内核重定向至 selpg 的标准输入。将第 10 页到第 20 页写至 selpg 的标准输出</p>
<pre><code>$ cat input_file | selpg -s10 -e20
</code></pre><p> 结果：</p>
<pre><code>649
650
...
1440
</code></pre></li>
<li><p><code>selpg</code> 将第 10 页到第 20 页写至标准输出（屏幕）；所有的错误消息被 shell 重定向至 <code>error_file</code></p>
<pre><code>$ selpg -s10 -e20 input_file 2&gt;error_file
</code></pre><p> 结果：</p>
<pre><code>649
650
...
1440
</code></pre><p> <code>error_file</code>: 无内容</p>
</li>
<li><p><code>selpg</code> 将第 10 页到第 20 页写至标准输出；标准输出被 shell 重定向至 <code>res</code></p>
<pre><code>$selpg -s10 -e20 input_file &gt;res
</code></pre><p> 结果（res文件内容）：</p>
<pre><code>649
650
...
1440
</code></pre></li>
<li><p><code>selpg</code> 将第 10 页到第 20 页写至标准输出，标准输出被重定向至 <code>res</code>，<code>selpg</code> 写至标准错误的所有内容都被重定向至 <code>error_file</code></p>
<pre><code>$selpg -s10 -e20 input_file &gt;res 2&gt;error_file
</code></pre><p> 结果（res文件内容）：</p>
<pre><code>649
650
...
1440
</code></pre><p> <code>error_file</code>: 无内容</p>
</li>
<li><p><code>selpg</code> 的标准输出透明地被 shell 重定向，成为 <code>cat</code> 的标准输入，第 10 页到第 20 页被写至该标准输入</p>
<pre><code>$ selpg -s10 -e20 input_file | cat
</code></pre><p> 结果：</p>
<pre><code>649
650
...
1440
</code></pre></li>
<li><p>将页长设置为 66 行，这样 <code>selpg</code> 就可以把输入当作被定界为该长度的页那样处理。第 10 页到第 20 页被写至 <code>selpg</code> 的标准输出</p>
<pre><code>$ selpg -s10 -e20 -l66 input_file
</code></pre><p> 结果：</p>
<pre><code>595
596
...
1320
</code></pre></li>
<li><p>假定页由换页符定界。第 10 页到第 20 页被写至 <code>selpg</code> 的标准输出</p>
<pre><code>$ selpg -s10 -e20 -f input_file
</code></pre><p> 结果（输入文件没有换页符，所以只有一页）：</p>
<pre><code>Invalid flag values! Too large endNumber!
Usage of selpg:
-d, --destination string   Choose a printer to accept the result as a task
-e, --endpage int          The page to end printing at [Necessary, no less than startpage]
-f, --forcepaging          Change page only if &apos;-f&apos; appears [Cannot be used with -l]
-l, --linenumber int       If this flag is used, a page will consist of a fixed number of characters, which is given by you (default 72)
-s, --startpage int        The page to start printing at [Necessary, no greater than endpage]
</code></pre></li>
<li><p>第 10 页到第 20 页由管道输送至命令 <code>lp -dlp1</code>，该命令将使输出在打印机 lp1 上打印</p>
<pre><code>$ selpg -s10 -e20 -dlp1 input_file
</code></pre><p> 结果（因为没有打印机）：</p>
<pre><code>Error occured when sending data to lp:
exit status 1
</code></pre></li>
</ol>
<p>经测试，程序运行符合预期，工作正常。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Service-Computing/Golang-CLI-Program-Selpg/" data-id="cjn6rnst0002jwnxme76kdufa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/">Golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Service-Computing/">Service Computing</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode-839-Similar-String-Groups" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Leetcode/Leetcode-839-Similar-String-Groups/" class="article-date">
  <time datetime="2018-10-06T10:52:31.000Z" itemprop="datePublished">2018-10-06</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Leetcode/Leetcode-839-Similar-String-Groups/">Leetcode 839. Similar String Groups</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="839-Similar-String-Groups"><a href="#839-Similar-String-Groups" class="headerlink" title="839. Similar String Groups"></a>839. Similar String Groups</h3><p>Two strings <code>X</code> and <code>Y</code> are similar if we can swap two letters (in different positions) of X, so that it equals Y.</p>
<p>For example, <code>&quot;tars&quot;</code> and <code>&quot;rats&quot;</code> are similar (swapping at positions 0 and 2), and <code>&quot;rats&quot;</code> and <code>&quot;arts&quot;</code> are similar, but <code>&quot;star&quot;</code> is not similar to <code>&quot;tars&quot;</code>, <code>&quot;rats&quot;</code>, or <code>&quot;arts&quot;</code>.</p>
<p>Together, these form two connected groups by similarity: <code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> and <code>{&quot;star&quot;}</code>.  Notice that <code>&quot;tars&quot;</code> and <code>&quot;arts&quot;</code> are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.</p>
<p>We are given a list <code>A</code> of strings.  Every string in <code>A</code> is an anagram of every other string in <code>A</code>.  How many groups are there?</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]
Output: 2
</code></pre><p><strong>Note:</strong></p>
<ol>
<li><code>A.length &lt;= 2000</code></li>
<li><code>A[i].length &lt;= 1000</code></li>
<li><code>A.length * A[i].length &lt;= 20000</code></li>
<li>All words in <code>A</code> consist of lowercase letters only.</li>
<li>All words in <code>A</code> have the same length and are anagrams of each other.</li>
<li>The judging time limit has been increased for this question.</li>
</ol>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="AC-截图"><a href="#AC-截图" class="headerlink" title="AC 截图"></a>AC 截图</h3><img src="/Leetcode/Leetcode-839-Similar-String-Groups/solve3.png" title="Preview">
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>对于任意两个字符串，若其中一个能够由另一个字符串通过交换字符串中两个字符的位置来得到，那么就称二者 <strong>相似</strong>。我们将这种相似关系视作而两个字符串间有一条边连通。如此以来，我们构建了一个由字符串作为节点，以相似关系作为边的无向图。本题的问题就是该无向图中存在几个连通分量。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>此类连通性问题一般可以通过两种方法求解。一种是遍历，即是通过 <strong>深度优先搜索</strong> 或者 <strong>广度优先搜索</strong> 来发现每一个连通分量。另一种是通过 <strong>并查集</strong> 来构建连通分量。在这里，我们首先考虑通过遍历求解（我们选取的是深度优先搜索），但是很不幸……</p>
<h3 id="超时题解"><a href="#超时题解" class="headerlink" title="超时题解"></a>超时题解</h3><h4 id="结果截图"><a href="#结果截图" class="headerlink" title="结果截图"></a>结果截图</h4><img src="/Leetcode/Leetcode-839-Similar-String-Groups/TLE.png" title="Preview">
<h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> runfirst = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> group[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// string size</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    size = A[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">return</span> traverseMethod(A);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">traverseMethod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; unvisitedStrings(A.begin(), A.end());</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; toVisit;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!unvisitedStrings.empty()) &#123;</span><br><span class="line">      <span class="comment">// Push the first string into the queue //</span></span><br><span class="line">      ++result;</span><br><span class="line">      toVisit.push(*unvisitedStrings.begin());</span><br><span class="line">      unvisitedStrings.erase(unvisitedStrings.begin());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Find the connected component //</span></span><br><span class="line">      <span class="keyword">while</span> (!toVisit.empty()) &#123;</span><br><span class="line">        <span class="comment">// Get the front string //</span></span><br><span class="line">        string toTest(toVisit.front());</span><br><span class="line">        toVisit.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Traverse all possible results from toVisit.front() //</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> t = i + <span class="number">1</span>; t &lt; size; ++t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (toTest[i] != toTest[t]) &#123;</span><br><span class="line">              swap(toTest[i], toTest[t]);</span><br><span class="line">              <span class="keyword">if</span> (unvisitedStrings.count(toTest)) &#123;</span><br><span class="line">                toVisit.push(toTest);</span><br><span class="line">                unvisitedStrings.erase(toTest);</span><br><span class="line">                <span class="keyword">if</span> (unvisitedStrings.empty()) <span class="keyword">return</span> result;</span><br><span class="line">              &#125;</span><br><span class="line">              swap(toTest[i], toTest[t]);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>遍历算法虽然简单，但是其时间复杂度非常高。以上面的实现为例，其时间复杂度高达 <code>O(size * size * length * log(length))</code>，对于像结果截图中那样超长的字符串显然就无能为力地超时了。因而我们考虑使用并查集方法：</p>
<h3 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h3><h4 id="结果截图-1"><a href="#结果截图-1" class="headerlink" title="结果截图"></a>结果截图</h4><img src="/Leetcode/Leetcode-839-Similar-String-Groups/solve1.png" title="Preview">
<h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> runfirst = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> group[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// string size</span></span><br><span class="line">  <span class="keyword">int</span> length; <span class="comment">// vector length</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    size = A[<span class="number">0</span>].size();</span><br><span class="line">    length = A.size();</span><br><span class="line">    <span class="keyword">return</span> unionFindingMethod(A);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findGroup</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group[index] == index) <span class="keyword">return</span> index;</span><br><span class="line">    <span class="keyword">return</span> group[index] = findGroup(group[index]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isSimilar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> different = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str1[i] != str2[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (different &gt; <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ++different;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">unionFindingMethod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    length = A.size();</span><br><span class="line">    <span class="comment">// int groupI, groupT;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Initially, each node belongs to its own group //</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) group[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = i + <span class="number">1</span>; t &lt; length; ++t) &#123;</span><br><span class="line">        <span class="comment">// groupI = findGroup(i);</span></span><br><span class="line">        <span class="comment">// groupT = findGroup(t);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSimilar(A[i], A[t])) &#123;</span><br><span class="line">          group[findGroup(i)] = findGroup(t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">      result += (group[i] == i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h4><p>虽然并查集方法在规定的时间内成功通过了所有的测试样例，但是通过分析我们发现，其时间复杂度实际上是 <strong>O(length <em> length </em> size)</strong>，因而相对于遍历方法，并查集方法更适合于较大 <code>size</code> 的情景。注意到题目中的 <strong>Note</strong>，我们知道 <strong>size * length &lt;= 20000</strong>，因而对于较大的 <code>size</code>，其 <code>length</code> 则会较小，所以我们可以通过判断 <code>size</code> 的大小来决定使用哪种方法进行我们的查找。</p>
<h3 id="题解2（最优解）"><a href="#题解2（最优解）" class="headerlink" title="题解2（最优解）"></a>题解2（最优解）</h3><h4 id="结果截图-2"><a href="#结果截图-2" class="headerlink" title="结果截图"></a>结果截图</h4><img src="/Leetcode/Leetcode-839-Similar-String-Groups/solve2.png" title="Preview">
<h4 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> runfirst = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> group[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// string size</span></span><br><span class="line">  <span class="keyword">int</span> length; <span class="comment">// vector length</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    size = A[<span class="number">0</span>].size();</span><br><span class="line">    length = A.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">20</span>)</span><br><span class="line">      <span class="keyword">return</span> traverseMethod(A);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> unionFindingMethod(A);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findGroup</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group[index] == index) <span class="keyword">return</span> index;</span><br><span class="line">    <span class="keyword">return</span> group[index] = findGroup(group[index]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isSimilar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> different = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str1[i] != str2[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (different &gt; <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ++different;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">unionFindingMethod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    length = A.size();</span><br><span class="line">    <span class="comment">// int groupI, groupT;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Initially, each node belongs to its own group //</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) group[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = i + <span class="number">1</span>; t &lt; length; ++t) &#123;</span><br><span class="line">        <span class="comment">// groupI = findGroup(i);</span></span><br><span class="line">        <span class="comment">// groupT = findGroup(t);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSimilar(A[i], A[t])) &#123;</span><br><span class="line">          group[findGroup(i)] = findGroup(t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">      result += (group[i] == i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">traverseMethod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; unvisitedStrings(A.begin(), A.end());</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; toVisit;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!unvisitedStrings.empty()) &#123;</span><br><span class="line">      <span class="comment">// Push the first string into the queue //</span></span><br><span class="line">      ++result;</span><br><span class="line">      toVisit.push(*unvisitedStrings.begin());</span><br><span class="line">      unvisitedStrings.erase(unvisitedStrings.begin());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Find the connected component //</span></span><br><span class="line">      <span class="keyword">while</span> (!toVisit.empty()) &#123;</span><br><span class="line">        <span class="comment">// Get the front string //</span></span><br><span class="line">        string toTest(toVisit.front());</span><br><span class="line">        toVisit.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Traverse all possible results from toVisit.front() //</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> t = i + <span class="number">1</span>; t &lt; size; ++t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (toTest[i] != toTest[t]) &#123;</span><br><span class="line">              swap(toTest[i], toTest[t]);</span><br><span class="line">              <span class="keyword">if</span> (unvisitedStrings.count(toTest)) &#123;</span><br><span class="line">                toVisit.push(toTest);</span><br><span class="line">                unvisitedStrings.erase(toTest);</span><br><span class="line">                <span class="keyword">if</span> (unvisitedStrings.empty()) <span class="keyword">return</span> result;</span><br><span class="line">              &#125;</span><br><span class="line">              swap(toTest[i], toTest[t]);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="结果分析-2"><a href="#结果分析-2" class="headerlink" title="结果分析"></a>结果分析</h4><p>虽然我们对于 <code>size</code> 的判断一定程度上确定了 <code>length</code> 的大小，但是我们不能忽略 <code>size</code> 和 <code>length</code> 都较小的情况。因而我们加入对 <code>length</code> 的判断，从而超越了原本的最优解：</p>
<h3 id="Even-Better"><a href="#Even-Better" class="headerlink" title="Even Better"></a>Even Better</h3><h4 id="结果截图-3"><a href="#结果截图-3" class="headerlink" title="结果截图"></a>结果截图</h4><img src="/Leetcode/Leetcode-839-Similar-String-Groups/solve3.png" title="Preview">
<h4 id="C-代码-3"><a href="#C-代码-3" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> runfirst = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> group[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// string size</span></span><br><span class="line">  <span class="keyword">int</span> length; <span class="comment">// vector length</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    size = A[<span class="number">0</span>].size();</span><br><span class="line">    length = A.size();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">19</span> || length &lt; <span class="number">50</span>)</span><br><span class="line">      <span class="keyword">return</span> unionFindingMethod(A);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> traverseMethod(A);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findGroup</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group[index] == index) <span class="keyword">return</span> index;</span><br><span class="line">    <span class="keyword">return</span> group[index] = findGroup(group[index]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isSimilar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> different = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str1[i] != str2[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (different &gt; <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ++different;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">unionFindingMethod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    length = A.size();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Initially, each node belongs to its own group //</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) group[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = i + <span class="number">1</span>; t &lt; length; ++t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSimilar(A[i], A[t])) &#123;</span><br><span class="line">          group[findGroup(t)] = findGroup(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">      result += (group[i] == i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">traverseMethod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Time complexity: O(size * size * length * log(length))</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; unvisitedStrings(A.begin(), A.end());</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; toVisit;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!unvisitedStrings.empty()) &#123;</span><br><span class="line">      <span class="comment">// Push the first string into the queue //</span></span><br><span class="line">      ++result;</span><br><span class="line">      toVisit.push(*unvisitedStrings.begin());</span><br><span class="line">      unvisitedStrings.erase(unvisitedStrings.begin());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Find the connected component //</span></span><br><span class="line">      <span class="keyword">while</span> (!toVisit.empty()) &#123;</span><br><span class="line">        <span class="comment">// Get the front string //</span></span><br><span class="line">        string toTest(toVisit.front());</span><br><span class="line">        toVisit.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Traverse all possible results from toVisit.front() //</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> t = i + <span class="number">1</span>; t &lt; size; ++t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (toTest[i] != toTest[t]) &#123;</span><br><span class="line">              swap(toTest[i], toTest[t]);</span><br><span class="line">              <span class="keyword">if</span> (unvisitedStrings.count(toTest)) &#123;</span><br><span class="line">                toVisit.push(toTest);</span><br><span class="line">                unvisitedStrings.erase(toTest);</span><br><span class="line">                <span class="keyword">if</span> (unvisitedStrings.empty()) <span class="keyword">return</span> result;</span><br><span class="line">              &#125;</span><br><span class="line">              swap(toTest[i], toTest[t]);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Leetcode/Leetcode-839-Similar-String-Groups/" data-id="cjn6rnst4002vwnxmup0rufp1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/">Leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode-685-Redundant-Connection-II" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Leetcode/Leetcode-685-Redundant-Connection-II/" class="article-date">
  <time datetime="2018-09-26T14:11:15.000Z" itemprop="datePublished">2018-09-26</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Leetcode/Leetcode-685-Redundant-Connection-II/">Leetcode 685. Redundant Connection II</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="685-Redundant-Connection-II"><a href="#685-Redundant-Connection-II" class="headerlink" title="685. Redundant Connection II"></a>685. Redundant Connection II</h3><ul>
<li><strong>Difficulty:</strong> Hard</li>
<li><strong>Total Accepted:</strong> 11.2K</li>
<li><strong>Total Submissions:</strong> 39.7K</li>
</ul>
<p>In this problem, a rooted tree is a <strong>directed</strong> graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.</p>
<p>The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, …, N), with one additional directed edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</p>
<p>The resulting graph is given as a 2D-array of <code>edges</code>. Each element of <code>edges</code> is a pair <code>[u, v]</code> that represents a directed edge connecting nodes <code>u</code> and <code>v</code>, where <code>u</code> is a parent of child <code>v</code>.</p>
<p>Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [[1,2], [1,3], [2,3]]
Output: [2,3]
Explanation: The given directed graph will be like this:
  1
 / \
v   v
2--&gt;3
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [[1,2], [2,3], [3,4], [4,1], [1,5]]
Output: [4,1]
Explanation: The given directed graph will be like this:
5 &lt;- 1 -&gt; 2
     ^    |
     |    v
     4 &lt;- 3
</code></pre><p><strong>Note:</strong></p>
<ul>
<li>The size of the input 2D-array will be between 3 and 1000.</li>
<li>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</li>
</ul>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="AC-截图"><a href="#AC-截图" class="headerlink" title="AC 截图"></a>AC 截图</h3><img src="/Leetcode/Leetcode-685-Redundant-Connection-II/finalresult.png" title="FinalResult">
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>该问题给出一组有向图内的边，并且给出等同数量的节点，构成一个可以通过 <strong>删掉一条边</strong> 而成为 <strong>有根树</strong> 的有向图。在有多个答案时，输出最后出现的可用边。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题乍一看情况非常复杂，因为要从一个有向图转换为有根树，需要消除图中所有的回环，以及所有入度大于 1 的节点（后称「双源」节点）。但是冷静下来想想，题目其实已经给出了相当优厚的条件——<strong>只能删掉一条边</strong>。</p>
<p>根据这个条件，我们可以反推回输入数据的情况：该有向图只可能是下列三种情况的一种。</p>
<ul>
<li>有一个回环，没有「双源」节点</li>
<li>有一个「双源」节点，没有回环</li>
<li>有一个「双源」节点，并且该节点也在一个回环内</li>
</ul>
<p>考虑第一种情况，因为只删掉一条边就可以构成有根树，那么最后形成环的那条边，肯定就是我们要找的边，因而在扫描一边所有边的时候监控整个图的连通性即可，<strong>一旦发现成环，我们就删掉那条边</strong>。</p>
<p>考虑第二种情况，在没有回环的情况下，两条边可以 <strong>任意地删除</strong>，因而删除触发形成双源节点条件的边即可，因其相对位于集合的后部，处理方式同第一种。</p>
<p>考虑第三种情况，因为这个时候双源节点接入的两条边中有一条会参与成环，因而要同时解除成环和双源，我们只能 <strong>删掉参与成环和双源节点的唯一边</strong>。同时，为了保证不会漏掉这种重叠情况，在前两种情况的判定中，我们 <strong>不能在判定后立刻作出相应操作</strong>，而要等待整个边集合扫描完后再处理。</p>
<p>那么接下来，我们来考虑如何判定双源与回环的问题。</p>
<p>（这实际上是一个简化的 <strong>并查集</strong> 问题，有兴趣的同学可以了解一下）我们维护一个「祖先」数组，它标定整个图中每个节点的祖先。每当一条边由点 A 指向点 B 时，我们令点 B 的祖先为点 A 的祖先。这样，当一条边指向一个有祖先的节点时，就会发生「双源」；当一条边的两端祖先相同时，就会发生「回环」。</p>
<p>必须要考虑的是，当「双源」发生时，对双源节点的祖先查找可能引导向两个结果，如何对两个结果进行处理会是一个问题。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h3><h4 id="结果截图"><a href="#结果截图" class="headerlink" title="结果截图"></a>结果截图</h4><img src="/Leetcode/Leetcode-685-Redundant-Connection-II/midresult.png" title="MidResult">
<h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> runfirst = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> parent1, parent2;</span><br><span class="line">  <span class="keyword">int</span> subParent1, subParent2;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *doubleSourceEdge, *circularEdge;</span><br><span class="line">  <span class="keyword">int</span> doubleSourceNode;</span><br><span class="line">  <span class="keyword">int</span> subParent;</span><br><span class="line">  <span class="keyword">int</span> sameParent;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantDirectedConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = edges.size();</span><br><span class="line">    <span class="keyword">int</span> *parent = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> *father = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    doubleSourceEdge = circularEdge = <span class="literal">nullptr</span>;</span><br><span class="line">    doubleSourceNode = subParent = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">memset</span>(parent, <span class="number">0</span>, (size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter : edges) &#123;</span><br><span class="line">      <span class="keyword">if</span> (doubleSourceNode) &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp1 = findParentFork(parent, father, iter[<span class="number">0</span>]),</span><br><span class="line">          temp2 = findParentFork(parent, father, iter[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        parent1 = temp1[<span class="number">0</span>];</span><br><span class="line">        parent2 = temp2[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        subParent1 = temp1[<span class="number">1</span>];</span><br><span class="line">        subParent2 = temp2[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        parent1 = findParent(parent, iter[<span class="number">0</span>]);</span><br><span class="line">        parent2 = findParent(parent, iter[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (parent[iter[<span class="number">1</span>]]) &#123;</span><br><span class="line">        <span class="comment">// Double source</span></span><br><span class="line">        <span class="keyword">if</span> (parent1 == parent2) &#123;</span><br><span class="line">          <span class="keyword">return</span> iter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (circularEdge) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;father[iter[<span class="number">1</span>]], iter[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          doubleSourceNode = iter[<span class="number">1</span>];</span><br><span class="line">          doubleSourceEdge = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;father[iter[<span class="number">1</span>]], iter[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subParent = parent2;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (doubleSourceNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sameParent = parent1) == parent2 || (sameParent = parent1) == subParent2 || (sameParent = parent2) == subParent1) &#123;</span><br><span class="line">          <span class="keyword">if</span> (findParent(parent, doubleSourceNode) == sameParent) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;father[doubleSourceNode], doubleSourceNode&#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *doubleSourceEdge;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (parent1 == parent2) &#123;</span><br><span class="line">        <span class="comment">// Circular path</span></span><br><span class="line">        circularEdge = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;iter[<span class="number">0</span>], iter[<span class="number">1</span>]&#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      parent[iter[<span class="number">1</span>]] = parent1;</span><br><span class="line">      father[iter[<span class="number">1</span>]] = iter[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (doubleSourceNode) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;father[doubleSourceNode], doubleSourceNode&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> *circularEdge;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> *parent, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == parent[index] || parent[index] == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> findParent(parent, parent[index]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findParentFork(<span class="keyword">int</span> *parent, <span class="keyword">int</span> *father, <span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == parent[index] || parent[index] == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;index, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (index == doubleSourceNode) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;findParent(parent, father[index]),</span><br><span class="line">        findParent(parent, subParent)&#125;);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> findParentFork(parent, father, father[index]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h4><p>在题解 1 中，我们通过在一次扫描中监控前两种情况来达成要求。在检测到其中一种情况发生后，我们将继续扫描，直到第三种情况发生或者到达终点。这个算法很好的达到了我们的预期效果，但是有很多问题。</p>
<p>首先，在触发「双源」后，后续扫描复杂度陡增，严重影响了程序运行效率。其次，过于复杂的逻辑判断大大增加了编程难度。最后，在“寻找祖先”的过程中，大量可以复用的信息被浪费掉。</p>
<p>那么有没有什么优化的办法呢？</p>
<p>首先，我们考虑一下这三种情况。实际上我们不必在扫描时判断如此多的内容。首先，我们进行一次扫描，查看是否有「双源」的发生。若有，我们去除触发双源的边，再进行一次查找，此时如果没有回环的发生，那么这条边就是目标边，否则，就说明是另一条「双源」边在回环内，那条边也就是目标边。如果没有发生「双源」，则是简单的回环问题，找到成环边即可。</p>
<p>然后，我们考虑一下信息复用的问题。由动态规划的思想，我们可以在每次寻找祖先的过程中，更新整个路径上的所有祖先，从而大大减少后续的查找祖先的时间。</p>
<p>具体实现见题解 2。</p>
<h3 id="题解-2（最优解）"><a href="#题解-2（最优解）" class="headerlink" title="题解 2（最优解）"></a>题解 2（最优解）</h3><h4 id="结果截图-1"><a href="#结果截图-1" class="headerlink" title="结果截图"></a>结果截图</h4><img src="/Leetcode/Leetcode-685-Redundant-Connection-II/finalresult.png" title="FinalResult">
<h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fast = []() &#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> parent1, parent2;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; doubleSourceEdge1, doubleSourceEdge2;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantDirectedConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = edges.size();</span><br><span class="line">    <span class="keyword">int</span> *father = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    doubleSourceEdge1 = doubleSourceEdge2 = <span class="literal">nullptr</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">memset</span>(father, <span class="number">0</span>, (size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Looking for node which has two sources</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter : edges) &#123;</span><br><span class="line">      <span class="keyword">if</span> (father[iter[<span class="number">1</span>]]) &#123;</span><br><span class="line">        <span class="comment">// found</span></span><br><span class="line">        doubleSourceEdge1 = &#123;</span><br><span class="line">          father[iter[<span class="number">1</span>]], iter[<span class="number">1</span>]</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        doubleSourceEdge2 = iter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// break;</span></span><br><span class="line">      &#125;</span><br><span class="line">      father[iter[<span class="number">1</span>]] = iter[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; ++i) father[i] = i;</span><br><span class="line">    <span class="comment">// Looking for an edge which forms a circular path</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter: edges) &#123;</span><br><span class="line">      <span class="keyword">if</span> (doubleSourceEdge2 &amp;&amp; iter == *doubleSourceEdge2) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      parent1 = findParent(father, iter[<span class="number">0</span>]);</span><br><span class="line">      parent2 = findParent(father, iter[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (parent1 == parent2) &#123;</span><br><span class="line">        <span class="comment">// found</span></span><br><span class="line">        <span class="keyword">if</span> (doubleSourceEdge1.empty())</span><br><span class="line">          <span class="keyword">return</span> iter;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">          <span class="keyword">return</span> doubleSourceEdge1;</span><br><span class="line">      &#125;</span><br><span class="line">      father[iter[<span class="number">1</span>]] = iter[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doubleSourceEdge2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> *&amp;father, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == father[index])</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> father[index] = findParent(father, father[index]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Leetcode/Leetcode-685-Redundant-Connection-II/" data-id="cjn6rnst3002twnxmibzbtcyk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/">Leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Make-Full-Use-of-Your-VPS-Server" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Tips/Make-Full-Use-of-Your-VPS-Server/" class="article-date">
  <time datetime="2018-09-21T01:12:18.000Z" itemprop="datePublished">2018-09-21</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tips/">Tips</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Tips/Make-Full-Use-of-Your-VPS-Server/">Make Full Use of Your VPS Server</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【预告】相信很多小伙伴都有一个自己的 VPS 服务器，可是大多数人只是在上面挂载一个 SS/SSR 服务器（这篇里也有讲），然后就对它不管不问了……看看你们 VPS 的 CPU 利用率，这难道不是在暴殄天物嘛！如果你和我一样有 VPS 资源被白白浪费的苦恼，那么这篇文章或许能解决你的问题～【本文长期更新】</p>
        
          <p class="article-more-link">
            <a href="/Tips/Make-Full-Use-of-Your-VPS-Server/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Tips/Make-Full-Use-of-Your-VPS-Server/" data-id="cjn6rnsry000ewnxmajgsz3nl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VPS-server/">VPS server</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode-124-Binary-Tree-Maximum-Path-Sum" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Leetcode/Leetcode-124-Binary-Tree-Maximum-Path-Sum/" class="article-date">
  <time datetime="2018-09-20T12:31:21.000Z" itemprop="datePublished">2018-09-20</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Leetcode/Leetcode-124-Binary-Tree-Maximum-Path-Sum/">Leetcode 124. Binary Tree Maximum Path Sum</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a>124. Binary Tree Maximum Path Sum</h3><ul>
<li><strong>Difficulty:</strong> Hard</li>
<li><strong>Total Accepted:</strong> 145.3K</li>
<li><strong>Total Submissions:</strong> 519.8K</li>
</ul>
<p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="AC-截图"><a href="#AC-截图" class="headerlink" title="AC 截图"></a>AC 截图</h3><img src="/Leetcode/Leetcode-124-Binary-Tree-Maximum-Path-Sum/finalresult.png" title="FinalResult">
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个非空的二叉树，我们需要找到一个路径，使得路径上所有节点的值的和最大。需要注意的是，该路径最少需要包含一个节点，同时这个路径可以不沿着树边「由父到子」的方向走，但是不可以回头。同时，这个路径也不需要经过根结点。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很简单的 DFS + 贪心算法就可以求解。因为路径可以不经过根节点，因而任何子过程都有可能产生一个最优解。为了记录这些最优解，我们建立一个全局变量来记录当前的最优解。考虑一条路径，以最上层的节点的视角，其有三种可能的形状：向左/右子树延伸，同时向两个子树延伸，以及一个裸节点。</p>
<p>其中，第一种情况和第三种情况的路径可以被上层节点复用，来构成新的路径；而第二种情况的路径则不能拓展，因为路径不能回头，因而不可能有分叉。因而，在每个子过程中，我们获取左右子树的非第二种情况的最大 sum 的路径，将其中大于 0 的都与节点的值相加，并尝试更新全局最大值。然后选择其中最大的大于零的 sum，与节点的值相加，并返回该值，作为「非第二种情况的最大值」。</p>
<p>然后，不要忘记加上 <code>iostream</code> 的加速装置～我们的最优解就出炉啦：</p>
<h3 id="题解（最优解）"><a href="#题解（最优解）" class="headerlink" title="题解（最优解）"></a>题解（最优解）</h3><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> runfirst = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> globalMax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      globalMax = root-&gt;val;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> maxSum = root-&gt;val, temp;</span><br><span class="line"></span><br><span class="line">      temp = subtreeMax(root-&gt;left);</span><br><span class="line">      <span class="keyword">if</span> (temp &gt; <span class="number">0</span>)</span><br><span class="line">        maxSum += temp;</span><br><span class="line">        </span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; temp;</span><br><span class="line">      </span><br><span class="line">      temp = subtreeMax(root-&gt;right);</span><br><span class="line">      <span class="keyword">if</span> (temp &gt; <span class="number">0</span>)</span><br><span class="line">        maxSum += temp;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span> (maxSum &gt; globalMax)</span><br><span class="line">        globalMax = maxSum;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> globalMax;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subtreeMax</span><span class="params">(TreeNode* subroot)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (subroot == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span> val = subroot-&gt;val, temp1, temp2;</span><br><span class="line"></span><br><span class="line">      temp1 = subtreeMax(subroot-&gt;left);</span><br><span class="line">      temp2 = subtreeMax(subroot-&gt;right);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (temp1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (temp1 &gt; temp2) &#123;</span><br><span class="line">            val += temp1;</span><br><span class="line">            <span class="keyword">if</span> (val + temp2 &gt; globalMax)</span><br><span class="line">              globalMax = val + temp2;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            val += temp2;</span><br><span class="line">            <span class="keyword">if</span> (val + temp1 &gt; globalMax)</span><br><span class="line">              globalMax = val + temp1;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          val += temp1;</span><br><span class="line">          <span class="keyword">if</span> (val &gt; globalMax)</span><br><span class="line">            globalMax = val;</span><br><span class="line">          <span class="keyword">return</span> val; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (temp2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        val += temp2;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; globalMax)</span><br><span class="line">          globalMax = val;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (val &gt; globalMax)</span><br><span class="line">        globalMax = val;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Leetcode/Leetcode-124-Binary-Tree-Maximum-Path-Sum/" data-id="cjn6rnsrv0009wnxmyuonlnp4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/">Leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode-4-Median-of-Two-Sorted-Arrays" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/" class="article-date">
  <time datetime="2018-09-16T08:08:02.000Z" itemprop="datePublished">2018-09-16</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/">Leetcode 4. Median of Two Sorted Arrays</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h3><ul>
<li><strong>Difficulty:</strong> Hard</li>
<li><strong>Total Accepted:</strong> 301.7K</li>
<li><strong>Total Submissions:</strong> 1.3M</li>
</ul>
<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
<p><strong>Example1:</strong></p>
<pre><code>nums1 = [1, 3]
nums2 = [2]

The median is 2.0
</code></pre><p><strong>Exaple2:</strong></p>
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
</code></pre><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="AC-截图"><a href="#AC-截图" class="headerlink" title="AC 截图"></a>AC 截图</h3><img src="/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/finalresult.png" title="FinalResult">
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>本题要求寻找两个有序序列合并后的序列的「中位数」。同时要求 O(log (m+n)) 级别的时间复杂度。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>在一个序列中寻找一个数，又要求 O(log) 级的时间复杂度，我们很容易想到通过不断分割区间来寻找目标数的二分查找法。那么唯一的问题是如何在两个有序序列上应用针对单条序列的二分查找法了。</p>
<p>创建变量 <code>start1</code>、<code>end1</code>、<code>start2</code>、<code>end2</code>、<code>halfSize</code>，分别标识两个序列当前处理区间的头和尾，以及用于计数左侧较小数个数。通过不断对比两个区间中间数的大小，来使得中间数靠近，直到 <code>halfSize</code> 达到序列长度的一半即可（题解中为从一半减少到1）。</p>
<h3 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h3><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lengthSum = nums1.size() + nums2.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (lengthSum % <span class="number">2</span> == <span class="number">1</span>) ?</span><br><span class="line">      (<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), (lengthSum + <span class="number">1</span>) / <span class="number">2</span>):</span><br><span class="line">      ((<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>,nums2.size(), lengthSum / <span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">      (<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>,nums2.size(), lengthSum / <span class="number">2</span>)) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findMedian</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">const</span> <span class="keyword">int</span> start1,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">int</span> end1, <span class="keyword">const</span> <span class="keyword">int</span> start2, <span class="keyword">const</span> <span class="keyword">int</span> end2,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">int</span> halfSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size1 = end1 - start1, size2 = end2 - start2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size1 &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + halfSize - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (size2 &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums1[start1 + halfSize - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (halfSize == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid1 = (end1 + start1) / <span class="number">2</span>, mid2 = (end2 + start2) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums1[mid1] &lt;= nums2[mid2]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (size1 / <span class="number">2</span> + size2 / <span class="number">2</span> + <span class="number">1</span> &gt;= halfSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMedian(nums1, nums2, start1, end1, start2, mid2, halfSize);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findMedian(nums1, nums2, mid1 + <span class="number">1</span>, end1, start2, end2,</span><br><span class="line">                          halfSize - size1 / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (size1 / <span class="number">2</span> + size2 / <span class="number">2</span> + <span class="number">1</span> &gt;= halfSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMedian(nums1, nums2, start1, mid1, start2, end2, halfSize);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findMedian(nums1, nums2, start1, end1, mid2 + <span class="number">1</span>, end2,</span><br><span class="line">                          halfSize - size2 / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="AC-截图-1"><a href="#AC-截图-1" class="headerlink" title="AC 截图"></a>AC 截图</h4><img src="/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/solve1.png" title="AC">
<h4 id="题解分析"><a href="#题解分析" class="headerlink" title="题解分析"></a>题解分析</h4><p>虽然这个题解顺利通过了测试，但是我们发现，前面的最优解还有相当多……那么尝试对于代码进行优化。我们知道，递归方法相对于迭代法需要在每次递归时，对栈进行单独的操作——在空间和时间复杂度上都不如迭代法。</p>
<p>那么，是否可以把递归法转换为迭代法呢——当然可以啦～</p>
<h3 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h3><h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lengthSum = nums1.size() + nums2.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (lengthSum % <span class="number">2</span> == <span class="number">1</span>) ?</span><br><span class="line">      (<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), (lengthSum + <span class="number">1</span>) / <span class="number">2</span>) : </span><br><span class="line">      ((<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), lengthSum / <span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">      (<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), lengthSum / <span class="number">2</span>)) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findMedian</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> halfSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size1, size2, mid1, mid2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      size1 = end1 - start1;</span><br><span class="line">      size2 = end2 - start2;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size1 &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + halfSize - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (size2 &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums1[start1 + halfSize - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (halfSize == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">      mid1 = (end1 + start1) / <span class="number">2</span>;</span><br><span class="line">      mid2 = (end2 + start2) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nums1[mid1] &lt;= nums2[mid2]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size1 / <span class="number">2</span> + size2 / <span class="number">2</span> + <span class="number">1</span> &gt;= halfSize) &#123;</span><br><span class="line">          end2 = mid2;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          start1 = mid1 + <span class="number">1</span>;</span><br><span class="line">          halfSize -= size1 / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size1 / <span class="number">2</span> + size2 / <span class="number">2</span> + <span class="number">1</span> &gt;= halfSize) &#123;</span><br><span class="line">          end1 = mid1;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          start2 = mid2 + <span class="number">1</span>;</span><br><span class="line">          halfSize -= size2 / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="AC-截图-2"><a href="#AC-截图-2" class="headerlink" title="AC 截图"></a>AC 截图</h4><img src="/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/solve2.png" title="AC">
<h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="题解分析"></a>题解分析</h4><p>嗯？这两个的耗时完全没有区别啊！看来是编译器已经把我的递归优化掉了……那么和第一梯队如此大的时间差又是从何而来呢？</p>
<p>参加过 ACM 的同学应该都知道，能用 <code>scanf</code> 的代码绝对不用 <code>cin</code>。不过其实 <code>cin</code> 的效率并不算差，只是，我们需要对其进行一些优化才能让他发挥出应有的实力。要想解放 <code>cin</code> 实力的封印，一行代码足矣：</p>
<pre><code>ios::sync_with_stdio(false);
</code></pre><p>这会禁用 cin／cout 和 scanf／printf 之间的同步等待，从而大幅提升 cin 的效率——甚至可以直追 scanf。但是这里我们又有一个问题了，我们函数的调用显然是在输入操作之后，怎样才能让这个函数在输入操作前生效呢？当然是有办法的啦：</p>
<h3 id="题解3（最优解）"><a href="#题解3（最优解）" class="headerlink" title="题解3（最优解）"></a>题解3（最优解）</h3><h4 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> runfirst = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> lengthSum = nums1.size() + nums2.size();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (lengthSum % <span class="number">2</span> == <span class="number">1</span>) ?</span><br><span class="line">        (<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), (lengthSum + <span class="number">1</span>) / <span class="number">2</span>) :</span><br><span class="line">        ((<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), lengthSum / <span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">        (<span class="keyword">double</span>)findMedian(nums1, nums2, <span class="number">0</span>, nums1.size(), <span class="number">0</span>, nums2.size(), lengthSum / <span class="number">2</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMedian</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums2,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> start1, <span class="keyword">int</span> end1,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> start2, <span class="keyword">int</span> end2,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> halfSize)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> size1, size2, mid1, mid2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            size1 = end1 - start1;</span><br><span class="line">            size2 = end2 - start2;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (size1 &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + halfSize - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (size2 &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums1[start1 + halfSize - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (halfSize == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">            mid1 = (end1 + start1) / <span class="number">2</span>;</span><br><span class="line">            mid2 = (end2 + start2) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums1[mid1] &lt;= nums2[mid2]) &#123;</span><br><span class="line">              <span class="keyword">if</span> (size1 / <span class="number">2</span> + size2 / <span class="number">2</span> + <span class="number">1</span> &gt;= halfSize) &#123;</span><br><span class="line">                end2 = mid2;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                start1 = mid1 + <span class="number">1</span>;</span><br><span class="line">                halfSize -= size1 / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (size1 / <span class="number">2</span> + size2 / <span class="number">2</span> + <span class="number">1</span> &gt;= halfSize) &#123;</span><br><span class="line">                end1 = mid1;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                start2 = mid2 + <span class="number">1</span>;</span><br><span class="line">                halfSize -= size2 / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="AC-截图-3"><a href="#AC-截图-3" class="headerlink" title="AC 截图"></a>AC 截图</h4><img src="/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/finalresult.png" title="FinalResult">
<h4 id="题解分析-2"><a href="#题解分析-2" class="headerlink" title="题解分析"></a>题解分析</h4><p>通过声明一个静态的常量变量，我们使得后面这个自执行的函数甚至可以在编译阶段预执行，从而在输入输出前完成对于 cin/cout 的设置～总时耗也从 56ms 下降到了 16ms，妥妥的第一梯队～看来算法和实现细节都是保证程序执行速度的重要环节呢。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Leetcode/Leetcode-4-Median-of-Two-Sorted-Arrays/" data-id="cjn6rnst2002qwnxmxlh32myn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/">Leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Service-Computing-01-Private-Cloud-Service" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Service-Computing/Service-Computing-01-Private-Cloud-Service/" class="article-date">
  <time datetime="2018-09-08T10:59:32.000Z" itemprop="datePublished">2018-09-08</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Service-Computing/">Service Computing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Service-Computing/Service-Computing-01-Private-Cloud-Service/">Service Computing 01 - Private Cloud Service</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于作者水平有限，<strong>内容可能存在错漏，若有发现，还望您在评论区指出。</strong> 本博客内容仅适用于 VMWare Workstation，Virtual Box 上的操作可能有所不同。</p>
<h1 id="使用-VMWare-Workstation-让-PC-提供云桌面服务"><a href="#使用-VMWare-Workstation-让-PC-提供云桌面服务" class="headerlink" title="使用 VMWare Workstation 让 PC 提供云桌面服务"></a>使用 VMWare Workstation 让 PC 提供云桌面服务</h1>
        
          <p class="article-more-link">
            <a href="/Service-Computing/Service-Computing-01-Private-Cloud-Service/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Service-Computing/Service-Computing-01-Private-Cloud-Service/" data-id="cjn6rnst6002zwnxmy0myb0p1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cloud-Service/">Cloud Service</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Service-Computing/">Service Computing</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode-41-First-Missing-Positive" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Leetcode/Leetcode-41-First-Missing-Positive/" class="article-date">
  <time datetime="2018-09-07T01:55:24.000Z" itemprop="datePublished">2018-09-07</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Leetcode/Leetcode-41-First-Missing-Positive/">Leetcode 41. First Missing Positive</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41. First Missing Positive"></a>41. First Missing Positive</h3><ul>
<li><strong>Difficulty:</strong> Hard</li>
<li><strong>Total Accepted:</strong> 152.5K</li>
<li><strong>Total Submissions:</strong> 571.7K </li>
</ul>
<p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [1, 2, 0]
Output: 3
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [3,4,-1,1]
Output: 2
</code></pre><p><strong>Example 3:</strong></p>
<pre><code>Input: [7,8,9,11,12]
Output: 1
</code></pre><p><strong>Note:</strong></p>
<p>Your algorithm should run in O(n) time and uses constant extra space.</p>
<p><a href="https://leetcode.com/problems/first-missing-positive/description/" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="AC-截图"><a href="#AC-截图" class="headerlink" title="AC 截图"></a>AC 截图</h3><img src="/Leetcode/Leetcode-41-First-Missing-Positive/finalresult.png" title="FinalResult">
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>本题要求寻找到一串未排序的整数中，缺失的最小的正整数。同时要求 $O(n)$ 级的时间复杂度和常量级的空间开销。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>最容易想到的解题方法莫过于从 1 开始，将正整数依次在整个数组中寻找一遍。但是这种在无序数组上进行的扫描，时间复杂度为 $O(n^2)$，显然是不符合要求的。</p>
<p>另一个容易想到的方法是建立一个等规模的布尔数组，初始值为 <code>false</code>，然后扫描一次原始数组，将对应下标的布尔值置为 <code>true</code>。最后扫描一遍布尔数组，即可以以 $O(n)$ 的时间复杂度完成。但是这种方法需要开辟一个变长的空间，不符合题目「常量级空间开销」的要求。</p>
<p>那么要如何优化这两种方法，来满足题目要求呢？</p>
<p>从第一种方法出发，既然无序的数组上扫描会超时，那么我们就尝试在 $O(n)$ 时间复杂度内构建一个“特殊的”有序数组即可。</p>
<p>从第二种方法出发，既然不允许变长的额外空间开销，那么我们就尝试使用原数组的空间来作为“布尔数组”即可。</p>
<p>两种方法的优化最后都指向同一个解法：先对原数组进行操作，使之可以在一次扫描后得出结果。</p>
<p>那么如何进行操作呢？我们知道，我们的目标是寻找缺失的最小的正整数，那么我们可以吧所有数字放到其对应的位置（比如数字 1 放到下标为 0 的位置上，数字 4 放到下标为 3 的位置上），这样一来，<code>array[index] == index + 1</code> 这些布尔值就构成了第二种方法中的“布尔数组”，不满足这个条件的最小的 <code>index</code>，对应的数字 <code>index + 1</code> 就是题解。</p>
<p>构建数组的过程也是简单的，顺序扫描整个数组，不断将当前位置的数字和其应该处于的位置上的数字进行交换，就可以在 $O(n)$ 的时间复杂度下完成操作。再加上最后的扫描求解，整个解法的复杂度为 $O(n)$.</p>
<h3 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h3><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> index, length;</span><br><span class="line">        length = nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; length; ++index) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[index] &gt; <span class="number">0</span> &amp;&amp; nums[index] &lt;= length &amp;&amp; </span><br><span class="line">                    nums[index] != nums[nums[index] - <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums[index], nums[nums[index] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; length; ++index) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] != index + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="AC-截图-1"><a href="#AC-截图-1" class="headerlink" title="AC 截图"></a>AC 截图</h4><img src="/Leetcode/Leetcode-41-First-Missing-Positive/result1.png" title="AC">
<h4 id="题解分析"><a href="#题解分析" class="headerlink" title="题解分析"></a>题解分析</h4><p>虽然这个题解顺利通过了测试，但是竟然还有 16.03% 的更优解？是我算法的问题吗？</p>
<p>打开最优解的示例代码一看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// time: O(n), space: O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i]<span class="number">-1</span>] != nums[i]) &#123;</span><br><span class="line">                swap(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>乍一眼看过去……这不和我是一样的吗？而且 i++ 的效率显然不如 ++i，怎么可能还比我快？他甚至还在每个 for 循环中重新声明变量 i，这肯定是比我直接声明好进行复用要更慢啊！不信邪的我也改了一下自己的代码，于是有了题解2……</p>
<h3 id="题解2（最优解）"><a href="#题解2（最优解）" class="headerlink" title="题解2（最优解）"></a>题解2（最优解）</h3><h4 id="c-代码"><a href="#c-代码" class="headerlink" title="c++ 代码"></a>c++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        length = nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; length; ++index) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[index] &gt; <span class="number">0</span> &amp;&amp; nums[index] &lt;= length &amp;&amp; </span><br><span class="line">                    nums[index] != nums[nums[index] - <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums[index], nums[nums[index] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; length; ++index) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] != index + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="AC-截图-2"><a href="#AC-截图-2" class="headerlink" title="AC 截图"></a>AC 截图</h4><img src="/Leetcode/Leetcode-41-First-Missing-Positive/finalresult.png" title="FinalResult">
<h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="题解分析"></a>题解分析</h4><p>看样子确实是重新声明的写法会更快……但……<strong>为什么复用的效率反而不如每次重新声明高？这不科学！我不接受！</strong></p>
<p>如何找到问题的源头呢？当然是反汇编啦～</p>
<p>测试代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">solve1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    length = nums.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (nums[index] &gt; <span class="number">0</span> &amp;&amp; nums[index] &lt;= length &amp;&amp;</span><br><span class="line">        nums[index] != nums[nums[index] - <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(nums[index], nums[nums[index] - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[index] != index + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">solve2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index, length;</span><br><span class="line">    length = nums.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (nums[index] &gt; <span class="number">0</span> &amp;&amp; nums[index] &lt;= length &amp;&amp;</span><br><span class="line">        nums[index] != nums[nums[index] - <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(nums[index], nums[nums[index] - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[index] != index + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Solution ins;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">auto</span> ans = ins.solve1(input); ans = ins.solve2(input);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://siskonemilia.github.io/Leetcode/Leetcode-41-First-Missing-Positive/winasm1.s">Windows 汇编：solve1</a></p>
<p><a href="https://siskonemilia.github.io/Leetcode/Leetcode-41-First-Missing-Positive/winasm2.s">Windows 汇编：solve2</a></p>
<p>令人吃惊的是：两者的汇编代码几乎是完全一样的！唯一的区别在于：由于 <code>index</code> 和 <code>length</code> 的声明先后顺序不同，其在内存中的地址（相对于ebp）在两个函数中对调了。这虽然没能验证反复声明反而更快的结果，但至少说明了 <strong>在 for 循环初始化语句中声明变量，不会比在外部声明更耗时</strong>。同时也告诉我们，<strong>单纯通过高级语言编写中的直觉推测程序在机器上执行的效率是危险的</strong>。</p>
<p>那么，为什么 <code>solve2</code> 会更快呢？事实上，经过测试，在 Windows VS 环境下，二者速度是基本一致的。那么是编译器和环境的问题吗？</p>
<p>查找 Leetcode 的编译环境，我了解到其使用的是 G++ 6.4，C++14 标准。于是我在 MacOS 环境下对于其使用 g++ 进行编译，并且利用 objdump 得到汇编结果，通过重定向保存到 <code>main.s</code> 文件内：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -c main.cpp -std=c++14</span><br><span class="line">objdump -d -S main.o &gt; main.s</span><br></pre></td></tr></table></figure>
<p><a href="https://siskonemilia.github.io/Leetcode/Leetcode-41-First-Missing-Positive/macasm1.s">g++ on MacOS 汇编：solve1</a></p>
<p><a href="https://siskonemilia.github.io/Leetcode/Leetcode-41-First-Missing-Positive/macasm2.s">g++ on MacOS 汇编：solve2</a></p>
<p>然而结果依旧如故——二者几乎是完全一样的！至此我就拿它毫无办法了……根据网上查询的结果推测，可能是空间高度受限的情况下，生命周期长的 <code>index</code> 导致了高速缓冲数据的频繁不命中，但是这个说法依旧有很多问题……希望哪位大佬能够不吝赐教。</p>
<p>附上完整的汇编代码（macos）：</p>
<p><a href="https://siskonemilia.github.io/Leetcode/Leetcode-41-First-Missing-Positive/main.s">g++ on MacOS 汇编</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Leetcode/Leetcode-41-First-Missing-Positive/" data-id="cjn6rnst1002mwnxmd7xbv97o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/">Leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Get-Started-with-Unity3D-8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Unity3D/Get-Started-with-Unity3D-8/" class="article-date">
  <time datetime="2018-06-26T13:38:35.000Z" itemprop="datePublished">2018-06-26</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Unity3D/Get-Started-with-Unity3D-8/">Get Started with Unity3D - 8</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="网络对战-天际赛车"><a href="#网络对战-天际赛车" class="headerlink" title="网络对战-天际赛车"></a>网络对战-天际赛车</h2><p>经历了一个学期的各种学习，我们今天终于迎来了 Unity 制作网游的重要一步——网络模块。网络模块的存在使得游戏可以随时变身客户端／服务端，并且让多人共同进行游戏——没有什么比分享更能让人快乐的了！那么这次我们制作的是《天际赛车》，玩家将驾驶飞行器和同伴一起穿过圆环，争取分数！单人预览：</p>
<img src="/Unity3D/Get-Started-with-Unity3D-8/GIF.gif" title="preview">
        
          <p class="article-more-link">
            <a href="/Unity3D/Get-Started-with-Unity3D-8/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Unity3D/Get-Started-with-Unity3D-8/" data-id="cjn6rnssz002gwnxmxdym4l3b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/">Unity3D</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Get-Started-with-Unity3D-7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Unity3D/Get-Started-with-Unity3D-7/" class="article-date">
  <time datetime="2018-06-19T13:42:42.000Z" itemprop="datePublished">2018-06-19</time>
  
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity3D/">Unity3D</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Unity3D/Get-Started-with-Unity3D-7/">Get Started with Unity3D - 7</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="坦克大战-人工智障版"><a href="#坦克大战-人工智障版" class="headerlink" title="坦克大战 - 人工智障版"></a>坦克大战 - 人工智障版</h2><p><a href="http://www.chenxd59.cn/?p=213" target="_blank" rel="noopener">参考博客</a></p>
<p><a href="https://www.bilibili.com/video/av25222632/" target="_blank" rel="noopener">B站视频</a></p>
<p>游戏预览：</p>
        
          <p class="article-more-link">
            <a href="/Unity3D/Get-Started-with-Unity3D-7/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://siskonemilia.github.io/Unity3D/Get-Started-with-Unity3D-7/" data-id="cjn6rnssy002dwnxmlhyns3ew" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/">Unity3D</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Service-Computing/">Service Computing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tips/">Tips</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unity3D/">Unity3D</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB-Assignments/">WEB Assignments</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cloud-Service/">Cloud Service</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github-Pages/">Github Pages</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitment/">Gitment</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Remote-Floder/">Remote Floder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Service-Computing/">Service Computing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity3D/">Unity3D</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VPS-server/">VPS server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/">Windows</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 16px;">Algorithm</a> <a href="/tags/Cloud-Service/" style="font-size: 10px;">Cloud Service</a> <a href="/tags/Github-Pages/" style="font-size: 10px;">Github Pages</a> <a href="/tags/Gitment/" style="font-size: 10px;">Gitment</a> <a href="/tags/Golang/" style="font-size: 10px;">Golang</a> <a href="/tags/JavaScript/" style="font-size: 14px;">JavaScript</a> <a href="/tags/Leetcode/" style="font-size: 16px;">Leetcode</a> <a href="/tags/Remote-Floder/" style="font-size: 10px;">Remote Floder</a> <a href="/tags/Service-Computing/" style="font-size: 12px;">Service Computing</a> <a href="/tags/Unity3D/" style="font-size: 20px;">Unity3D</a> <a href="/tags/VPS-server/" style="font-size: 10px;">VPS server</a> <a href="/tags/WEB/" style="font-size: 18px;">WEB</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/Service-Computing/Golang-CLI-Program-Selpg/">Service Computing 02 - Golang CLI Program - Selpg</a>
          </li>
        
          <li>
            <a href="/Leetcode/Leetcode-839-Similar-String-Groups/">Leetcode 839. Similar String Groups</a>
          </li>
        
          <li>
            <a href="/Leetcode/Leetcode-685-Redundant-Connection-II/">Leetcode 685. Redundant Connection II</a>
          </li>
        
          <li>
            <a href="/Tips/Make-Full-Use-of-Your-VPS-Server/">Make Full Use of Your VPS Server</a>
          </li>
        
          <li>
            <a href="/Leetcode/Leetcode-124-Binary-Tree-Maximum-Path-Sum/">Leetcode 124. Binary Tree Maximum Path Sum</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Emilia<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a><br>
      <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_uv"> 
          Visitors: <span id="busuanzi_value_site_uv">loading...</span>
      </span>
    </div>
  </div>
  
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>